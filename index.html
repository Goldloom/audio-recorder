<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; media-src 'self' blob:; connect-src 'self' https://api.github.com https://cdnjs.cloudflare.com;">
    <title>ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ë…¹ìŒê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            position: relative;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 24px;
            padding: 40px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
        }

        h1 {
            text-align: center;
            color: #1a1a2e;
            margin-bottom: 8px;
            font-size: 28px;
            font-weight: 600;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
            font-size: 14px;
        }

        .format-badge {
            text-align: center;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
            margin: 0 auto 20px;
            width: fit-content;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .help-icon {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: help;
        }

        .help-icon:hover .tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .tooltip {
            position: absolute;
            top: 35px;
            right: 0;
            background: #1a1a2e;
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            line-height: 1.6;
            width: 280px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .tooltip strong {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .tooltip ol {
            margin-left: 18px;
            padding: 0;
        }

        .tooltip li {
            margin-bottom: 4px;
        }

        .source-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        .source-btn {
            flex: 1;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .source-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .source-btn.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .source-btn .icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .source-btn .label {
            font-size: 13px;
            font-weight: 600;
        }

        .source-btn .desc {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 3px;
        }

        .visualizer-container {
            background: #1a1a2e;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 25px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #visualizer {
            width: 100%;
            height: 60px;
        }

        .timer {
            text-align: center;
            font-size: 48px;
            font-weight: 300;
            color: #1a1a2e;
            margin-bottom: 25px;
            font-family: 'Courier New', monospace;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-record {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .btn-record.recording {
            animation: pulse 1.5s infinite;
        }

        .btn-stop {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .btn-pause {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7);
            }

            50% {
                box-shadow: 0 0 0 20px rgba(231, 76, 60, 0);
            }
        }

        .btn svg {
            width: 28px;
            height: 28px;
            fill: white;
        }

        .status {
            text-align: center;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .status.ready {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status.recording {
            background: #ffebee;
            color: #c62828;
        }

        .status.paused {
            background: #fff8e1;
            color: #f57f17;
        }

        .status.error {
            background: #fce4ec;
            color: #c2185b;
        }

        .recordings {
            max-height: 300px;
            overflow-y: auto;
        }

        .recordings h2 {
            color: #1a1a2e;
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .recordings-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-download-all {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-download-all:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        .btn-download-all:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recording-item {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .recording-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .recording-info {
            flex: 1;
        }

        .recording-name {
            font-weight: 600;
            color: #1a1a2e;
            font-size: 14px;
        }

        .recording-meta {
            font-size: 12px;
            color: #888;
            margin-top: 3px;
        }

        .recording-badge {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 20px;
            font-weight: 600;
        }

        .badge-system {
            background: #e3f2fd;
            color: #1565c0;
        }

        .badge-mic {
            background: #fce4ec;
            color: #c2185b;
        }

        .badge-both {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .recording-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .btn-small:hover {
            transform: scale(1.1);
        }

        .btn-small svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        .btn-download {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .btn-delete {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .recording-item audio {
            width: 100%;
            height: 40px;
            border-radius: 8px;
        }

        .empty-state {
            text-align: center;
            color: #888;
            padding: 30px;
            font-size: 14px;
        }

        /* ë¡œê·¸ ì°½ ìŠ¤íƒ€ì¼ */
        .log-panel {
            margin-top: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
        }

        /* ìë™í™” ì„¤ì • ê·¸ë£¹ ìŠ¤íƒ€ì¼ */
        .settings-group {
            margin-top: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid #dee2e6;
        }

        .settings-title {
            color: #1a1a2e;
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
            font-weight: 600;
        }

        .settings-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .settings-content .toggle-container {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
        }

        .settings-content .toggle-container:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }

        .log-panel h2 {
            color: #1a1a2e;
            font-size: 16px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .log-controls {
            display: flex;
            gap: 8px;
        }

        .btn-clear-log {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-clear-log:hover {
            background: #c0392b;
        }

        .btn-export-log {
            background: #3498db;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-export-log:hover {
            background: #2980b9;
        }

        .log-container {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 12px;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            line-height: 1.6;
        }

        .log-container::-webkit-scrollbar {
            width: 8px;
        }

        .log-container::-webkit-scrollbar-track {
            background: #2c2c3e;
            border-radius: 4px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .log-container::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.03);
        }

        .log-entry.log-info {
            color: #5dade2;
        }

        .log-entry.log-success {
            color: #52c41a;
        }

        .log-entry.log-warning {
            color: #faad14;
        }

        .log-entry.log-error {
            color: #ff4d4f;
        }

        .log-timestamp {
            color: #888;
            margin-right: 8px;
        }

        .log-message {
            color: inherit;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-item input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }

        .extra-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn-new-lecture {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-new-lecture:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }

        .btn-new-lecture:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 10px;
        }

        .toggle-label {
            font-size: 13px;
            color: #333;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked+.toggle-slider {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .toggle-switch input:checked+.toggle-slider:before {
            transform: translateX(24px);
        }

        .silence-indicator {
            font-size: 11px;
            color: #888;
            margin-left: 5px;
        }

        .silence-indicator.active {
            color: #27ae60;
            font-weight: 600;
        }

        .capture-section {
            background: #fff3e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .capture-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .capture-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .capture-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .capture-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }

        .capture-option select {
            padding: 5px 8px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 12px;
            cursor: pointer;
            background: white;
        }

        .capture-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .capture-status {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .capture-status.active {
            color: #e65100;
            font-weight: 500;
        }

        .sensitivity-slider {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 10px;
        }

        .sensitivity-slider input[type="range"] {
            width: 100px;
            cursor: pointer;
        }

        .sensitivity-value {
            font-size: 12px;
            color: #666;
            min-width: 30px;
        }

        .curriculum-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
        }

        .curriculum-help {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .curriculum-help-icon {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
        }

        .curriculum-help-icon:hover+.curriculum-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .curriculum-tooltip {
            position: absolute;
            top: 25px;
            left: 0;
            background: #1a1a2e;
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            line-height: 1.7;
            width: 320px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .curriculum-tooltip strong {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #f093fb;
        }

        .curriculum-tooltip code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        .curriculum-tooltip ul {
            margin: 8px 0;
            padding-left: 18px;
        }

        .curriculum-tooltip li {
            margin-bottom: 4px;
        }

        .curriculum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .curriculum-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .speed-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-selector label {
            font-size: 13px;
            color: #555;
        }

        .speed-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 13px;
            cursor: pointer;
            background: white;
        }

        .curriculum-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            margin-bottom: 10px;
        }

        .curriculum-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .curriculum-textarea::placeholder {
            color: #aaa;
        }

        .btn-parse {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-parse:hover {
            transform: scale(1.02);
        }

        .chapter-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .chapter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .chapter-item.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .chapter-item.completed {
            background: #d4edda;
            color: #155724;
        }

        .chapter-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 10px;
        }

        .chapter-time {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            opacity: 0.8;
        }

        .chapter-progress {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .clear-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
        }

        .clear-btn:hover {
            background: #c0392b;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 12px 15px;
            border-radius: 10px;
            font-size: 12px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .update-date {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 11px;
            color: #999;
            font-family: inherit;
        }

        /* í”„ë¡œê·¸ë ˆìŠ¤ ë°” ìŠ¤íƒ€ì¼ */
        .progress-section {
            margin-bottom: 25px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .progress-container {
            width: 100%;
            height: 10px;
            background: #eee;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-bar.waiting {
            width: 100%;
            background: linear-gradient(90deg, #eee 0%, #667eea 50%, #eee 100%);
            background-size: 200% 100%;
            animation: waiting-shimmer 1.5s infinite linear;
        }

        @keyframes waiting-shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="lastUpdate" class="update-date">ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: í™•ì¸ ì¤‘...</div>
        <h1>ğŸ§ ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ë…¹ìŒê¸°</h1>


        <div class="help-icon">
            ?
            <div class="tooltip">
                <strong>ğŸ“Œ ì‚¬ìš© ë°©ë²•</strong>
                <ol>
                    <li>ë…¹ìŒ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</li>
                    <li>ê³µìœ  ì°½ì—ì„œ <strong>"Chrome íƒ­"</strong> ë˜ëŠ” <strong>"ì „ì²´ í™”ë©´"</strong> ì„ íƒ</li>
                    <li><strong>"ì˜¤ë””ì˜¤ ê³µìœ "</strong> ì²´í¬ âœ…</li>
                    <li>ê³µìœ  ë²„íŠ¼ í´ë¦­ í›„ ë…¹ìŒ ì‹œì‘!</li>
                </ol>
                <hr style="margin: 12px 0; border: none; border-top: 1px solid rgba(255,255,255,0.2);">
                <strong>âš ï¸ ë¸Œë¼ìš°ì € í˜¸í™˜ì„±</strong>
                <p style="margin-top: 6px; font-size: 11px; line-height: 1.5;">
                    <strong>Chrome, Edge</strong>ì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤.<br>
                    Firefox, SafariëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                </p>
            </div>
        </div>


        <div class="checkbox-group">
            <div class="checkbox-item">
                <input type="checkbox" id="includeSystemAudio" checked>
                <label for="includeSystemAudio">ğŸ”Š ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤</label>
            </div>
            <div class="checkbox-item">
                <input type="checkbox" id="includeMic">
                <label for="includeMic">ğŸ¤ ë§ˆì´í¬ (ë‚´ ëª©ì†Œë¦¬)</label>
            </div>
        </div>

        <div id="status" class="status ready">ì¤€ë¹„ë¨ - ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”</div>

        <div class="extra-controls">
            <button id="newLectureBtn" class="btn-new-lecture" title="í˜„ì¬ ë…¹ìŒì„ ì €ì¥í•˜ê³  ì¦‰ì‹œ ìƒˆë¡œìš´ ê°•ì˜ ë…¹ìŒì„ ì‹œì‘í•©ë‹ˆë‹¤">
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: white;">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                </svg>
                ìƒˆ ê°•ì˜ ì‹œì‘ (ìˆ˜ë™ ë¶„í• )
            </button>
        </div>

        <div class="split-mode-section" style="background: #f8f9fa; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
            <h3 style="font-size: 14px; font-weight: 600; color: #333; margin-bottom: 12px;">ğŸ¯ ë¶„í•  ëª¨ë“œ</h3>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                    <input type="radio" name="splitMode" value="manual" style="width: 18px; height: 18px;">
                    <div style="flex: 1;">
                        <strong style="font-size: 13px; display: block; margin-bottom: 2px;">ìˆ˜ë™ ë¶„í• </strong>
                        <span style="font-size: 11px; color: #666;">ìœ„ "ìƒˆ ê°•ì˜ ì‹œì‘" ë²„íŠ¼ì„ ëˆŒëŸ¬ ìˆ˜ë™ìœ¼ë¡œ ë¶„í• </span>
                    </div>
                </label>
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                    <input type="radio" name="splitMode" value="title" id="autoSplitMode" checked style="width: 18px; height: 18px;">
                    <div style="flex: 1;">
                        <strong style="font-size: 13px; display: block; margin-bottom: 2px;">ğŸ“Œ ì œëª© ê°ì§€ ìë™ ë¶„í•  (DOM ê¸°ë°˜)</strong>
                        <span style="font-size: 11px; color: #666;">ê°•ì˜ ì œëª© ë³€ê²½ ì‹œ ìë™ ë¶„í•  (1ì´ˆë§ˆë‹¤ ì²´í¬)</span>
                    </div>
                </label>
                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; padding: 10px; background: white; border-radius: 8px; border: 2px solid #e0e0e0;">
                    <input type="radio" name="splitMode" value="clipboard" id="clipboardSplitMode" style="width: 18px; height: 18px;">
                    <div style="flex: 1;">
                        <strong style="font-size: 13px; display: block; margin-bottom: 2px;">ğŸ“‹ ì œëª©ê°ì§€ ìë™ ë¶„í• ëª¨ë“œ (í´ë¦½ë³´ë“œ)</strong>
                        <span style="font-size: 11px; color: #666;">í´ë¦½ë³´ë“œ ë‚´ìš© ë³€ê²½ ì‹œ ìë™ ë¶„í•  (1ì´ˆë§ˆë‹¤ ì²´í¬)</span>
                    </div>
                </label>
            </div>
            <div id="autoSplitStatus" style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-left: 3px solid #2196f3; border-radius: 4px; font-size: 12px; display: none;">
                <strong>ğŸ” í˜„ì¬ ê°ì§€ëœ ì œëª©:</strong> <span id="currentDetectedTitle">-</span>
            </div>
            <div id="clipboardSplitStatus" style="margin-top: 10px; padding: 8px; background: #e8f5e9; border-left: 3px solid #4caf50; border-radius: 4px; font-size: 12px; display: none;">
                <div style="margin-bottom: 5px;"><strong>ğŸ“‹ í´ë¦½ë³´ë“œ ê°ì‹œ ì¤‘...</strong></div>
                <div><strong>í˜„ì¬ ê°ì§€ëœ ê°•ì˜:</strong> <span id="clipboardDetectedTitle">-</span></div>
                <div style="font-size: 10px; color: #666; margin-top: 3px;">ìµœê·¼ ë³€ê²½: <span id="clipboardLastChange">-</span></div>
            </div>
        </div>

        <div class="curriculum-section">
            <div class="curriculum-header">
                <span class="curriculum-title">
                    <span class="curriculum-help">
                        ğŸ“‹ ê°•ì˜ ëª©ì°¨ (ì„ íƒì‚¬í•­)
                        <span class="curriculum-help-icon">?</span>
                        <div class="curriculum-tooltip">
                            <strong>ğŸ“Œ ëª©ì°¨ ì…ë ¥ ë°©ë²•</strong>
                            ê°•ì˜ ì‚¬ì´íŠ¸ì—ì„œ ëª©ì°¨ë¥¼ ë³µì‚¬í•´ì„œ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.
                            <ul>
                                <li><code>55</code> â†’ ê°•ì˜ ë²ˆí˜¸</li>
                                <li><code>Part 4. Advanced</code> â†’ íŒŒíŠ¸ëª…</li>
                                <li><code>Ch01. ì œëª©</code> â†’ ì±•í„°ëª… (ì‹œê°„ ì—†ìŒ)</li>
                                <li><code>CH01-1. ì œëª© 7:58</code> â†’ ì†Œì±•í„° (ì‹œê°„ í•„ìˆ˜)</li>
                            </ul>
                            <strong>ğŸ’¾ ì €ì¥ë˜ëŠ” íŒŒì¼ëª… ì˜ˆì‹œ</strong>
                            <code>55 Part 4 - Ch01 - CH01-1. ì œëª©.webm</code>
                            <br><br>
                            â© ë°°ì† ì„¤ì •í•˜ë©´ ìë™ìœ¼ë¡œ ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚°ë¨
                        </div>
                    </span>
                </span>
                <div class="speed-selector">
                    <label for="playbackSpeed">ì¬ìƒ ë°°ì†:</label>
                    <select id="playbackSpeed">
                        <option value="1">1ë°°ì†</option>
                        <option value="1.25">1.25ë°°ì†</option>
                        <option value="1.5">1.5ë°°ì†</option>
                        <option value="1.75">1.75ë°°ì†</option>
                        <option value="2" selected>2ë°°ì†</option>
                        <option value="2.5">2.5ë°°ì†</option>
                        <option value="3">3ë°°ì†</option>
                    </select>
                </div>
            </div>
            <textarea id="curriculumInput" class="curriculum-textarea" placeholder="ê°•ì˜ ëª©ì°¨ë¥¼ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”. ì˜ˆì‹œ:

001
Part 1. ê¸°ì´ˆí¸
Ch01. ì˜¤ë¦¬ì—”í…Œì´ì…˜
01. ê°•ì˜ ì†Œê°œ 5:00
02. í•™ìŠµ ë°©ë²• ì•ˆë‚´ 7:30"></textarea>
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <button class="btn-parse" id="parseBtn">ëª©ì°¨ ë¶„ì„</button>
                <button class="clear-btn" id="clearBtn">ì´ˆê¸°í™”</button>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;">
                    <input type="checkbox" id="autoStopCheckbox" checked style="width: 16px; height: 16px;">
                    ëª©ì°¨ ëë‚˜ë©´ ìë™ ì¢…ë£Œ
                </label>
            </div>
            <div id="chapterList" class="chapter-list"></div>
            <div id="chapterProgress" class="chapter-progress"></div>
        </div>

        <div class="csv-batch-section" style="background: #fff3e0; border-radius: 12px; padding: 15px; margin-bottom: 20px; border: 2px solid #ff9800;">
            <h3 style="font-size: 14px; font-weight: 600; color: #e65100; margin-bottom: 12px;">ğŸ“Š ì œëª©ê°ì§€ ì¼ê´„ ë¶„í• ëª¨ë“œ (CSV ê¸°ë°˜ í›„ì²˜ë¦¬)</h3>
            <div style="font-size: 12px; color: #666; margin-bottom: 15px; padding: 10px; background: white; border-radius: 6px;">
                ë…¹ìŒ ì™„ë£Œ í›„ CSV íŒŒì¼ì„ ê¸°ì¤€ìœ¼ë¡œ ì „ì²´ ë…¹ìŒ íŒŒì¼ê³¼ ìº¡ì²˜ ì´ë¯¸ì§€ë¥¼ ê°•ì˜ë³„ë¡œ ìë™ ë¶„ë¦¬í•©ë‹ˆë‹¤.
            </div>

            <div style="display: flex; flex-direction: column; gap: 12px;">
                <div>
                    <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 5px; color: #333;">
                        ğŸ“„ CSV íŒŒì¼ ì„ íƒ (í•„ìˆ˜)
                    </label>
                    <input type="file" id="csvFileInput" accept=".csv" style="font-size: 12px; padding: 8px; width: 100%; border: 1px solid #ddd; border-radius: 6px;">
                    <div id="csvStatus" style="margin-top: 5px; font-size: 11px; color: #666;"></div>
                </div>

                <div>
                    <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 5px; color: #333;">
                        ğŸ™ï¸ ì „ì²´ ë…¹ìŒ íŒŒì¼ ì„ íƒ (webm)
                    </label>
                    <input type="file" id="fullWebmInput" accept=".webm" style="font-size: 12px; padding: 8px; width: 100%; border: 1px solid #ddd; border-radius: 6px;">
                    <div id="webmStatus" style="margin-top: 5px; font-size: 11px; color: #666;"></div>
                </div>

                <div>
                    <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 5px; color: #333;">
                        ğŸ–¼ï¸ ìº¡ì²˜ ì´ë¯¸ì§€ í´ë” ì„ íƒ (ì„ íƒì‚¬í•­)
                    </label>
                    <input type="file" id="captureImagesInput" webkitdirectory directory multiple style="font-size: 12px; padding: 8px; width: 100%; border: 1px solid #ddd; border-radius: 6px;">
                    <div id="imagesStatus" style="margin-top: 5px; font-size: 11px; color: #666;"></div>
                </div>

                <button id="processCsvBatchBtn" disabled style="padding: 12px; background: #ff9800; color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: not-allowed; margin-top: 10px;">
                    ğŸ”„ ì¼ê´„ ì²˜ë¦¬ ì‹¤í–‰
                </button>

                <div id="batchProcessStatus" style="display: none; margin-top: 10px; padding: 10px; background: white; border-radius: 6px; font-size: 12px;">
                    <div><strong>ì²˜ë¦¬ ìƒíƒœ:</strong></div>
                    <div id="batchProgressText" style="margin-top: 5px; color: #666;"></div>
                    <div style="margin-top: 8px; background: #eee; border-radius: 4px; height: 20px; overflow: hidden;">
                        <div id="batchProgressBar" style="height: 100%; background: #4caf50; width: 0%; transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="visualizer-container">
            <canvas id="visualizer"></canvas>
        </div>

        <div class="progress-section" id="progressSection" style="display: none;">
            <div class="progress-info">
                <span id="progressElapsed">00:00:00</span>
                <span id="progressRemaining">ë‚¨ì€ ì‹œê°„: --:--:--</span>
            </div>
            <div class="progress-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
        </div>

        <div class="timer" id="timer">00:00:00</div>

        <div class="controls">
            <button class="btn btn-record" id="recordBtn" title="ë…¹ìŒ ì‹œì‘">
                <svg viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="8" />
                </svg>
            </button>
            <button class="btn btn-pause" id="pauseBtn" disabled title="ì¼ì‹œì •ì§€">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="4" width="4" height="16" />
                    <rect x="14" y="4" width="4" height="16" />
                </svg>
            </button>
            <button class="btn btn-stop" id="stopBtn" disabled title="ì •ì§€">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="6" width="12" height="12" />
                </svg>
            </button>
        </div>

        <div class="recordings">
            <h2>
                <span class="recordings-title">ğŸ“ ë…¹ìŒ íŒŒì¼</span>
                <button class="btn-download-all" id="downloadAllBtn" disabled>
                    â¬‡ï¸ ì „ì²´ ë‹¤ìš´ë¡œë“œ
                </button>
            </h2>
            <div id="recordingsList">
                <div class="empty-state">ë…¹ìŒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>
            </div>
        </div>

        <!-- ë¡œê·¸ íŒ¨ë„ -->
        <div class="log-panel">
            <h2>
                <span>ğŸ“‹ ì‹¤ì‹œê°„ ë¡œê·¸</span>
                <div class="log-controls">
                    <button class="btn-export-log" id="exportLogBtn" title="ë¡œê·¸ ë‚´ë³´ë‚´ê¸°">ğŸ“¥ ë‚´ë³´ë‚´ê¸°</button>
                    <button class="btn-clear-log" id="clearLogBtn" title="ë¡œê·¸ ì§€ìš°ê¸°">ğŸ—‘ï¸ ì§€ìš°ê¸°</button>
                </div>
            </h2>
            <div class="log-container" id="logContainer">
                <div class="log-entry log-info">
                    <span class="log-timestamp">[00:00:00]</span>
                    <span class="log-message">ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ</span>
                </div>
            </div>
        </div>

        <!-- ìë™í™” ì„¤ì • ê·¸ë£¹ -->
        <div class="settings-group">
            <h2 class="settings-title">âš™ï¸ ìë™í™” ì„¤ì •</h2>
            <div class="settings-content">
                <div class="toggle-container">
                    <span class="toggle-label">ğŸ¬ ì†Œë¦¬ ê°ì§€ ì‹œ ìë™ ì‹œì‘</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="autoStartOnSound">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label"
                        title="ë¬´ìŒì´ ê°ì§€ë˜ë©´ ìë™ìœ¼ë¡œ ë…¹ìŒì„ ë¶„í• í•©ë‹ˆë‹¤.&#13;&#10;&#13;&#10;[ì¼ë°˜ ëª¨ë“œ]&#13;&#10;â€¢ ì„¤ì •í•œ ë¬´ìŒ ì‹œê°„ ê°ì§€ ì‹œ ì¦‰ì‹œ ìë™ ë¶„í• &#13;&#10;&#13;&#10;[ì±•í„° ëª¨ë“œ]&#13;&#10;â€¢ ì”ì—¬ ì‹œê°„ì— ë”°ë¼ ë¬´ìŒ ì¡°ê±´ ìë™ ì¡°ì • (í•˜ë‹¨ ì„¤ì • ì°¸ê³ )">ğŸ”‡
                        ë¬´ìŒ ê°ì§€ ìë™ë¶„í• </span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="silenceDetection">
                        <span class="toggle-slider"></span>
                    </label>
                    <span id="silenceIndicator" class="silence-indicator"></span>
                    <span id="remainingTimeIndicator" class="silence-indicator" style="margin-left: 10px; color: #2196F3;"></span>
                </div>
                <div class="toggle-container" style="margin-left: 20px; font-size: 12px;">
                    <span style="color: #666;"
                        title="ì±•í„° ëª¨ë“œì—ì„œ ì”ì—¬ ì‹œê°„ì— ë”°ë¼ ìë™ ì¡°ì •ë©ë‹ˆë‹¤.&#13;&#10;â€¢ ì”ì—¬ â‰¤ 5ì´ˆ: ë¬´ìŒ ì¡°ê±´ ì ìš©&#13;&#10;â€¢ ì”ì—¬ > 5ì´ˆ: ë¶„í•  ì•ˆí•¨">ì±•í„°
                        ëª¨ë“œ ì”ì—¬ 5ì´ˆ ì´í•˜:</span>
                    <select id="chapterSilence5"
                        style="margin-left: 5px; padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                        <option value="500">0.5ì´ˆ</option>
                        <option value="1000">1.0ì´ˆ</option>
                        <option value="1500" selected>1.5ì´ˆ</option>
                        <option value="2000">2.0ì´ˆ</option>
                    </select>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label">ğŸ“¸ ì´ë¯¸ì§€ìº¡ì²˜(WebP->PDF)</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="captureEnabled" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <div style="margin-left: 10px; display: flex; gap: 15px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label for="captureInterval" style="font-size: 12px; color: #666;">ê°„ê²©:</label>
                            <select id="captureInterval"
                                style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                                <option value="1">1ì´ˆ</option>
                                <option value="2">2ì´ˆ</option>
                                <option value="5" selected>5ì´ˆ</option>
                                <option value="10">10ì´ˆ</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label for="captureQuality" style="font-size: 12px; color: #666;">í’ˆì§ˆ:</label>
                            <select id="captureQuality"
                                style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                                <option value="0.9">ê³ í™”ì§ˆ</option>
                                <option value="0.7" selected>ì¤‘í™”ì§ˆ</option>
                                <option value="0.5">ì €í™”ì§ˆ</option>
                            </select>
                        </div>
                        <span id="captureStatus" style="font-size: 11px; color: #666;"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let recordings = [];
        let startTime;
        let timerInterval;
        let isPaused = false;
        let isRecording = false; // ì¶”ê°€: ë…¹ìŒ ì§„í–‰ ì—¬ë¶€ í”Œë˜ê·¸
        let isWaitingForFirstSound = false; // ì¶”ê°€: ì²« ì†Œë¦¬ ëŒ€ê¸° ì—¬ë¶€
        let pausedTime = 0;
        let recordingStartTime = null; // í˜„ì¬ ë…¹ìŒ ì„¸ì…˜ì˜ ì‹¤ì œ ì‹œì‘ ì‹œê°„
        let audioContext;
        let analyser;
        let dataArray;
        let animationId;
        let streams = [];
        let currentMimeType = ''; // ì¶”ê°€: ì‹¤ì œ ì‚¬ìš© ì¤‘ì¸ ë…¹ìŒ í˜•ì‹
        let currentRecordingType = ''; // ì¶”ê°€: ë…¹ìŒ ì†ŒìŠ¤ íƒ€ì… (system, mic, both)
        let silenceStart = null;
        let silenceThreshold = 30; // ë³¼ë¥¨ ì„ê³„ê°’ (0-255) - ì´ ê°’ë³´ë‹¤ ë‚®ìœ¼ë©´ ë¬´ìŒìœ¼ë¡œ íŒë‹¨
        let silenceDuration = 5000; // 5ì´ˆ ë¬´ìŒ ì‹œ ë¶„í•  (ê¸°ë³¸ê°’)
        let lastLoggedSecond = -1; // ë§ˆì§€ë§‰ ë¡œê·¸ ì¶œë ¥ëœ ì´ˆ (ì¤‘ë³µ ë°©ì§€)
        let forceSplitExecuted = false; // -5ì´ˆ ê°•ì œ ë¶„í•  ì‹¤í–‰ ì—¬ë¶€ (ì¤‘ë³µ ë°©ì§€)
        let lectureCount = 1;
        
        // ì œëª© ê°ì§€ ìë™ ë¶„í•  ê´€ë ¨ ë³€ìˆ˜
        let titleDetectionEnabled = false;
        let currentDetectedTitle = '';
        let titleCheckInterval = null;

        // í´ë¦½ë³´ë“œ ê¸°ë°˜ ìë™ ë¶„í•  ê´€ë ¨ ë³€ìˆ˜
        let clipboardDetectionEnabled = false;
        let lastClipboardText = '';
        let clipboardCheckInterval = null;
        let clipboardDetectedTitle = '';

        // CSV ê¸°ë°˜ ì¼ê´„ ë¶„í•  ê´€ë ¨ ë³€ìˆ˜
        let csvData = null;
        let fullWebmFile = null;
        let captureImagesFiles = [];

        // ì´ˆ ë‹¨ìœ„ ì‹œê°„ì„ ê¹”ë”í•˜ê²Œ í‘œì‹œ (1ì´ˆ, 1.5ì´ˆ ë“±)
        function formatSeconds(seconds) {
            const fixed = seconds.toFixed(1);
            return fixed.endsWith('.0') ? fixed.slice(0, -2) : fixed;
        }

        const recordBtn = document.getElementById('recordBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timerDisplay = document.getElementById('timer');
        const recordingsList = document.getElementById('recordingsList');
        const statusDisplay = document.getElementById('status');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        const includeSystemAudio = document.getElementById('includeSystemAudio');
        const includeMic = document.getElementById('includeMic');
        const autoStartOnSound = document.getElementById('autoStartOnSound'); // ì¶”ê°€
        const silenceDetection = document.getElementById('silenceDetection');
        const chapterSilence5 = document.getElementById('chapterSilence5'); // ì±•í„° ëª¨ë“œ ì”ì—¬ 5ì´ˆ ì´í•˜
        const silenceIndicator = document.getElementById('silenceIndicator');
        const remainingTimeIndicator = document.getElementById('remainingTimeIndicator');
        // í™”ë©´ì „í™˜ ìë™ê°ì§€ ê´€ë ¨ ìš”ì†Œ ì œê±°ë¨ - nullë¡œ ì„¤ì •
        const sceneChangeDetectionToggle = null;
        const sceneChangeSensitivity = null;
        const sensitivityValue = null;
        const detectBasic = null;
        const detectMode1 = null;
        const detectMode2 = null;
        const detectMode3 = null;
        const mode2ImageUpload = null;
        const mode2ImageInput = null;
        const uploadMode2ImageBtn = null;
        const mode2ImageStatus = null;
        const requireSilenceForSceneChange = null;
        // í…œí”Œë¦¿ ë§¤ì¹­ ê´€ë ¨ ìš”ì†Œ ì œê±°ë¨ - nullë¡œ ì„¤ì •
        const templateMatchingToggle = null;
        const templateImageInput = null;
        const uploadTemplateBtn = null;
        const templateStatus = null;
        const templateSimilarity = null;
        const similarityValue = null;
        const newLectureBtn = document.getElementById('newLectureBtn');
        const curriculumInput = document.getElementById('curriculumInput');
        const parseBtn = document.getElementById('parseBtn');
        const clearBtn = document.getElementById('clearBtn');
        const chapterList = document.getElementById('chapterList');
        const logContainer = document.getElementById('logContainer');
        const clearLogBtn = document.getElementById('clearLogBtn');
        const exportLogBtn = document.getElementById('exportLogBtn');
        const chapterProgress = document.getElementById('chapterProgress');
        const playbackSpeed = document.getElementById('playbackSpeed');
        const autoStopCheckbox = document.getElementById('autoStopCheckbox');
        const captureEnabled = document.getElementById('captureEnabled');
        const captureInterval = document.getElementById('captureInterval');
        const captureQuality = document.getElementById('captureQuality');
        const captureStatus = document.getElementById('captureStatus');
        
        // ì œëª© ê°ì§€ ìë™ ë¶„í•  ê´€ë ¨ ìš”ì†Œ
        const autoSplitMode = document.getElementById('autoSplitMode');
        const autoSplitStatus = document.getElementById('autoSplitStatus');
        const currentDetectedTitleSpan = document.getElementById('currentDetectedTitle');

        // í´ë¦½ë³´ë“œ ê¸°ë°˜ ë¶„í•  ê´€ë ¨ ìš”ì†Œ
        const clipboardSplitMode = document.getElementById('clipboardSplitMode');
        const clipboardSplitStatus = document.getElementById('clipboardSplitStatus');
        const clipboardDetectedTitleSpan = document.getElementById('clipboardDetectedTitle');
        const clipboardLastChange = document.getElementById('clipboardLastChange');

        // CSV ì¼ê´„ ë¶„í•  ê´€ë ¨ ìš”ì†Œ
        const csvFileInput = document.getElementById('csvFileInput');
        const fullWebmInput = document.getElementById('fullWebmInput');
        const captureImagesInput = document.getElementById('captureImagesInput');
        const processCsvBatchBtn = document.getElementById('processCsvBatchBtn');
        const csvStatus = document.getElementById('csvStatus');
        const webmStatus = document.getElementById('webmStatus');
        const imagesStatus = document.getElementById('imagesStatus');
        const batchProcessStatus = document.getElementById('batchProcessStatus');
        const batchProgressText = document.getElementById('batchProgressText');
        const batchProgressBar = document.getElementById('batchProgressBar');

        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const progressBar = document.getElementById('progressBar');
        const progressElapsed = document.getElementById('progressElapsed');
        const progressRemaining = document.getElementById('progressRemaining');
        const progressSection = document.getElementById('progressSection');

        let chapters = [];
        let currentChapterIndex = 0;
        let chapterStartTime = 0;
        let chapterTimers = [];

        // ìº¡ì²˜ ê´€ë ¨ ë³€ìˆ˜
        let captureTimer = null;
        let capturedImages = [];
        let captureCount = 0;
        let videoStream = null;
        let videoElement = null;

        // ë¶„í•  ëŒ€ê¸° ìƒíƒœ ë³€ìˆ˜ë“¤
        let chapterReadyToSplit = false;
        let waitingForSilence = false;
        let pendingSplitChapterIndex = -1;
        let readyToAutoStop = false;
        let silenceStartForSplit = null;
        let silenceWaitStartTime = null; // âœ… ì±•í„° ì¢…ë£Œ ëŒ€ê¸° ì‹œì‘ ì‹œê°„
        const silenceDurationForSplit = 2000; // âœ… 2ì´ˆ ë¬´ìŒ (ê¸°ì¡´ 3000ms â†’ 2000ms)

        // âœ… í˜„ì¬ ë…¹ìŒ ì¤‘ì¸ ì±•í„° ì´ë¦„
        let activeChapterName = '';

        // í™”ë©´ ë³€í™” ê°ì§€ ë³€ìˆ˜ë“¤
        let sceneChangeDetector = null;
        let lastFrameData = null;
        let sceneChangeCheckInterval = null;
        let detectedSceneChange = false;
        let sceneChangeTime = null;
        let frameBeforeSilence = null; // âœ… ë¬´ìŒ ì‹œì‘ ì§ì „ í™”ë©´ ì €ì¥

        // í…œí”Œë¦¿ ë§¤ì¹­ ë³€ìˆ˜ë“¤
        let templateImage = null; // í…œí”Œë¦¿ ì´ë¯¸ì§€ ë°ì´í„°
        let templateMatcher = null;
        let templateCheckInterval = null;

        // ë™ì˜ìƒ ì œëª© ê°ì§€ ë³€ìˆ˜ë“¤
        let videoTitleDetector = null;

        function updateStatus(state, message) {
            statusDisplay.className = 'status ' + state;
            statusDisplay.textContent = message;
        }

        // ============ ë¡œê·¸ ì‹œìŠ¤í…œ ============
        let logEntries = [];

        function addLog(message, type = 'info') {
            const now = new Date();
            const timestamp = now.toLocaleTimeString('ko-KR', { hour12: false });
            const logEntry = {
                timestamp,
                message,
                type,
                fullTime: now
            };

            logEntries.push(logEntry);

            // ë¡œê·¸ ì—”íŠ¸ë¦¬ ìƒì„±
            const logDiv = document.createElement('div');
            logDiv.className = `log-entry log-${type}`;
            logDiv.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span>
                <span class="log-message">${message}</span>
            `;

            logContainer.appendChild(logDiv);

            // ìë™ ìŠ¤í¬ë¡¤ (ìµœì‹  ë¡œê·¸ê°€ ë³´ì´ë„ë¡)
            logContainer.scrollTop = logContainer.scrollHeight;

            // ì½˜ì†”ì—ë„ ì¶œë ¥
            console.log(`[${type.toUpperCase()}] ${timestamp} - ${message}`);
        }

        function clearLog() {
            logEntries = [];
            logContainer.innerHTML = '<div class="log-entry log-info"><span class="log-timestamp">[' +
                new Date().toLocaleTimeString('ko-KR', { hour12: false }) +
                ']</span><span class="log-message">ë¡œê·¸ê°€ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤</span></div>';
        }

        function exportLog() {
            if (logEntries.length === 0) {
                alert('ë‚´ë³´ë‚¼ ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const logText = logEntries.map(entry =>
                `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
            ).join('\n');

            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `recording-log-${new Date().toISOString().replace(/:/g, '-').slice(0, 19)}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            addLog('ë¡œê·¸ë¥¼ íŒŒì¼ë¡œ ë‚´ë³´ëƒˆìŠµë‹ˆë‹¤', 'success');
        }

        // ë¡œê·¸ ë²„íŠ¼ ì´ë²¤íŠ¸
        clearLogBtn.addEventListener('click', clearLog);
        exportLogBtn.addEventListener('click', exportLog);

        // ============ ë¡œê·¸ ì‹œìŠ¤í…œ ë ============

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            if (isWaitingForFirstSound) {
                timerDisplay.textContent = 'ëŒ€ê¸° ì¤‘...';
                if (progressBar) {
                    progressBar.className = 'progress-bar waiting';
                    progressBar.style.width = '100%';
                }
                if (progressElapsed) progressElapsed.textContent = 'ì†Œë¦¬ ëŒ€ê¸° ì¤‘';
                if (progressRemaining) progressRemaining.textContent = '';
                return;
            }

            if (isRecording && !isPaused) {
                const elapsedMs = Date.now() - startTime + pausedTime;
                const timeStr = formatTime(elapsedMs);
                timerDisplay.textContent = timeStr;
                if (progressElapsed) progressElapsed.textContent = timeStr;

                // í”„ë¡œê·¸ë ˆìŠ¤ ë°” ë° ì”ì—¬ ì‹œê°„ ì—…ë°ì´íŠ¸
                if (chapters.length > 0 && chapters[currentChapterIndex]) {
                    const currentChapter = chapters[currentChapterIndex];
                    const chapterDuration = currentChapter.duration; // seconds
                    const durationMs = chapterDuration * 1000;

                    if (chapterDuration && chapterDuration > 0) {
                        const percent = Math.min((elapsedMs / durationMs) * 100, 100);
                        // ì±•í„° ì „í™˜ ì‹œê°„ 1ì´ˆ ê³ ë ¤ (ë§ˆì§€ë§‰ ì±•í„° ì œì™¸)
                        const isLastChapter = currentChapterIndex >= chapters.length - 1;
                        const transitionTime = isLastChapter ? 0 : 1;
                        const remainingTimeSec = Math.max(-8, chapterDuration - (elapsedMs / 1000) + transitionTime);

                        if (progressBar) {
                            progressBar.className = 'progress-bar';
                            progressBar.style.width = `${percent}%`;
                        }
                        if (progressRemaining) progressRemaining.textContent = `ë‚¨ì€ ì‹œê°„: ${formatTime(remainingTimeSec * 1000)}`;

                        // ì”ì—¬ì‹œê°„ í‘œì‹œ (ë¬´ìŒ ê°ì§€ ìë™ë¶„í•  ì˜†)
                        if (remainingTimeIndicator) {
                            remainingTimeIndicator.textContent = `(ì”ì—¬: ${formatSeconds(remainingTimeSec)}ì´ˆ)`;
                        }
                    } else {
                        if (progressBar) {
                            progressBar.className = 'progress-bar';
                            progressBar.style.width = '100%';
                        }
                        if (progressRemaining) progressRemaining.textContent = 'ì—°ì† ë…¹ìŒ ì¤‘';
                        if (remainingTimeIndicator) remainingTimeIndicator.textContent = '';
                    }
                } else {
                    if (progressBar) {
                        progressBar.className = 'progress-bar';
                        progressBar.style.width = '100%';
                    }
                    if (progressRemaining) progressRemaining.textContent = 'ì—°ì† ë…¹ìŒ ì¤‘';
                    if (remainingTimeIndicator) remainingTimeIndicator.textContent = '';
                }

                // ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ ì•ˆì •ì ì¸ ë¬´ìŒ ê°ì§€ ë° ìë™ë¶„í•  ì²´í¬
                // (requestAnimationFrame ëŒ€ì‹  setInterval ë£¨í”„ì¸ ì—¬ê¸°ì„œ ì²˜ë¦¬)
                if (silenceDetection.checked && mediaRecorder && mediaRecorder.state === 'recording') {
                    // AudioContext ìƒíƒœ í™•ì¸: suspended ìƒíƒœë¼ë©´ ë°ì´í„°ë¥¼ ì‹ ë¢°í•  ìˆ˜ ì—†ìŒ
                    if (audioContext && audioContext.state === 'suspended') {
                        // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¸Œë¼ìš°ì €ê°€ ì˜¤ë””ì˜¤ë¥¼ ì¤‘ë‹¨ì‹œí‚¨ ê²½ìš°, ì˜¤íƒ ë°©ì§€ë¥¼ ìœ„í•´ ë¬´ìŒ íƒ€ì´ë¨¸ ì‘ë™ ì•ˆ í•¨
                        return;
                    }

                    if (analyser && dataArray) {
                        analyser.getByteFrequencyData(dataArray);
                        const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                        processSilenceDetection(average);
                    }
                }
            }
        }

        function processSilenceDetection(average) {
            if (average < silenceThreshold) {
                if (!silenceStart) {
                    silenceStart = Date.now();
                    lastLoggedSecond = -1;
                    console.log(`ğŸ”‡ [ë¬´ìŒ ê°ì§€] ë¬´ìŒ ì‹œì‘ (í‰ê·  ë ˆë²¨: ${average.toFixed(1)}, ì„ê³„ê°’: ${silenceThreshold})`);
                } else {
                    const silentTime = Date.now() - silenceStart;
                    const silentTimeSec = silentTime / 1000;

                    silenceIndicator.textContent = `(ë¬´ìŒ ${formatSeconds(silentTimeSec)}ì´ˆ)`;
                    silenceIndicator.className = 'silence-indicator active';

                    // 1.5ì´ˆ ì´ìƒì¼ ë•Œ, ì •ìˆ˜ ì´ˆê°€ ë°”ë€” ë•Œë§Œ ë¡œê·¸ (ì½˜ì†” + UI)
                    if (silentTime >= 1500) {
                        const currentSecond = Math.floor(silentTimeSec);
                        if (currentSecond !== lastLoggedSecond) {
                            lastLoggedSecond = currentSecond;
                            const targetSec = silenceDuration / 1000;

                            let remainingInfo = '';
                            let remainingTime = null;
                            if (chapters.length > 0 && currentChapterIndex < chapters.length) {
                                const currentChapter = chapters[currentChapterIndex];
                                const expectedDuration = currentChapter.duration;
                                const elapsedTime = (Date.now() - startTime) / 1000;
                                const rawRemaining = expectedDuration - elapsedTime;
                                // ì±•í„° ì „í™˜ ì‹œê°„ 1ì´ˆ ê³ ë ¤ (ë§ˆì§€ë§‰ ì±•í„° ì œì™¸)
                                const isLastChapter = currentChapterIndex >= chapters.length - 1;
                                const transitionTime = isLastChapter ? 0 : 1;
                                remainingTime = Math.max(-8, rawRemaining + transitionTime);


                                remainingInfo = `, ì”ì—¬: ${formatSeconds(remainingTime)}ì´ˆ`;
                            }

                            console.log(`ğŸ”‡ [ë¬´ìŒ ê°ì§€] ë¬´ìŒ ${formatSeconds(silentTimeSec)}ì´ˆ / ${formatSeconds(targetSec)}ì´ˆ (í‰ê·  ë ˆë²¨: ${average.toFixed(1)}, ì„ê³„ê°’: ${silenceThreshold}${remainingInfo})`);
                            addLog(`ğŸ”‡ [ë¬´ìŒ ê°ì§€] ${formatSeconds(silentTimeSec)}ì´ˆ / ${formatSeconds(targetSec)}ì´ˆ${remainingInfo}`, 'info');
                        }
                    }

                    // ìë™ë¶„í•  ì¡°ê±´ ì²´í¬
                    let reqSilence = silenceDuration;
                    let remainingTime = null;
                    if (chapters.length > 0 && currentChapterIndex < chapters.length) {
                        const currentChapter = chapters[currentChapterIndex];
                        const elapsedTime = (Date.now() - startTime) / 1000;
                        // ì±•í„° ì „í™˜ ì‹œê°„ 1ì´ˆ ê³ ë ¤ (ë§ˆì§€ë§‰ ì±•í„° ì œì™¸)
                        const isLastChapter = currentChapterIndex >= chapters.length - 1;
                        const transitionTime = isLastChapter ? 0 : 1;
                        remainingTime = Math.max(-8, currentChapter.duration - elapsedTime + transitionTime);

                        if (remainingTime <= 5) reqSilence = parseInt(chapterSilence5.value);
                        else reqSilence = Infinity;
                    }

                    // ê°•ì œ ë¶„í•  (-8ì´ˆ ë„ë‹¬)
                    if (remainingTime !== null && remainingTime <= -8 && !forceSplitExecuted) {
                        forceSplitExecuted = true;

                        // ğŸ”š ë§ˆì§€ë§‰ ì±•í„°ì¸ ê²½ìš° ë…¹ìŒ ì¢…ë£Œ
                        if (currentChapterIndex >= chapters.length - 1) {
                            console.log(`âš ï¸ [ê°•ì œ ìë™ë¶„í• ] ë§ˆì§€ë§‰ ì±•í„° ì”ì—¬ì‹œê°„ -8ì´ˆ ë„ë‹¬ â†’ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ`);
                            addLog(`âš ï¸ [ê°•ì œ ìë™ë¶„í• ] ë§ˆì§€ë§‰ ì±•í„° ì™„ë£Œ â†’ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ`, 'success');
                            silenceStart = null;
                            lastLoggedSecond = -1;
                            silenceIndicator.textContent = '(ì „ì²´ ë…¹ìŒ ì¢…ë£Œ!)';
                            updateStatus('ready', 'âœ… ëª¨ë“  ì±•í„° ë…¹ìŒ ì™„ë£Œ!');
                            stopRecording();
                            return;
                        }

                        console.log(`âš ï¸ [ê°•ì œ ìë™ë¶„í• ] ì”ì—¬ì‹œê°„ -8ì´ˆ ë„ë‹¬ â†’ ê°•ì œ ë¶„í• `);
                        addLog(`âš ï¸ [ê°•ì œ ìë™ë¶„í• ] ì”ì—¬ì‹œê°„ -8ì´ˆ ë„ë‹¬`, 'warning');
                        splitRecording();
                        silenceStart = null;
                        lastLoggedSecond = -1;
                        silenceIndicator.textContent = '(ê°•ì œ ë¶„í• ë¨!)';
                        return;
                    }

                    // ì •ìƒ ë¬´ìŒ ë¶„í• 
                    if (silentTime >= reqSilence) {
                        let canSplit = true;
                        if (remainingTime !== null && remainingTime > 5) {
                            canSplit = false;
                        }

                        if (canSplit) {
                            // ğŸ”š ë§ˆì§€ë§‰ ì±•í„°ì¸ ê²½ìš° ë…¹ìŒ ì¢…ë£Œ
                            if (chapters.length > 0 && currentChapterIndex >= chapters.length - 1) {
                                console.log(`âœ… [ìë™ë¶„í•  ì‹¤ì‹œ] ë§ˆì§€ë§‰ ì±•í„° ë¬´ìŒ ${formatSeconds(silentTimeSec)}ì´ˆ ê°ì§€ â†’ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ`);
                                addLog(`âœ… [ìë™ë¶„í•  ì‹¤ì‹œ] ë§ˆì§€ë§‰ ì±•í„° ì™„ë£Œ (ë¬´ìŒ ${formatSeconds(silentTimeSec)}ì´ˆ) â†’ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ`, 'success');
                                silenceStart = null;
                                lastLoggedSecond = -1;
                                silenceIndicator.textContent = '(ì „ì²´ ë…¹ìŒ ì¢…ë£Œ!)';
                                updateStatus('ready', 'âœ… ëª¨ë“  ì±•í„° ë…¹ìŒ ì™„ë£Œ!');
                                stopRecording();
                                return;
                            }

                            addLog(`âœ… [ìë™ë¶„í•  ì‹¤ì‹œ] ë¬´ìŒ ${formatSeconds(silentTimeSec)}ì´ˆ${remainingTime !== null ? ` (ì”ì—¬: ${formatSeconds(remainingTime)}ì´ˆ)` : ''}`, 'success');
                            splitRecording();
                            silenceStart = null;
                            lastLoggedSecond = -1;
                            silenceIndicator.textContent = '(ìë™ ë¶„í• ë¨!)';
                        } else {
                            silenceStart = null;
                            lastLoggedSecond = -1;
                        }
                    }
                }
            } else {
                // ì†Œë¦¬ ê°ì§€ë¨
                if (silenceStart) {
                    const interruptedTime = ((Date.now() - silenceStart) / 1000).toFixed(1);
                    let remainingInfo = '';
                    if (chapters.length > 0 && currentChapterIndex < chapters.length) {
                        const currentChapter = chapters[currentChapterIndex];
                        const elapsedTime = (Date.now() - startTime) / 1000;
                        // ì±•í„° ì „í™˜ ì‹œê°„ 1ì´ˆ ê³ ë ¤ (ë§ˆì§€ë§‰ ì±•í„° ì œì™¸)
                        const isLastChapter = currentChapterIndex >= chapters.length - 1;
                        const transitionTime = isLastChapter ? 0 : 1;
                        const remainingTime = Math.max(-8, currentChapter.duration - elapsedTime + transitionTime);
                        remainingInfo = `, ì”ì—¬: ${formatSeconds(remainingTime)}ì´ˆ`;
                    }
                    console.log(`âŒ [ë¬´ìŒ ê°ì§€] ë¬´ìŒ ì¤‘ë‹¨ (${average.toFixed(1)} / ${silenceThreshold}, ${interruptedTime}ì´ˆ${remainingInfo})`);

                    if (parseFloat(interruptedTime) >= 1.5) {
                        addLog(`âŒ ë¬´ìŒ ì¤‘ë‹¨ (${interruptedTime}ì´ˆ${remainingInfo})`, 'warning');
                    }
                }
                silenceStart = null;
                lastLoggedSecond = -1;
                silenceIndicator.textContent = '';
                silenceIndicator.className = 'silence-indicator';
            }
        }

        function setupVisualizer() {
            if (audioContext) {
                audioContext.close().catch(() => { });
            }

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.8;

            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            streams.forEach(s => {
                if (s.getAudioTracks().length > 0) {
                    try {
                        const source = audioContext.createMediaStreamSource(s);
                        source.connect(analyser);
                    } catch (e) {
                        console.log('Stream already connected or invalid');
                    }
                }
            });

            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            drawVisualizer();
        }

        function drawVisualizer() {
            animationId = requestAnimationFrame(drawVisualizer);

            canvas.width = canvas.offsetWidth * 2;
            canvas.height = canvas.offsetHeight * 2;
            canvasCtx.scale(2, 2);

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            canvasCtx.fillStyle = '#1a1a2e';
            canvasCtx.fillRect(0, 0, width, height);

            if (!analyser || !dataArray) {
                canvasCtx.strokeStyle = '#667eea';
                canvasCtx.lineWidth = 2;
                canvasCtx.beginPath();
                canvasCtx.moveTo(0, height / 2);
                canvasCtx.lineTo(width, height / 2);
                canvasCtx.stroke();
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

            // âœ… ìµœì´ˆ ì†Œë¦¬ ê°ì§€ ëŒ€ê¸° ë¡œì§
            if (isWaitingForFirstSound) {
                if (average > silenceThreshold) {
                    actuallyStartRecording();
                } else {
                    // ëŒ€ê¸° ìƒíƒœ ì‹œê°ì  í”¼ë“œë°± (í•„ìš” ì‹œ)
                }
            }

            // drawVisualizerëŠ” ì‹œê°í™”ë§Œ ë‹´ë‹¹ (ë¬´ìŒ ê°ì§€ ë¡œì§ì€ updateTimerë¡œ ì´ë™ë¨)

            // 20ì´ˆ í˜ì¼ì„¸ì´í”„ ì œê±° - í™”ë©´ ì „í™˜ ìë™ê°ì§€ë§Œ ì‚¬ìš©

            const barCount = 64;
            const barWidth = width / barCount;
            const gap = 2;

            for (let i = 0; i < barCount; i++) {
                const dataIndex = Math.floor(i * dataArray.length / barCount);
                const barHeight = (dataArray[dataIndex] / 255) * height * 0.9;

                const x = i * barWidth;
                const y = height - barHeight;

                const gradient = canvasCtx.createLinearGradient(0, y, 0, height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(0.5, '#764ba2');
                gradient.addColorStop(1, '#f093fb');

                canvasCtx.fillStyle = gradient;
                canvasCtx.fillRect(x + gap / 2, y, barWidth - gap, barHeight);
            }
        }

        function mergeAudioStreams(streams) {
            const ctx = new AudioContext();
            const dest = ctx.createMediaStreamDestination();

            streams.forEach(stream => {
                if (stream.getAudioTracks().length > 0) {
                    const source = ctx.createMediaStreamSource(stream);
                    source.connect(dest);
                }
            });

            return dest.stream;
        }

        async function startRecording() {
            const wantSystem = includeSystemAudio.checked;
            const wantMic = includeMic.checked;

            if (!wantSystem && !wantMic) {
                updateStatus('error', 'âŒ ìµœì†Œ í•˜ë‚˜ì˜ ì˜¤ë””ì˜¤ ì†ŒìŠ¤ë¥¼ ì„ íƒí•˜ì„¸ìš”');
                return;
            }

            try {
                streams = [];
                let recordingType = '';

                // ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ íšë“
                if (wantSystem) {
                    updateStatus('ready', 'ğŸ”„ í™”ë©´ ê³µìœ  ì°½ì—ì„œ ì˜¤ë””ì˜¤ë¥¼ ì„ íƒí•˜ì„¸ìš”...');
                    const displayStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: true
                    });

                    // ë¹„ë””ì˜¤ íŠ¸ë™ì´ ìˆìœ¼ë©´ ìº¡ì²˜ìš©ìœ¼ë¡œ ì €ì¥
                    const videoTrack = displayStream.getVideoTracks()[0];
                    if (videoTrack && captureEnabled.checked) {
                        videoStream = new MediaStream([videoTrack]);
                        videoElement = document.createElement('video');
                        videoElement.srcObject = videoStream;
                        videoElement.muted = true;
                        videoElement.play();
                    } else if (videoTrack) {
                        videoTrack.stop();
                    }

                    // ì˜¤ë””ì˜¤ íŠ¸ë™ë§Œ ì¶”ì¶œ
                    const audioTrack = displayStream.getAudioTracks()[0];
                    if (audioTrack) {
                        const audioOnlyStream = new MediaStream([audioTrack]);
                        streams.push(audioOnlyStream);
                        recordingType = 'system';
                    }
                }

                // ë§ˆì´í¬ íšë“
                if (wantMic) {
                    const micStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    streams.push(micStream);
                    recordingType = recordingType === 'system' ? 'both' : 'mic';
                }

                if (streams.length === 0) {
                    throw new Error('ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í™”ë©´ ê³µìœ  ì‹œ [ì˜¤ë””ì˜¤ ê³µìœ ] ì²´í¬ë°•ìŠ¤ë¥¼ ì„ íƒí–ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }

                // ìŠ¤íŠ¸ë¦¼ ë³‘í•©
                let finalStream;
                if (streams.length > 1) {
                    finalStream = mergeAudioStreams(streams);
                } else {
                    finalStream = streams[0];
                }

                setupVisualizer();

                // ë¸Œë¼ìš°ì €ê°€ ì§€ì›í•˜ëŠ” ìµœì ì˜ íƒ€ì… ì„ íƒ
                const types = [
                    'audio/webm;codecs=opus',
                    'audio/ogg;codecs=opus',
                    'audio/webm',
                    'audio/ogg'
                ];
                let mimeType = '';
                for (const t of types) {
                    if (MediaRecorder.isTypeSupported(t)) {
                        mimeType = t;
                        break;
                    }
                }

                if (!mimeType) {
                    throw new Error('ë¸Œë¼ìš°ì €ê°€ ì§€ì›í•˜ëŠ” ë…¹ìŒ í˜•ì‹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }

                currentMimeType = mimeType;
                mediaRecorder = new MediaRecorder(finalStream, { mimeType });
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                // ì²« ë…¹ìŒ onstop ì€ activeChapterName ê¸°ì¤€
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                    const baseName =
                        activeChapterName ||
                        (chapters[currentChapterIndex]?.name) ||
                        `ê°•ì˜${lectureCount}`;
                    saveRecordingWithName(audioBlob, currentRecordingType, baseName);
                    cleanup();
                };

                currentRecordingType = recordingType; // ë³€ìˆ˜ ëŒ€ì…
                lectureCount = 1;

                if (autoStartOnSound.checked) {
                    isWaitingForFirstSound = true;
                    updateStatus('recording', 'ğŸµ ì†Œë¦¬ ëŒ€ê¸° ì¤‘... ì†Œë¦¬ê°€ ê°ì§€ë˜ë©´ ë…¹ìŒì´ ì‹œì‘ë©ë‹ˆë‹¤.');
                    progressSection.style.display = 'block'; // ëŒ€ê¸° ì¤‘ì—ë„ ì§„í–‰ ë°” ì„¹ì…˜ í‘œì‹œ
                    updateTimer(); // ëŒ€ê¸° ìƒíƒœ ì¦‰ì‹œ ë°˜ì˜
                    recordBtn.classList.add('recording');
                    recordBtn.disabled = true;
                    stopBtn.disabled = false;
                    pauseBtn.disabled = true;
                    includeSystemAudio.disabled = true;
                    includeMic.disabled = true;
                } else {
                    // âœ… 1ì´ˆ í›„ ìë™ ë…¹ìŒ ì‹œì‘
                    updateStatus('ready', 'â³ 1ì´ˆ í›„ ë…¹ìŒ ì‹œì‘...');
                    recordBtn.disabled = true;
                    setTimeout(() => {
                        actuallyStartRecording();
                    }, 1000);
                }

            } catch (err) {
                console.error('ë…¹ìŒ ì‹œì‘ ì˜¤ë¥˜:', err);
                cleanup();

                if (err.name === 'NotAllowedError') {
                    updateStatus('error', 'âŒ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ê³µìœ  ì°½ì—ì„œ [ê³µìœ ]ë¥¼ ëˆ„ë¥´ê³  [ì˜¤ë””ì˜¤ ê³µìœ ]ë¥¼ ì²´í¬í–ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
                } else if (err.name === 'NotSupportedError') {
                    let reason = 'ì´ ë¸Œë¼ìš°ì €ëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
                    if (!window.isSecureContext) {
                        reason = 'ë³´ì•ˆ ì—°ê²°(HTTPS) í™˜ê²½ì´ ì•„ë‹™ë‹ˆë‹¤. HTTPS ì£¼ì†Œë¡œ ì ‘ì†í•´ì•¼ í•©ë‹ˆë‹¤.';
                    }
                    updateStatus('error', `âŒ ${reason} (Chrome/Edge ê¶Œì¥)`);
                } else {
                    // ì‹¤ì œ ë°œìƒí•œ ì—ëŸ¬ì˜ ì´ë¦„ê³¼ ë©”ì‹œì§€ë¥¼ ìƒì„¸íˆ ì „ë‹¬
                    const debugInfo = `(ì—ëŸ¬ëª…: ${err.name}, ë©”ì‹œì§€: ${err.message})`;
                    updateStatus('error', `âŒ ë…¹ìŒ ì‹œì‘ ì‹¤íŒ¨: ${debugInfo}`);
                }
            }
        }


        function actuallyStartRecording() {
            if (!mediaRecorder) return;

            isWaitingForFirstSound = false;
            mediaRecorder.start(1000);
            startTime = Date.now(); // ìƒˆ ì±•í„° ì‹œì‘ ì‹œê°„ ë¦¬ì…‹
            recordingStartTime = Date.now(); // ì‹¤ì œ ë…¹ìŒ ì‹œì‘ ì‹œê°„ ê¸°ë¡
            pausedTime = 0;
            isPaused = false;
            isRecording = true; // ë…¹ìŒ ìƒíƒœ ì‹œì‘
            timerInterval = setInterval(updateTimer, 100);
            progressSection.style.display = 'block'; // ì§„í–‰ ë°” í‘œì‹œ

            // ìº¡ì²˜ ì‹œì‘
            if (captureEnabled.checked && videoElement) {
                startCapture();
            }

            recordBtn.classList.add('recording');
            recordBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            newLectureBtn.disabled = false;

            if (chapters.length > 0) {
                // í˜„ì¬ ì±•í„°ì˜ ì´ë¦„ ì„¤ì •
                const currentChapter = chapters[currentChapterIndex];
                activeChapterName = currentChapter.name;
                updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (${currentChapter.shortName || currentChapter.name})`);

                // ë¡œê·¸ ì¶”ê°€ (ì˜ˆìƒ ì‹œê°„ í¬í•¨)
                const expectedMin = Math.floor(currentChapter.duration / 60);
                const expectedSec = Math.floor(currentChapter.duration % 60);
                const expectedTimeStr = `${expectedMin}ë¶„ ${expectedSec}ì´ˆ`;
                addLog(`ğŸ¬ ë…¹ìŒ ì‹œì‘: "${currentChapter.name}" (ì±•í„° ${currentChapterIndex + 1}/${chapters.length}, ì˜ˆìƒ: ${expectedTimeStr})`, 'success');

                // âš ï¸ ë¶„í•  ëª¨ë“œ í™•ì¸ ë° ê°ì§€ ì‹œì‘ (startChapterTimers í˜¸ì¶œ ì „ì— ë¨¼ì € ì„¤ì •)
                const splitModeRadios = document.getElementsByName('splitMode');
                for (const radio of splitModeRadios) {
                    if (radio.checked) {
                        if (radio.value === 'title') {
                            titleDetectionEnabled = true;
                            clipboardDetectionEnabled = false;
                            startTitleDetection();
                            if (autoSplitStatus) {
                                autoSplitStatus.style.display = 'block';
                            }
                        } else if (radio.value === 'clipboard') {
                            clipboardDetectionEnabled = true;
                            titleDetectionEnabled = false;
                            startClipboardDetection();
                            if (clipboardSplitStatus) {
                                clipboardSplitStatus.style.display = 'block';
                            }
                        } else {
                            titleDetectionEnabled = false;
                            clipboardDetectionEnabled = false;
                        }
                        break;
                    }
                }

                // í™œì„±í™”ëœ ì„¤ì • ë¡œê·¸ í‘œì‹œ
                const activeSettings = [];
                if (autoStartOnSound && autoStartOnSound.checked) activeSettings.push('ì†Œë¦¬ ê°ì§€ ìë™ ì‹œì‘');
                if (silenceDetection && silenceDetection.checked) {
                    const silence5 = chapterSilence5 ? (parseInt(chapterSilence5.value) / 1000).toFixed(1) : '?';
                    activeSettings.push(`ë¬´ìŒ ê°ì§€ ìë™ë¶„í•  (ì±•í„° ëª¨ë“œ ì”ì—¬ 5ì´ˆ ì´í•˜:${silence5}ì´ˆ)`);
                }
                // ì œëª© ê°ì§€ ìë™ ë¶„í•  ëª¨ë“œ í‘œì‹œ
                if (titleDetectionEnabled) {
                    activeSettings.push('ì œëª© ê°ì§€ ìë™ ë¶„í• ');
                }
                if (activeSettings.length > 0) {
                    addLog(`âš™ï¸ í™œì„±í™”ëœ ì„¤ì •: ${activeSettings.join(' | ')}`, 'info');
                }

                // ì±•í„° íƒ€ì´ë¨¸ëŠ” ì²« ë…¹ìŒ ì‹œì‘ ì‹œì—ë§Œ ì‹œì‘ (ë¶„í•  ì‹œì—ëŠ” ì´ë¯¸ ì‹œì‘ë¨)
                console.log(`ğŸ” [DEBUG] ì¡°ê±´ í™•ì¸ - currentChapterIndex: ${currentChapterIndex}, chapterTimers.length: ${chapterTimers.length}, titleDetectionEnabled: ${titleDetectionEnabled}`);
                if (currentChapterIndex === 0 || chapterTimers.length === 0) {
                    console.log(`ğŸ” [DEBUG] startChapterTimers() í˜¸ì¶œ - currentChapterIndex: ${currentChapterIndex}`);
                    startChapterTimers(currentChapterIndex);
                } else {
                    console.log(`âš ï¸ [DEBUG] startChapterTimers() í˜¸ì¶œ ìƒëµ - ì´ë¯¸ íƒ€ì´ë¨¸ê°€ ì„¤ì •ë¨`);
                }
            } else {
                // ì¼ë°˜ ëª¨ë“œ (ì±•í„° ì—†ìŒ)
                const sourceText = currentRecordingType === 'both' ? 'ì‹œìŠ¤í…œ + ë§ˆì´í¬' :
                    currentRecordingType === 'system' ? 'ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤' : 'ë§ˆì´í¬';
                const lectureTitle = getCurrentLectureTitle() || `ê°•ì˜ ${lectureCount}`;
                updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (${lectureTitle}, ${sourceText})`);
                addLog(`ğŸ¬ ë…¹ìŒ ì‹œì‘: ${lectureTitle} (ì†ŒìŠ¤: ${sourceText})`, 'success');
            }
        }

        // ============ ì œëª© ê°ì§€ ìë™ ë¶„í•  ============
        
        /**
         * ê°•ì˜ ì œëª© ê°ì§€ í•¨ìˆ˜
         */
        function getCurrentLectureTitle() {
            try {
                // í˜„ì¬ ì¬ìƒ ì¤‘ì¸ ê°•ì˜ì— --active í´ë˜ìŠ¤ ì¶”ê°€ë¨
                let titleElement = document.querySelector('.classroom-sidebar-clip__chapter__clip__title--active');
                
                // 2ìˆœìœ„: ëª¨ë“  ì œëª© ì¤‘ì—ì„œ ë¶€ëª¨ê°€ activeì¸ ê²ƒ ì°¾ê¸°
                if (!titleElement) {
                    const allTitles = document.querySelectorAll('.classroom-sidebar-clip__chapter__clip__title');
                    
                    for (const titleEl of allTitles) {
                        let parent = titleEl.parentElement;
                        let depth = 0;
                        
                        while (parent && depth < 5) {
                            const classList = parent.classList.toString();
                            const style = window.getComputedStyle(parent);
                            const bgColor = style.backgroundColor;
                            
                            // íŒŒë€ìƒ‰ ë°°ê²½ì´ê±°ë‚˜ active í´ë˜ìŠ¤ê°€ ìˆìœ¼ë©´ í˜„ì¬ ì¬ìƒ ì¤‘
                            if (classList.includes('active') || 
                                classList.includes('playing') ||
                                classList.includes('current') ||
                                bgColor.includes('59, 130, 246') || // blue-500
                                bgColor.includes('37, 99, 235')) {  // blue-600
                                titleElement = titleEl;
                                break;
                            }
                            
                            parent = parent.parentElement;
                            depth++;
                        }
                        
                        if (titleElement) break;
                    }
                }
                
                if (titleElement) {
                    return titleElement.textContent.trim();
                }
            } catch (error) {
                console.error('ì œëª© ê°ì§€ ì˜¤ë¥˜:', error);
            }
            
            return null;
        }

        /**
         * ì œëª© ê°ì§€ ì‹œì‘
         */
        function startTitleDetection() {
            if (titleCheckInterval) {
                clearInterval(titleCheckInterval);
            }

            currentDetectedTitle = getCurrentLectureTitle() || '';
            if (currentDetectedTitleSpan) {
                currentDetectedTitleSpan.textContent = currentDetectedTitle || 'ì œëª©ì„ ê°ì§€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
            }

            console.log(`ğŸ¯ ì œëª© ê°ì§€ ì‹œì‘ - í˜„ì¬: "${currentDetectedTitle}"`);
            addLog(`ğŸ¯ ì œëª© ê°ì§€ ëª¨ë“œ ì‹œì‘ - í˜„ì¬: "${currentDetectedTitle}"`, 'info');

            let lastLoggedTitle = currentDetectedTitle; // ë§ˆì§€ë§‰ìœ¼ë¡œ ë¡œê·¸ì— í‘œì‹œí•œ ì œëª© (ì¤‘ë³µ ë°©ì§€)

            // 1ì´ˆë§ˆë‹¤ ì œëª© ì²´í¬
            titleCheckInterval = setInterval(() => {
                if (!isRecording || isPaused) {
                    console.log(`ğŸ” [ì œëª©ê°ì§€] ì²´í¬ ì¤‘ì§€ - isRecording: ${isRecording}, isPaused: ${isPaused}`);
                    return;
                }

                const newTitle = getCurrentLectureTitle();
                console.log(`ğŸ” [ì œëª©ê°ì§€] ì²´í¬ ì¤‘ - í˜„ì¬: "${newTitle}"`);

                // ì œëª© ì—…ë°ì´íŠ¸ (í‘œì‹œìš©)
                if (currentDetectedTitleSpan && newTitle) {
                    currentDetectedTitleSpan.textContent = newTitle;
                }

                // ë¡œê·¸ ì˜ì—­ì— ì œëª© ë³€ê²½ í‘œì‹œ (ì¤‘ë³µ ë°©ì§€)
                if (newTitle && newTitle !== lastLoggedTitle) {
                    addLog(`ğŸ” ê°ì§€ëœ ì œëª©: "${newTitle}"`, 'info');
                    lastLoggedTitle = newTitle;
                }

                // ì œëª©ì´ ë³€ê²½ë˜ì—ˆì„ ë•Œ
                if (newTitle && newTitle !== currentDetectedTitle) {
                    console.log(`\nğŸ“Œ ì±•í„° ë³€ê²½ ê°ì§€!`);
                    console.log(`   ì´ì „: ${currentDetectedTitle}`);
                    console.log(`   í˜„ì¬: ${newTitle}`);
                    console.log(`   mediaRecorder ìƒíƒœ: ${mediaRecorder?.state}`);

                    addLog(`ğŸ“Œ ì œëª© ë³€ê²½ ê°ì§€: "${currentDetectedTitle}" â†’ "${newTitle}"`, 'success');

                    // í˜„ì¬ ë…¹ìŒ ì €ì¥ ë° ìƒˆ ë…¹ìŒ ì‹œì‘
                    const previousTitle = currentDetectedTitle;
                    currentDetectedTitle = newTitle;

                    // ìë™ ë¶„í•  ì‹¤í–‰
                    performAutoSplit(previousTitle, newTitle);
                }
            }, 1000); // 1ì´ˆë§ˆë‹¤ ì²´í¬
        }

        /**
         * ìë™ ë¶„í•  ì‹¤í–‰
         */
        function performAutoSplit(previousTitle, newTitle) {
            if (!mediaRecorder || mediaRecorder.state !== 'recording') {
                console.warn('ğŸ” [ìë™ë¶„í• ] ë…¹ìŒ ì¤‘ì´ ì•„ë‹ˆë¯€ë¡œ ë¶„í• ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                console.warn(`   mediaRecorder: ${!!mediaRecorder}, state: ${mediaRecorder?.state}`);
                return;
            }

            console.log(`ğŸ”„ [ìë™ë¶„í• ] ì‹œì‘ - "${previousTitle}" â†’ "${newTitle}"`);

            // onstop ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ë¥¼ ì„ì‹œë¡œ ì¬ì •ì˜
            const currentChunks = [...audioChunks]; // í˜„ì¬ê¹Œì§€ì˜ ì²­í¬ ë³µì‚¬

            mediaRecorder.onstop = () => {
                console.log(`ğŸ’¾ [ìë™ë¶„í• ] ì´ì „ ë…¹ìŒ ì €ì¥ ì¤‘: "${previousTitle}"`);

                // ì´ì „ ë…¹ìŒ ì €ì¥
                const audioBlob = new Blob(currentChunks, { type: currentMimeType });
                saveRecordingWithName(audioBlob, currentRecordingType, previousTitle);

                // ìƒˆ ë…¹ìŒì´ ê³„ì† ì§„í–‰ë˜ì–´ì•¼ í•˜ëŠ”ì§€ í™•ì¸
                if (!isRecording) {
                    console.log('ğŸ›‘ [ìë™ë¶„í• ] ì‚¬ìš©ìê°€ ë…¹ìŒì„ ì¤‘ì§€í–ˆìœ¼ë¯€ë¡œ ì¬ì‹œì‘í•˜ì§€ ì•ŠìŒ');
                    return;
                }

                // ìƒˆ ë…¹ìŒ ì¤€ë¹„
                audioChunks = [];
                lectureCount++;
                recordingStartTime = Date.now();
                startTime = Date.now();
                pausedTime = 0;
                activeChapterName = newTitle;

                console.log(`ğŸ”´ [ìë™ë¶„í• ] ìƒˆ ë…¹ìŒ ì‹œì‘: "${newTitle}"`);
                addLog(`ğŸ”´ ìë™ ë¶„í•  ì™„ë£Œ - ìƒˆ ë…¹ìŒ ì‹œì‘: "${newTitle}"`, 'success');
                updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘ - ${newTitle}`);

                // MediaRecorder ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì¬ì„¤ì •
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    console.log(`ğŸ’¾ [ì •ìƒì¢…ë£Œ] ë…¹ìŒ ì €ì¥ ì¤‘: "${activeChapterName || `ê°•ì˜${lectureCount}`}"`);
                    const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                    const baseName = activeChapterName || `ê°•ì˜${lectureCount}`;
                    saveRecordingWithName(audioBlob, currentRecordingType, baseName);
                };

                // ìƒˆ ë…¹ìŒ ì‹œì‘
                try {
                    mediaRecorder.start();
                    console.log(`âœ… [ìë™ë¶„í• ] MediaRecorder.start() ì„±ê³µ`);
                } catch (error) {
                    console.error(`âŒ [ìë™ë¶„í• ] MediaRecorder.start() ì‹¤íŒ¨:`, error);
                    addLog(`âŒ ë…¹ìŒ ì¬ì‹œì‘ ì‹¤íŒ¨: ${error.message}`, 'error');
                }
            };

            // í˜„ì¬ ë…¹ìŒ ì¤‘ì§€ (onstop ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°)
            console.log(`â¸ï¸ [ìë™ë¶„í• ] í˜„ì¬ ë…¹ìŒ ì¤‘ì§€ ì¤‘...`);
            mediaRecorder.stop();
        }

        /**
         * ì œëª© ê°ì§€ ì¤‘ì§€
         */
        function stopTitleDetection() {
            if (titleCheckInterval) {
                clearInterval(titleCheckInterval);
                titleCheckInterval = null;
            }
            console.log('ğŸ›‘ ì œëª© ê°ì§€ ì¤‘ì§€');
        }

        // ============ ì œëª© ê°ì§€ ìë™ ë¶„í•  ë ============

        // ============ í´ë¦½ë³´ë“œ ê¸°ë°˜ ìë™ ë¶„í•  ============

        /**
         * í´ë¦½ë³´ë“œ ê°ì‹œ ì‹œì‘
         */
        async function startClipboardDetection() {
            if (clipboardCheckInterval) {
                clearInterval(clipboardCheckInterval);
            }

            // ì´ˆê¸° í´ë¦½ë³´ë“œ ê°’ ì½ê¸°
            try {
                const text = await navigator.clipboard.readText();
                lastClipboardText = text;
                clipboardDetectedTitle = text;
                if (clipboardDetectedTitleSpan) {
                    clipboardDetectedTitleSpan.textContent = text || 'í´ë¦½ë³´ë“œê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤';
                }
                if (clipboardLastChange) {
                    clipboardLastChange.textContent = new Date().toLocaleTimeString('ko-KR');
                }
                console.log(`ğŸ“‹ í´ë¦½ë³´ë“œ ê°ì‹œ ì‹œì‘ - í˜„ì¬: "${text}"`);
                addLog(`ğŸ“‹ í´ë¦½ë³´ë“œ ê°ì‹œ ëª¨ë“œ ì‹œì‘ - í˜„ì¬: "${text}"`, 'info');
            } catch (error) {
                console.error('í´ë¦½ë³´ë“œ ì ‘ê·¼ ê¶Œí•œ ì˜¤ë¥˜:', error);
                addLog(`âš ï¸ í´ë¦½ë³´ë“œ ì ‘ê·¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.`, 'warning');
                if (clipboardDetectedTitleSpan) {
                    clipboardDetectedTitleSpan.textContent = 'ê¶Œí•œ ì˜¤ë¥˜';
                }
            }

            // 1ì´ˆë§ˆë‹¤ í´ë¦½ë³´ë“œ ì²´í¬
            clipboardCheckInterval = setInterval(async () => {
                if (!isRecording || isPaused) {
                    return;
                }

                try {
                    const text = await navigator.clipboard.readText();

                    // í´ë¦½ë³´ë“œ ë‚´ìš©ì´ ë³€ê²½ë˜ì—ˆì„ ë•Œ
                    if (text && text !== lastClipboardText) {
                        console.log(`\nğŸ“‹ í´ë¦½ë³´ë“œ ë³€ê²½ ê°ì§€!`);
                        console.log(`   ì´ì „: ${lastClipboardText}`);
                        console.log(`   í˜„ì¬: ${text}`);

                        addLog(`ğŸ“‹ í´ë¦½ë³´ë“œ ë³€ê²½ ê°ì§€: "${lastClipboardText}" â†’ "${text}"`, 'success');

                        // UI ì—…ë°ì´íŠ¸
                        if (clipboardDetectedTitleSpan) {
                            clipboardDetectedTitleSpan.textContent = text;
                        }
                        if (clipboardLastChange) {
                            clipboardLastChange.textContent = new Date().toLocaleTimeString('ko-KR');
                        }

                        const previousText = lastClipboardText;
                        lastClipboardText = text;
                        clipboardDetectedTitle = text;

                        // ìë™ ë¶„í•  ì‹¤í–‰
                        performClipboardAutoSplit(previousText, text);
                    }
                } catch (error) {
                    // í´ë¦½ë³´ë“œ ì ‘ê·¼ ì‹¤íŒ¨ ì‹œ ì¡°ìš©íˆ ë¬´ì‹œ (ê¶Œí•œ ë¬¸ì œì¼ ìˆ˜ ìˆìŒ)
                }
            }, 1000); // 1ì´ˆë§ˆë‹¤ ì²´í¬
        }

        /**
         * í´ë¦½ë³´ë“œ ê¸°ë°˜ ìë™ ë¶„í•  ì‹¤í–‰
         */
        function performClipboardAutoSplit(previousText, newText) {
            if (!mediaRecorder || mediaRecorder.state !== 'recording') {
                console.warn('ğŸ“‹ [í´ë¦½ë³´ë“œ ë¶„í• ] ë…¹ìŒ ì¤‘ì´ ì•„ë‹ˆë¯€ë¡œ ë¶„í• ì„ ê±´ë„ˆëœë‹ˆë‹¤');
                return;
            }

            console.log(`ğŸ“‹ [í´ë¦½ë³´ë“œ ë¶„í• ] ì‹¤í–‰ ì‹œì‘`);
            console.log(`   ì´ì „: "${previousText}"`);
            console.log(`   ìƒˆ ì œëª©: "${newText}"`);

            addLog(`ğŸ”„ ê°•ì˜ ë¶„í•  ì¤‘... (í´ë¦½ë³´ë“œ ë³€ê²½ ê°ì§€)`, 'info');

            // ê¸°ì¡´ ìº¡ì²˜ ì¤‘ì§€ ë° PDF ì €ì¥
            if (capturedImages.length > 0) {
                stopCapture();
                const previousName = parseClipboardTitle(previousText);
                saveCapturedImagesToPDF(previousName);
            }

            // ê°•ì˜ ì¹´ìš´íŠ¸ ì¦ê°€
            lectureCount++;

            // MediaRecorder ì¬ì‹œì‘
            mediaRecorder.onstop = () => {
                console.log(`ğŸ’¾ [í´ë¦½ë³´ë“œ ë¶„í• ] ì´ì „ ë…¹ìŒ ì €ì¥: "${parseClipboardTitle(previousText)}"`);
                const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                const baseName = parseClipboardTitle(previousText);
                saveRecordingWithName(audioBlob, currentRecordingType, baseName);

                // ìƒˆ ë…¹ìŒ ì‹œì‘
                audioChunks = [];
                activeChapterName = parseClipboardTitle(newText);

                console.log(`ğŸ¬ [í´ë¦½ë³´ë“œ ë¶„í• ] ìƒˆ ë…¹ìŒ ì‹œì‘: "${activeChapterName}"`);
                addLog(`ğŸ¬ ìƒˆ ê°•ì˜ ë…¹ìŒ ì‹œì‘: "${activeChapterName}" (ê°•ì˜ ${lectureCount})`, 'success');

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    console.log(`ğŸ’¾ [ì •ìƒì¢…ë£Œ] ë…¹ìŒ ì €ì¥ ì¤‘: "${activeChapterName || `ê°•ì˜${lectureCount}`}"`);
                    const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                    const baseName = activeChapterName || `ê°•ì˜${lectureCount}`;
                    saveRecordingWithName(audioBlob, currentRecordingType, baseName);
                };

                // ìƒˆ ë…¹ìŒ ì‹œì‘
                try {
                    mediaRecorder.start();
                    console.log(`âœ… [í´ë¦½ë³´ë“œ ë¶„í• ] MediaRecorder.start() ì„±ê³µ`);

                    // ìº¡ì²˜ ì¬ì‹œì‘
                    if (captureEnabled && captureEnabled.checked) {
                        startCapture();
                    }
                } catch (error) {
                    console.error(`âŒ [í´ë¦½ë³´ë“œ ë¶„í• ] MediaRecorder.start() ì‹¤íŒ¨:`, error);
                    addLog(`âŒ ë…¹ìŒ ì¬ì‹œì‘ ì‹¤íŒ¨: ${error.message}`, 'error');
                }
            };

            // í˜„ì¬ ë…¹ìŒ ì¤‘ì§€
            mediaRecorder.stop();
        }

        /**
         * í´ë¦½ë³´ë“œ í…ìŠ¤íŠ¸ë¥¼ íŒŒì¼ëª…ìœ¼ë¡œ íŒŒì‹±
         * í˜•ì‹: "114 - Ch 5 - 03. RAG ì½”ë“œ êµ¬í˜„í•˜ê¸°"
         */
        function parseClipboardTitle(clipboardText) {
            if (!clipboardText) return `ê°•ì˜${lectureCount}`;

            // ëª©ì°¨ ë¶„ì„ì´ ë˜ì–´ ìˆëŠ” ê²½ìš°, lecture ì´ë¦„ë§Œ ë¹„êµ
            if (chapters.length > 0) {
                // clipboardTextì—ì„œ ê°•ì˜ ì´ë¦„ ì¶”ì¶œ
                const parts = clipboardText.split('-').map(p => p.trim());
                const lectureName = parts[parts.length - 1] || clipboardText;

                // ì±•í„° ëª©ë¡ì—ì„œ ë§¤ì¹­ë˜ëŠ” ê°•ì˜ ì°¾ê¸°
                for (const chapter of chapters) {
                    if (chapter.name && chapter.name.includes(lectureName)) {
                        return chapter.name;
                    }
                }
            }

            // ëª©ì°¨ ë¶„ì„ì´ ì•ˆ ë˜ì–´ ìˆìœ¼ë©´ í´ë¦½ë³´ë“œ ë¬¸ìì—´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
            // íŒŒì¼ëª…ì— ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ë¬¸ì ì œê±°
            return clipboardText.replace(/[<>:"/\\|?*]/g, '_');
        }

        /**
         * í´ë¦½ë³´ë“œ ê°ì‹œ ì¤‘ì§€
         */
        function stopClipboardDetection() {
            if (clipboardCheckInterval) {
                clearInterval(clipboardCheckInterval);
                clipboardCheckInterval = null;
            }
            console.log('ğŸ›‘ í´ë¦½ë³´ë“œ ê°ì‹œ ì¤‘ì§€');
        }

        // ============ í´ë¦½ë³´ë“œ ê¸°ë°˜ ìë™ ë¶„í•  ë ============

        // ============ CSV ê¸°ë°˜ ì¼ê´„ ë¶„í•  ============

        /**
         * CSV íŒŒì¼ íŒŒì‹±
         */
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('CSV íŒŒì¼ì´ ë¹„ì–´ìˆê±°ë‚˜ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }

            const headers = lines[0].split(',').map(h => h.trim());
            const requiredHeaders = ['startTime', 'endTime', 'donut', 'chapter', 'lecture', 'fullText'];

            for (const required of requiredHeaders) {
                if (!headers.includes(required)) {
                    throw new Error(`CSV íŒŒì¼ì— í•„ìˆ˜ ì»¬ëŸ¼ì´ ì—†ìŠµë‹ˆë‹¤: ${required}`);
                }
            }

            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index];
                });
                data.push(row);
            }

            return data;
        }

        /**
         * CSV ì¼ê´„ ì²˜ë¦¬ ì‹¤í–‰
         */
        async function processCsvBatch() {
            if (!csvData || !fullWebmFile) {
                addLog('âŒ CSV íŒŒì¼ê³¼ webm íŒŒì¼ì´ í•„ìš”í•©ë‹ˆë‹¤.', 'error');
                return;
            }

            batchProcessStatus.style.display = 'block';
            batchProgressText.textContent = 'ì²˜ë¦¬ ì‹œì‘...';
            batchProgressBar.style.width = '0%';

            addLog(`ğŸ“Š CSV ì¼ê´„ ì²˜ë¦¬ ì‹œì‘ - ì´ ${csvData.length}ê°œ ê°•ì˜`, 'info');

            try {
                // 1. webm íŒŒì¼ì„ Audio ê°ì²´ë¡œ ë¡œë“œ
                const audioUrl = URL.createObjectURL(fullWebmFile);
                const audio = new Audio(audioUrl);

                await new Promise((resolve, reject) => {
                    audio.onloadedmetadata = resolve;
                    audio.onerror = reject;
                });

                addLog(`âœ… webm íŒŒì¼ ë¡œë“œ ì™„ë£Œ (ê¸¸ì´: ${formatTime(audio.duration * 1000)})`, 'success');

                // 2. ê° ê°•ì˜ë³„ë¡œ webm ë¶„ë¦¬ (MediaRecorder í™œìš©)
                // ì°¸ê³ : ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤ì‹œê°„ ë¶„ë¦¬ëŠ” ì œí•œì ì´ë¯€ë¡œ,
                // ì‹¤ì œë¡œëŠ” íƒ€ì„ìŠ¤íƒ¬í”„ ì •ë³´ë§Œ ì €ì¥í•˜ê³  ì‚¬ìš©ìì—ê²Œ ì•ˆë‚´

                batchProgressText.textContent = `CSV ì •ë³´ ì²˜ë¦¬ ì¤‘... (ì´ ${csvData.length}ê°œ)`;

                for (let i = 0; i < csvData.length; i++) {
                    const row = csvData[i];
                    const progress = ((i + 1) / csvData.length * 100).toFixed(0);
                    batchProgressBar.style.width = `${progress}%`;
                    batchProgressText.textContent = `ì²˜ë¦¬ ì¤‘: ${i + 1}/${csvData.length} - ${row.fullText}`;

                    const fileName = `${row.donut}${row.chapter ? ' - ' + row.chapter : ''} - ${row.lecture}.webm`;

                    addLog(`ğŸ“ [${i + 1}/${csvData.length}] ${fileName}`, 'info');
                    addLog(`   â° ì‹œì‘: ${row.startTime}, ì¢…ë£Œ: ${row.endTime}`, 'info');

                    // ì‹¤ì œ ë¶„ë¦¬ëŠ” ì„œë²„ ì‚¬ì´ë“œ ë˜ëŠ” FFmpeg.js í•„ìš”
                    // ì—¬ê¸°ì„œëŠ” ì •ë³´ë§Œ í‘œì‹œ

                    await new Promise(resolve => setTimeout(resolve, 100)); // UI ì—…ë°ì´íŠ¸ ëŒ€ê¸°
                }

                batchProgressText.textContent = 'ì²˜ë¦¬ ì™„ë£Œ!';
                batchProgressBar.style.width = '100%';

                addLog(`âœ… CSV ì¼ê´„ ì²˜ë¦¬ ì™„ë£Œ`, 'success');
                addLog(`â„¹ï¸ ì‹¤ì œ webm ë¶„ë¦¬ëŠ” FFmpeg ë“±ì˜ ì™¸ë¶€ ë„êµ¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.`, 'warning');
                addLog(`â„¹ï¸ CSVì— ê¸°ë¡ëœ ì‹œê°„ ì •ë³´ë¥¼ ì°¸ê³ í•˜ì—¬ ìˆ˜ë™ìœ¼ë¡œ ë¶„ë¦¬í•˜ì„¸ìš”.`, 'warning');

            } catch (error) {
                addLog(`âŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ${error.message}`, 'error');
                batchProgressText.textContent = `ì˜¤ë¥˜ ë°œìƒ: ${error.message}`;
            }
        }

        // ============ CSV ê¸°ë°˜ ì¼ê´„ ë¶„í•  ë ============

        function cleanup() {
            streams.forEach(stream => {
                stream.getTracks().forEach(track => track.stop());
            });
            streams = [];

            if (audioContext) {
                audioContext.close().catch(() => { });
                audioContext = null;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            // ì œëª© ê°ì§€ ì¤‘ì§€
            stopTitleDetection();

            // í´ë¦½ë³´ë“œ ê°ì‹œ ì¤‘ì§€
            stopClipboardDetection();

            analyser = null;
            dataArray = null;

            stopCapture();
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            if (videoElement) {
                videoElement.remove();
                videoElement = null;
            }

            // í™”ë©´ ë³€í™” ê°ì§€ ì •ë¦¬
            stopSceneChangeDetection();
            if (sceneChangeDetector) {
                sceneChangeDetector.destroy();
                sceneChangeDetector = null;
            }

            // í…œí”Œë¦¿ ë§¤ì¹­ ì •ë¦¬
            stopTemplateMatching();
            if (templateMatcher) {
                templateMatcher.destroy();
                templateMatcher = null;
            }

            // ë™ì˜ìƒ ì œëª© ê°ì§€ ì •ë¦¬
            if (videoTitleDetector) {
                videoTitleDetector.destroy();
                videoTitleDetector = null;
            }
            
            // ì œëª© ê°ì§€ ìë™ ë¶„í•  ì •ë¦¬
            stopTitleDetection();
        }

        // ìº¡ì²˜ ê´€ë ¨ ìƒìˆ˜
        const TARGET_WIDTH = 1280;
        const TARGET_HEIGHT = 720;

        function startCapture() {
            if (!captureEnabled.checked || !videoElement) return;

            const interval = parseInt(captureInterval.value) * 1000;
            captureTimer = setInterval(captureFrame, interval);
            captureFrame(); // ì²« í”„ë ˆì„ ì¦‰ì‹œ ìº¡ì²˜
        }

        function stopCapture() {
            if (captureTimer) {
                clearInterval(captureTimer);
                captureTimer = null;
            }
        }

        function captureFrame() {
            if (!videoElement || videoElement.readyState < 2) return;

            const vw = videoElement.videoWidth;
            const vh = videoElement.videoHeight;

            // 1280x720 ê³ ì • ìº”ë²„ìŠ¤
            const canvas = document.createElement('canvas');
            canvas.width = TARGET_WIDTH;
            canvas.height = TARGET_HEIGHT;
            const ctx = canvas.getContext('2d');

            // ì›ë³¸ ë¹„ìœ¨ ìœ ì§€ + Contain ë°©ì‹
            const scale = Math.min(
                TARGET_WIDTH / vw,
                TARGET_HEIGHT / vh
            );

            const drawW = vw * scale;
            const drawH = vh * scale;

            const offsetX = (TARGET_WIDTH - drawW) / 2;
            const offsetY = (TARGET_HEIGHT - drawH) / 2;

            // ì—¬ë°± ë°°ê²½ìƒ‰ (ê²€ì • ë°”íƒ•)
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);

            // ë¹„ìœ¨ ìœ ì§€ëœ ìƒíƒœë¡œ ê°€ìš´ë° ì •ë ¬
            ctx.drawImage(videoElement, offsetX, offsetY, drawW, drawH);

            const quality = parseFloat(captureQuality.value);
            const imageData = canvas.toDataURL("image/webp", quality);

            capturedImages.push(imageData);
            captureCount++;

            updateCaptureStatus();
        }

        function updateCaptureStatus() {
            if (captureCount > 0) {
                captureStatus.textContent = `ğŸ“¸ ${captureCount}ì¥ ìº¡ì²˜ë¨`;
            } else {
                captureStatus.textContent = '';
            }
        }

        // í™”ë©´ ë³€í™” ê°ì§€ ì‹œìŠ¤í…œ
        class SceneChangeDetector {
            constructor(videoElement) {
                this.video = videoElement;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.lastFrameData = null;
                this.lastHistogram = null;
                this.changeThreshold = 0.15; // 15% ì´ìƒ ë³€í™” ì‹œ ì¥ë©´ ì „í™˜ìœ¼ë¡œ íŒë‹¨
                this.minChangePixels = 50000; // ìµœì†Œ ë³€í™” í”½ì…€ ìˆ˜
                this.histogramThreshold = 0.25; // 25% ì´ìƒ íˆìŠ¤í† ê·¸ë¨ ë³€í™” ì‹œ ì¥ë©´ ì „í™˜
                this.lastChangeTime = 0;
                this.cooldownPeriod = 3000; // 3ì´ˆ ì¿¨ë‹¤ìš´ (ê°™ì€ ê°•ì˜ ë‚´ ì „í™˜ ë¬´ì‹œ)

                // ìƒ˜í”Œë§ í•´ìƒë„ (ì„±ëŠ¥ ìµœì í™”)
                this.sampleWidth = 160;
                this.sampleHeight = 90;
                this.canvas.width = this.sampleWidth;
                this.canvas.height = this.sampleHeight;

                // ì—°ì† í”„ë ˆì„ ë³€í™” ì¶”ì  (ë™ì˜ìƒ ì „í™˜ ê°ì§€ìš©)
                this.consecutiveChanges = 0;
                this.consecutiveThreshold = 3; // 3í”„ë ˆì„ ì—°ì† ë³€í™” ì‹œ ë™ì˜ìƒ ì „í™˜ìœ¼ë¡œ íŒë‹¨

                // ê°ì§€ ëª¨ë“œ ('basic', 'mode1', 'mode2', 'mode3')
                this.detectionMode = 'basic';
                this.mode2ReferenceImage = null; // ëª¨ë“œ2ìš© ì°¸ì¡° ì´ë¯¸ì§€

                // ëª¨ë“œ3: ë¬´ìŒ ê°ì§€ìš© ë³€ìˆ˜
                this.silenceStartTime = null;
                this.silenceDuration = 4000; // 4ì´ˆ
            }

            captureFrame() {
                if (!this.video || this.video.readyState < 2) return null;

                const vw = this.video.videoWidth;
                const vh = this.video.videoHeight;

                if (!vw || !vh) return null;

                // ë¹„ìœ¨ ìœ ì§€í•˜ë©° ìº”ë²„ìŠ¤ì— ë§ì¶¤ (letterbox ì œê±°)
                const scale = Math.min(
                    this.sampleWidth / vw,
                    this.sampleHeight / vh
                );

                const drawW = vw * scale;
                const drawH = vh * scale;
                const offsetX = (this.sampleWidth - drawW) / 2;
                const offsetY = (this.sampleHeight - drawH) / 2;

                // ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (ê²€ì€ ë°°ê²½)
                this.ctx.fillStyle = "#000";
                this.ctx.fillRect(0, 0, this.sampleWidth, this.sampleHeight);

                // ì‹¤ì œ ë¹„ë””ì˜¤ ì½˜í…ì¸ ë§Œ ê·¸ë¦¬ê¸°
                this.ctx.drawImage(this.video, offsetX, offsetY, drawW, drawH);

                return this.ctx.getImageData(0, 0, this.sampleWidth, this.sampleHeight);
            }

            // íˆìŠ¤í† ê·¸ë¨ ê³„ì‚° (ìƒ‰ìƒ ë¶„í¬ ë¶„ì„)
            calculateHistogram(frameData) {
                if (!frameData) return null;

                const histogram = {
                    r: new Array(16).fill(0),
                    g: new Array(16).fill(0),
                    b: new Array(16).fill(0),
                    brightness: new Array(16).fill(0)
                };

                const data = frameData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // 16ê°œ êµ¬ê°„ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì¹´ìš´íŠ¸
                    histogram.r[Math.floor(r / 16)]++;
                    histogram.g[Math.floor(g / 16)]++;
                    histogram.b[Math.floor(b / 16)]++;

                    // ë°ê¸° ê³„ì‚° (ê°„ë‹¨í•œ í‰ê· )
                    const brightness = (r + g + b) / 3;
                    histogram.brightness[Math.floor(brightness / 16)]++;
                }

                // ì •ê·œí™”
                const totalPixels = data.length / 4;
                for (let i = 0; i < 16; i++) {
                    histogram.r[i] /= totalPixels;
                    histogram.g[i] /= totalPixels;
                    histogram.b[i] /= totalPixels;
                    histogram.brightness[i] /= totalPixels;
                }

                return histogram;
            }

            // íˆìŠ¤í† ê·¸ë¨ ì°¨ì´ ê³„ì‚°
            compareHistograms(hist1, hist2) {
                if (!hist1 || !hist2) return 0;

                let totalDiff = 0;
                const channels = ['r', 'g', 'b', 'brightness'];

                for (const channel of channels) {
                    for (let i = 0; i < 16; i++) {
                        totalDiff += Math.abs(hist1[channel][i] - hist2[channel][i]);
                    }
                }

                return totalDiff / (16 * channels.length);
            }

            calculateDifference(frame1, frame2) {
                if (!frame1 || !frame2) return 0;

                const data1 = frame1.data;
                const data2 = frame2.data;
                let diffPixels = 0;
                let totalDiff = 0;

                // í”½ì…€ ë‹¨ìœ„ë¡œ RGB ì°¨ì´ ê³„ì‚° (4í”½ì…€ì”© ê±´ë„ˆë›°ë©° ìƒ˜í”Œë§)
                for (let i = 0; i < data1.length; i += 16) { // RGBAì´ë¯€ë¡œ 4í”½ì…€ = 16ë°”ì´íŠ¸
                    const r1 = data1[i];
                    const g1 = data1[i + 1];
                    const b1 = data1[i + 2];
                    const r2 = data2[i];
                    const g2 = data2[i + 1];
                    const b2 = data2[i + 2];

                    const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);

                    // ì„ê³„ê°’ ì´ìƒì˜ ë³€í™”ë§Œ ì¹´ìš´íŠ¸ (ë¯¸ì„¸í•œ ë³€í™” ë¬´ì‹œ)
                    if (diff > 30) {
                        diffPixels++;
                        totalDiff += diff;
                    }
                }

                const totalPixels = (data1.length / 4) / 4; // ìƒ˜í”Œë§í•œ í”½ì…€ ìˆ˜
                const changeRatio = diffPixels / totalPixels;
                const avgDiff = diffPixels > 0 ? totalDiff / diffPixels : 0;

                return { changeRatio, diffPixels, avgDiff };
            }

            // ì˜¬ë¸”ë™ í™”ë©´ ê°ì§€
            isBlackScreen(frameData) {
                if (!frameData) return false;

                const data = frameData.data;
                let totalBrightness = 0;
                const sampleSize = Math.min(1000, data.length / 4); // ìµœëŒ€ 1000ê°œ í”½ì…€ ìƒ˜í”Œë§

                for (let i = 0; i < sampleSize * 4; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    totalBrightness += (r + g + b) / 3;
                }

                const avgBrightness = totalBrightness / sampleSize;
                const isBlack = avgBrightness < 15; // í‰ê·  ë°ê¸°ê°€ 15 ë¯¸ë§Œì´ë©´ ë¸”ë™

                if (isBlack) {
                    console.log(`â¬› ì˜¬ë¸”ë™ í™”ë©´ ê°ì§€! í‰ê·  ë°ê¸°: ${avgBrightness.toFixed(1)}`);
                }

                return isBlack;
            }

            checkSceneChange() {
                // ì²´í¬ë°•ìŠ¤ë¡œ ì„ íƒëœ ì¡°ê±´ë“¤ì„ AND ì¡°ê±´ìœ¼ë¡œ ê²°í•©
                const conditions = [];
                let allSatisfied = true;

                // ê¸°ë³¸ ê°ì§€ ì²´í¬
                if (detectBasic.checked) {
                    const basicDetected = this.checkBasicSceneChange();
                    conditions.push({ name: 'ê¸°ë³¸', result: basicDetected });
                    if (!basicDetected) allSatisfied = false;
                }

                // ëª¨ë“œ1 ê°ì§€ ì²´í¬ (ê¸°ë³¸ì´ ë§Œì¡±ëœ ê²½ìš°ë§Œ)
                if (detectMode1.checked && allSatisfied) {
                    const mode1Detected = this.checkMode1WhiteBackground();
                    conditions.push({ name: 'ëª¨ë“œ1', result: mode1Detected });
                    if (!mode1Detected) allSatisfied = false;
                }

                // ëª¨ë“œ2 ê°ì§€ ì²´í¬ (ì´ì „ ì¡°ê±´ë“¤ì´ ëª¨ë‘ ë§Œì¡±ëœ ê²½ìš°ë§Œ)
                if (detectMode2.checked && allSatisfied) {
                    const mode2Detected = this.checkMode2ImageMatch();
                    conditions.push({ name: 'ëª¨ë“œ2', result: mode2Detected });
                    if (!mode2Detected) allSatisfied = false;
                }

                // ëª¨ë“œ3 ê°ì§€ ì²´í¬ (ì´ì „ ì¡°ê±´ë“¤ì´ ëª¨ë‘ ë§Œì¡±ëœ ê²½ìš°ë§Œ)
                if (detectMode3.checked && allSatisfied) {
                    const mode3Detected = this.checkMode3Silence();
                    conditions.push({ name: 'ëª¨ë“œ3', result: mode3Detected });
                    if (!mode3Detected) allSatisfied = false;
                }

                // ëª¨ë“  ì¡°ê±´ì´ ë§Œì¡±ë˜ì—ˆì„ ë•Œë§Œ ì „í™˜
                if (allSatisfied && conditions.length > 0) {
                    const conditionNames = conditions.map(c => c.name).join(' + ');
                    console.log(`âœ… [ì¡°í•© ê°ì§€] ${conditionNames} ì¡°ê±´ ëª¨ë‘ ë§Œì¡±!`);
                    addLog(`âœ… ${conditionNames} ì¡°ê±´ ëª¨ë‘ ë§Œì¡± â†’ ì „í™˜`, 'success');
                    return true;
                }

                return false;
            }

            // ê¸°ë³¸ ëª¨ë“œ: í”½ì…€ + íˆìŠ¤í† ê·¸ë¨ ë¶„ì„
            checkBasicSceneChange() {
                const currentFrame = this.captureFrame();
                if (!currentFrame) return false;

                // íˆìŠ¤í† ê·¸ë¨ ê³„ì‚°
                const currentHistogram = this.calculateHistogram(currentFrame);

                if (!this.lastFrameData || !this.lastHistogram) {
                    this.lastFrameData = currentFrame;
                    this.lastHistogram = currentHistogram;
                    this.consecutiveChanges = 0;
                    return false;
                }

                const now = Date.now();
                if (now - this.lastChangeTime < this.cooldownPeriod) {
                    this.lastFrameData = currentFrame;
                    this.lastHistogram = currentHistogram;
                    this.consecutiveChanges = 0;
                    return false;
                }

                // í”½ì…€ ë‹¨ìœ„ ì°¨ì´ ê³„ì‚°
                const diff = this.calculateDifference(this.lastFrameData, currentFrame);

                // íˆìŠ¤í† ê·¸ë¨ ì°¨ì´ ê³„ì‚° (ìƒ‰ìƒ ë¶„í¬ ë³€í™”)
                const histDiff = this.compareHistograms(this.lastHistogram, currentHistogram);

                this.lastFrameData = currentFrame;
                this.lastHistogram = currentHistogram;

                // ë™ì˜ìƒ ì „í™˜ ê°ì§€ ì¡°ê±´:
                // 1. í”½ì…€ ë³€í™”ìœ¨ì´ ë†’ìŒ (ê¸‰ê²©í•œ í™”ë©´ ë³€í™”)
                // 2. íˆìŠ¤í† ê·¸ë¨ ë³€í™”ê°€ í¼ (ìƒ‰ìƒ ë¶„í¬ ë³€í™”)
                // 3. ì—°ì† í”„ë ˆì„ ë³€í™” ì¶”ì 
                const hasPixelChange = diff.changeRatio > this.changeThreshold && diff.diffPixels > this.minChangePixels;
                const hasHistogramChange = histDiff > this.histogramThreshold;

                // ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë„ í° ë³€í™”ê°€ ìˆìœ¼ë©´ ì¹´ìš´íŠ¸ ì¦ê°€
                if (hasPixelChange || hasHistogramChange) {
                    this.consecutiveChanges++;
                    console.log(`ğŸ” í™”ë©´ ë³€í™” (${this.consecutiveChanges}/${this.consecutiveThreshold}) - í”½ì…€: ${(diff.changeRatio * 100).toFixed(1)}%, íˆìŠ¤í† ê·¸ë¨: ${(histDiff * 100).toFixed(1)}%`);
                    addLog(`ğŸ” [DEBUG] í™”ë©´ ë³€í™” ê°ì§€ (${this.consecutiveChanges}/${this.consecutiveThreshold}) - í”½ì…€: ${(diff.changeRatio * 100).toFixed(1)}%, íˆìŠ¤í† ê·¸ë¨: ${(histDiff * 100).toFixed(1)}%`, 'info');
                } else {
                    this.consecutiveChanges = 0;
                }

                // ì—°ì† Ní”„ë ˆì„ ì´ìƒ ë³€í™” ì‹œ ë™ì˜ìƒ ì „í™˜ìœ¼ë¡œ íŒë‹¨
                const isVideoTransition = this.consecutiveChanges >= this.consecutiveThreshold;

                if (isVideoTransition) {
                    this.lastChangeTime = now;
                    this.consecutiveChanges = 0;
                    console.log(`ğŸ¬ ë™ì˜ìƒ ì „í™˜ ê°ì§€! í”½ì…€ ë³€í™”ìœ¨: ${(diff.changeRatio * 100).toFixed(1)}%, íˆìŠ¤í† ê·¸ë¨ ë³€í™”: ${(histDiff * 100).toFixed(1)}%`);
                    addLog(`ğŸ¬ ë™ì˜ìƒ ì „í™˜ ê°ì§€! (í”½ì…€: ${(diff.changeRatio * 100).toFixed(1)}%, ìƒ‰ìƒë¶„í¬: ${(histDiff * 100).toFixed(1)}%)`, 'success');
                }

                return isVideoTransition;
            }

            // ëª¨ë“œ1: í•˜ì–€ ë°°ê²½ + ì¤‘ì•™ ì‘ì€ ë¡œê³  ê°ì§€
            checkMode1WhiteBackground() {
                const currentFrame = this.captureFrame();
                if (!currentFrame) return false;

                const data = currentFrame.data;
                let whitePixels = 0;
                let darkCenterPixels = 0;
                const totalPixels = data.length / 4;

                // ì¤‘ì•™ ì˜ì—­ ê³„ì‚° (ì „ì²´ì˜ 20% ì¤‘ì•™ ì˜ì—­)
                const centerStartX = Math.floor(this.sampleWidth * 0.4);
                const centerEndX = Math.floor(this.sampleWidth * 0.6);
                const centerStartY = Math.floor(this.sampleHeight * 0.4);
                const centerEndY = Math.floor(this.sampleHeight * 0.6);

                for (let y = 0; y < this.sampleHeight; y++) {
                    for (let x = 0; x < this.sampleWidth; x++) {
                        const idx = (y * this.sampleWidth + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const brightness = (r + g + b) / 3;

                        // í•˜ì–€ìƒ‰ íŒì • (ë°ê¸° 200 ì´ìƒ)
                        if (brightness > 200) {
                            whitePixels++;
                        }

                        // ì¤‘ì•™ ì˜ì—­ì˜ ì–´ë‘ìš´ í”½ì…€ (ë¡œê³  ì˜ì—­)
                        if (x >= centerStartX && x <= centerEndX &&
                            y >= centerStartY && y <= centerEndY) {
                            if (brightness < 150) { // ì¤‘ì•™ì— ì–´ë‘ìš´ ì˜ì—­ ìˆìŒ
                                darkCenterPixels++;
                            }
                        }
                    }
                }

                const whiteRatio = whitePixels / totalPixels;
                const centerArea = (centerEndX - centerStartX) * (centerEndY - centerStartY);
                const darkCenterRatio = darkCenterPixels / centerArea;

                // í™”ë©´ì˜ 70% ì´ìƒì´ í•˜ì–—ê³ , ì¤‘ì•™ì— 10% ì´ìƒ ì–´ë‘ìš´ ì˜ì—­ (ë¡œê³ )
                const isWhiteBackgroundWithLogo = whiteRatio > 0.7 && darkCenterRatio > 0.1;

                if (isWhiteBackgroundWithLogo) {
                    console.log(`âœ“ [ëª¨ë“œ1 ì¡°ê±´] í•˜ì–€ ë°°ê²½ + ì¤‘ì•™ ë¡œê³  ê°ì§€! (í•˜ì–€ìƒ‰: ${(whiteRatio * 100).toFixed(1)}%, ì¤‘ì•™ ë¡œê³ : ${(darkCenterRatio * 100).toFixed(1)}%)`);
                    return true;
                }

                this.lastFrameData = currentFrame;
                return false;
            }

            // ëª¨ë“œ2: íŠ¹ì • ì´ë¯¸ì§€ ë§¤ì¹­
            checkMode2ImageMatch() {
                if (!this.mode2ReferenceImage) {
                    console.warn('âš ï¸ ëª¨ë“œ2: ì°¸ì¡° ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    return false;
                }

                const currentFrame = this.captureFrame();
                if (!currentFrame) return false;

                // ì°¸ì¡° ì´ë¯¸ì§€ë¥¼ í˜„ì¬ í”„ë ˆì„ í¬ê¸°ë¡œ ë¦¬ìƒ˜í”Œë§
                const refCanvas = document.createElement('canvas');
                refCanvas.width = this.sampleWidth;
                refCanvas.height = this.sampleHeight;
                const refCtx = refCanvas.getContext('2d');

                // ì°¸ì¡° ì´ë¯¸ì§€ë¥¼ ì„ì‹œ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.mode2ReferenceImage.width;
                tempCanvas.height = this.mode2ReferenceImage.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(this.mode2ReferenceImage, 0, 0);

                // ë¦¬ìƒ˜í”Œë§
                refCtx.drawImage(tempCanvas, 0, 0, this.sampleWidth, this.sampleHeight);
                const resizedRef = refCtx.getImageData(0, 0, this.sampleWidth, this.sampleHeight);

                // ìœ ì‚¬ë„ ê³„ì‚°
                const similarity = this.calculateImageSimilarity(currentFrame, resizedRef);

                // 70% ì´ìƒ ìœ ì‚¬í•˜ë©´ ë§¤ì¹­
                const matched = similarity > 0.7;

                if (matched) {
                    console.log(`âœ“ [ëª¨ë“œ2 ì¡°ê±´] íŠ¹ì • ì´ë¯¸ì§€ ë§¤ì¹­ ê°ì§€! (ìœ ì‚¬ë„: ${(similarity * 100).toFixed(1)}%)`);
                    return true;
                }

                this.lastFrameData = currentFrame;
                return false;
            }

            // ë‘ ì´ë¯¸ì§€ì˜ ìœ ì‚¬ë„ ê³„ì‚° (í”½ì…€ ë‹¨ìœ„ ë¹„êµ)
            calculateImageSimilarity(frame1, frame2) {
                if (!frame1 || !frame2) return 0;

                const data1 = frame1.data;
                const data2 = frame2.data;
                let matchPixels = 0;
                const totalPixels = data1.length / 4;

                for (let i = 0; i < data1.length; i += 4) {
                    const r1 = data1[i];
                    const g1 = data1[i + 1];
                    const b1 = data1[i + 2];
                    const r2 = data2[i];
                    const g2 = data2[i + 1];
                    const b2 = data2[i + 2];

                    const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);

                    // 30 ì´í•˜ ì°¨ì´ë©´ ìœ ì‚¬í•œ í”½ì…€ë¡œ ê°„ì£¼
                    if (diff < 30) {
                        matchPixels++;
                    }
                }

                return matchPixels / totalPixels;
            }

            // ëª¨ë“œ3: 4ì´ˆ ë¬´ìŒ ê°ì§€
            checkMode3Silence() {
                // analyserì™€ dataArrayê°€ ì „ì—­ ë³€ìˆ˜ë¡œ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                if (!window.analyser || !window.dataArray) {
                    return false;
                }

                // í˜„ì¬ ì˜¤ë””ì˜¤ ë ˆë²¨ ê³„ì‚°
                window.analyser.getByteFrequencyData(window.dataArray);
                const average = window.dataArray.reduce((a, b) => a + b, 0) / window.dataArray.length;
                const isSilent = average < silenceThreshold;

                if (isSilent) {
                    // ë¬´ìŒ ì‹œì‘ ì‹œê°„ ê¸°ë¡
                    if (!this.silenceStartTime) {
                        this.silenceStartTime = Date.now();
                        console.log('ğŸ”‡ [ëª¨ë“œ3] ë¬´ìŒ ê°ì§€ ì‹œì‘');
                    } else {
                        const silentDuration = Date.now() - this.silenceStartTime;

                        // 0.5ì´ˆë§ˆë‹¤ ë¡œê·¸ (ë„ˆë¬´ ë§ì€ ë¡œê·¸ ë°©ì§€)
                        if (Math.floor(silentDuration / 500) !== Math.floor((silentDuration - 500) / 500)) {
                            console.log(`ğŸ”‡ [ëª¨ë“œ3] ë¬´ìŒ ì§€ì† ì¤‘... ${formatSeconds(silentDuration / 1000)}ì´ˆ / 4ì´ˆ`);
                        }

                        // 4ì´ˆ ì´ìƒ ë¬´ìŒì´ë©´ ê°ì§€ ì„±ê³µ
                        if (silentDuration >= this.silenceDuration) {
                            console.log(`âœ“ [ëª¨ë“œ3 ì¡°ê±´] 4ì´ˆ ë¬´ìŒ ê°ì§€! (${formatSeconds(silentDuration / 1000)}ì´ˆ)`);
                            this.silenceStartTime = null; // ë¦¬ì…‹
                            return true;
                        }
                    }
                } else {
                    // ì†Œë¦¬ê°€ ë“¤ë¦¬ë©´ ë¬´ìŒ íƒ€ì´ë¨¸ ë¦¬ì…‹
                    if (this.silenceStartTime) {
                        console.log('âŒ [ëª¨ë“œ3] ë¬´ìŒ ì¤‘ë‹¨ (ì†Œë¦¬ ê°ì§€) - íƒ€ì´ë¨¸ ë¦¬ì…‹');
                        this.silenceStartTime = null;
                    }
                }

                return false;
            }

            reset() {
                this.lastFrameData = null;
                this.lastHistogram = null;
                this.lastChangeTime = 0;
                this.consecutiveChanges = 0;
                this.silenceStartTime = null; // ëª¨ë“œ3 ë¬´ìŒ íƒ€ì´ë¨¸ ë¦¬ì…‹
            }

            destroy() {
                this.lastFrameData = null;
                this.canvas = null;
                this.ctx = null;
            }
        }

        // í…œí”Œë¦¿ ë§¤ì¹­ ê°ì§€ ì‹œìŠ¤í…œ
        class TemplateMatcher {
            constructor(videoElement, templateImageData) {
                this.video = videoElement;
                this.template = templateImageData;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.similarityThreshold = 0.90; // 90% ìœ ì‚¬ë„

                // í…œí”Œë¦¿ í¬ê¸°ë¡œ ìº”ë²„ìŠ¤ ì„¤ì •
                this.canvas.width = this.template.width;
                this.canvas.height = this.template.height;
            }

            captureVideoFrame() {
                if (!this.video || this.video.readyState < 2) return null;

                const vw = this.video.videoWidth;
                const vh = this.video.videoHeight;

                if (!vw || !vh) return null;

                // ë¹„ìœ¨ ìœ ì§€í•˜ë©° ìº”ë²„ìŠ¤ì— ë§ì¶¤ (letterbox ì œê±°)
                const scale = Math.min(
                    this.canvas.width / vw,
                    this.canvas.height / vh
                );

                const drawW = vw * scale;
                const drawH = vh * scale;
                const offsetX = (this.canvas.width - drawW) / 2;
                const offsetY = (this.canvas.height - drawH) / 2;

                // ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (ê²€ì€ ë°°ê²½)
                this.ctx.fillStyle = "#000";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ì‹¤ì œ ë¹„ë””ì˜¤ ì½˜í…ì¸ ë§Œ ê·¸ë¦¬ê¸°
                this.ctx.drawImage(this.video, offsetX, offsetY, drawW, drawH);

                return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            }

            calculateSimilarity(frame1, frame2) {
                if (!frame1 || !frame2) return 0;

                const data1 = frame1.data;
                const data2 = frame2.data;
                let matchingPixels = 0;
                const totalPixels = data1.length / 4;

                // í”½ì…€ ë‹¨ìœ„ë¡œ RGB ë¹„êµ
                for (let i = 0; i < data1.length; i += 4) {
                    const r1 = data1[i];
                    const g1 = data1[i + 1];
                    const b1 = data1[i + 2];
                    const r2 = data2[i];
                    const g2 = data2[i + 1];
                    const b2 = data2[i + 2];

                    // RGB ê°ê°ì˜ ì°¨ì´ ê³„ì‚°
                    const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);

                    // ì°¨ì´ê°€ 30 ì´í•˜ë©´ ìœ ì‚¬í•œ í”½ì…€ë¡œ íŒë‹¨
                    if (diff <= 30) {
                        matchingPixels++;
                    }
                }

                return matchingPixels / totalPixels;
            }

            checkMatch() {
                const currentFrame = this.captureVideoFrame();
                if (!currentFrame) return { matched: false, similarity: 0 };

                const similarity = this.calculateSimilarity(this.template, currentFrame);
                const matched = similarity >= this.similarityThreshold;

                return { matched, similarity };
            }

            destroy() {
                this.template = null;
                this.canvas = null;
                this.ctx = null;
            }
        }

        // ë™ì˜ìƒ ì œëª© ê°ì§€ ì‹œìŠ¤í…œ
        class VideoTitleDetector {
            constructor(videoElement, titleRegion = { x: 0, y: 0, width: 1, height: 0.1 }) {
                this.video = videoElement;
                this.titleRegion = titleRegion; // ì œëª© ì˜ì—­ (ë¹„ìœ¨: 0~1)
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.lastTitleHash = null;
                this.changeThreshold = 0.10; // 10% ì´ìƒ ë³€í™” ì‹œ ì œëª© ë³€ê²½ìœ¼ë¡œ íŒë‹¨
                this.lastChangeTime = 0;
                this.cooldownPeriod = 2000; // 2ì´ˆ ì¿¨ë‹¤ìš´ (ì¤‘ë³µ ê°ì§€ ë°©ì§€)

                // ìƒ˜í”Œë§ í•´ìƒë„ (ì œëª© ì˜ì—­ë§Œ)
                this.sampleWidth = 320;
                this.sampleHeight = 60;
                this.canvas.width = this.sampleWidth;
                this.canvas.height = this.sampleHeight;

                console.log('ğŸ“º [VideoTitleDetector] ì´ˆê¸°í™” ì™„ë£Œ - ì œëª© ì˜ì—­:', titleRegion);
            }

            captureTitle() {
                if (!this.video || this.video.readyState < 2) return null;

                const vw = this.video.videoWidth;
                const vh = this.video.videoHeight;

                if (!vw || !vh) return null;

                // ì œëª© ì˜ì—­ ê³„ì‚° (ë¹„ìœ¨ ê¸°ë°˜)
                const regionX = vw * this.titleRegion.x;
                const regionY = vh * this.titleRegion.y;
                const regionW = vw * this.titleRegion.width;
                const regionH = vh * this.titleRegion.height;

                // ìº”ë²„ìŠ¤ ì´ˆê¸°í™”
                this.ctx.fillStyle = "#000";
                this.ctx.fillRect(0, 0, this.sampleWidth, this.sampleHeight);

                // ì œëª© ì˜ì—­ë§Œ ê·¸ë¦¬ê¸°
                this.ctx.drawImage(
                    this.video,
                    regionX, regionY, regionW, regionH,
                    0, 0, this.sampleWidth, this.sampleHeight
                );

                return this.ctx.getImageData(0, 0, this.sampleWidth, this.sampleHeight);
            }

            // ê°„ë‹¨í•œ í•´ì‹œ ê³„ì‚° (í”½ì…€ ë°ì´í„° ê¸°ë°˜)
            calculateHash(imageData) {
                if (!imageData) return null;

                const data = imageData.data;
                let hash = 0;

                // 8x8 ê·¸ë¦¬ë“œë¡œ ìƒ˜í”Œë§í•˜ì—¬ í•´ì‹œ ê³„ì‚°
                const gridSize = 8;
                const stepX = Math.floor(this.sampleWidth / gridSize);
                const stepY = Math.floor(this.sampleHeight / gridSize);

                for (let gy = 0; gy < gridSize; gy++) {
                    for (let gx = 0; gx < gridSize; gx++) {
                        const x = gx * stepX;
                        const y = gy * stepY;
                        const idx = (y * this.sampleWidth + x) * 4;

                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const brightness = (r + g + b) / 3;

                        // ë°ê¸° ê°’ì„ í•´ì‹œì— ë°˜ì˜
                        hash = (hash * 31 + Math.floor(brightness)) & 0xFFFFFFFF;
                    }
                }

                return hash;
            }

            // í”½ì…€ ì°¨ì´ ë¹„ìœ¨ ê³„ì‚°
            calculateDifference(imageData1, imageData2) {
                if (!imageData1 || !imageData2) return 0;

                const data1 = imageData1.data;
                const data2 = imageData2.data;
                let diffCount = 0;
                const totalPixels = data1.length / 4;

                for (let i = 0; i < data1.length; i += 4) {
                    const r1 = data1[i];
                    const g1 = data1[i + 1];
                    const b1 = data1[i + 2];

                    const r2 = data2[i];
                    const g2 = data2[i + 1];
                    const b2 = data2[i + 2];

                    // RGB ì°¨ì´ ê³„ì‚°
                    const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);

                    // ì„ê³„ê°’ ì´ìƒ ì°¨ì´ë‚˜ë©´ ì¹´ìš´íŠ¸
                    if (diff > 30) {
                        diffCount++;
                    }
                }

                return diffCount / totalPixels;
            }

            checkTitleChange() {
                const now = Date.now();

                // ì¿¨ë‹¤ìš´ ì²´í¬
                if (now - this.lastChangeTime < this.cooldownPeriod) {
                    return false;
                }

                const titleFrame = this.captureTitle();
                if (!titleFrame) return false;

                const currentHash = this.calculateHash(titleFrame);

                // ì²˜ìŒ í˜¸ì¶œ ì‹œ ì´ˆê¸°í™”
                if (this.lastTitleHash === null) {
                    this.lastTitleHash = currentHash;
                    this.lastTitleFrame = titleFrame;
                    console.log('ğŸ“º [VideoTitleDetector] ì´ˆê¸° ì œëª© ìº¡ì²˜ ì™„ë£Œ');
                    return false;
                }

                // í•´ì‹œ ë¹„êµ
                if (currentHash !== this.lastTitleHash) {
                    // í”½ì…€ ì°¨ì´ ê³„ì‚°
                    const diffRatio = this.calculateDifference(this.lastTitleFrame, titleFrame);

                    console.log(`ğŸ“º [VideoTitleDetector] ì œëª© ë³€í™” ê°ì§€ - í•´ì‹œ ë³€í™”: ${this.lastTitleHash} â†’ ${currentHash}, í”½ì…€ ì°¨ì´ìœ¨: ${(diffRatio * 100).toFixed(2)}%`);

                    // ë³€í™”ìœ¨ì´ ì„ê³„ê°’ ì´ìƒì´ë©´ ì œëª© ë³€ê²½ìœ¼ë¡œ íŒë‹¨
                    if (diffRatio >= this.changeThreshold) {
                        this.lastTitleHash = currentHash;
                        this.lastTitleFrame = titleFrame;
                        this.lastChangeTime = now;

                        console.log('âœ… [VideoTitleDetector] ì œëª© ë³€ê²½ ê°ì§€! ìë™ ë¶„í•  íŠ¸ë¦¬ê±°');
                        return true;
                    }
                }

                return false;
            }

            setTitleRegion(region) {
                this.titleRegion = region;
                console.log('ğŸ“º [VideoTitleDetector] ì œëª© ì˜ì—­ ì—…ë°ì´íŠ¸:', region);
            }

            reset() {
                this.lastTitleHash = null;
                this.lastTitleFrame = null;
                this.lastChangeTime = 0;
                console.log('ğŸ“º [VideoTitleDetector] ë¦¬ì…‹ ì™„ë£Œ');
            }

            destroy() {
                this.lastTitleFrame = null;
                this.canvas = null;
                this.ctx = null;
                console.log('ğŸ“º [VideoTitleDetector] íŒŒê´´ ì™„ë£Œ');
            }
        }

        function startSceneChangeDetection() {
            console.log(`ğŸ” [DEBUG] startSceneChangeDetection í˜¸ì¶œ - sceneChangeDetectionToggle: ${sceneChangeDetectionToggle.checked}, templateMatchingToggle: ${templateMatchingToggle.checked}, videoElement: ${!!videoElement}, waitingForSilence: ${waitingForSilence}`);

            // í™”ë©´ ë³€í™” ê°ì§€ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì‹œì‘í•˜ì§€ ì•ŠìŒ
            if (!sceneChangeDetectionToggle.checked && !templateMatchingToggle.checked) {
                console.log('âš ï¸ [DEBUG] í™”ë©´ ì „í™˜ ê°ì§€/í…œí”Œë¦¿ ë§¤ì¹­ ë‘˜ ë‹¤ ë¹„í™œì„±í™” â†’ ê°ì§€ ì‹œì‘ ì•ˆ í•¨');
                return;
            }
            if (!videoElement || !waitingForSilence) {
                console.log(`âš ï¸ [DEBUG] videoElement ë˜ëŠ” waitingForSilence ëˆ„ë½ â†’ ê°ì§€ ì‹œì‘ ì•ˆ í•¨ (videoElement: ${!!videoElement}, waitingForSilence: ${waitingForSilence})`);
                return;
            }

            // í™”ë©´ì „í™˜ ê°ì§€ ê¸°ëŠ¥ ì œê±°ë¨ - ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
            /*
            if (!sceneChangeDetector) {
                sceneChangeDetector = new SceneChangeDetector(videoElement);
                // ìŠ¬ë¼ì´ë” ê°’ìœ¼ë¡œ ë¯¼ê°ë„ ì„¤ì •
                sceneChangeDetector.changeThreshold = parseInt(sceneChangeSensitivity.value) / 100;
                // ëª¨ë“œ2 ì°¸ì¡° ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì„¤ì •
                if (mode2ReferenceImage) {
                    sceneChangeDetector.mode2ReferenceImage = mode2ReferenceImage;
                }
            }
            */

            // ë™ì˜ìƒ ì œëª© ê°ì§€ ì´ˆê¸°í™”
            if (!videoTitleDetector && videoTitleDetectionToggle && videoTitleDetectionToggle.checked) {
                // ê¸°ë³¸ ì œëª© ì˜ì—­: ìƒë‹¨ 10% (x: 0, y: 0, width: 1, height: 0.1)
                videoTitleDetector = new VideoTitleDetector(videoElement);
                console.log('ğŸ“º [VideoTitleDetector] ì´ˆê¸°í™” ì™„ë£Œ');
            }

            // í™”ë©´ ë³€í™” ê°ì§€ ì¤‘ì§€ (ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë©´)
            stopSceneChangeDetection();

            // í…œí”Œë¦¿ ë§¤ì¹­ ê¸°ëŠ¥ ì œê±°ë¨ - ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
            // í™”ë©´ì „í™˜ ìë™ê°ì§€ ê¸°ëŠ¥ ì œê±°ë¨ - ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
        }

        function stopSceneChangeDetection() {
            if (sceneChangeCheckInterval) {
                clearInterval(sceneChangeCheckInterval);
                sceneChangeCheckInterval = null;
            }
            detectedSceneChange = false;
            sceneChangeTime = null;
            silenceStartForSplit = null;
            frameBeforeSilence = null;

            // VideoTitleDetector ì •ë¦¬
            if (videoTitleDetector) {
                videoTitleDetector.reset();
            }
        }

        // í…œí”Œë¦¿ ë§¤ì¹­ ì¤‘ì§€ (cleanupìš©)
        function stopTemplateMatching() {
            if (templateCheckInterval) {
                clearInterval(templateCheckInterval);
                templateCheckInterval = null;
            }
        }

        function triggerChapterTransition(reason = 'ì•Œ ìˆ˜ ì—†ìŒ') {
            // ğŸ” ë””ë²„ê¹…: í˜¸ì¶œ ì¶”ì 
            const stackTrace = new Error().stack;
            console.log('ğŸ” [DEBUG] triggerChapterTransition í˜¸ì¶œë¨');
            console.log('ğŸ” [DEBUG] readyToAutoStop:', readyToAutoStop);
            console.log('ğŸ” [DEBUG] chapterReadyToSplit:', chapterReadyToSplit);
            console.log('ğŸ” [DEBUG] pendingSplitChapterIndex:', pendingSplitChapterIndex);
            console.log('ğŸ” [DEBUG] currentChapterIndex:', currentChapterIndex);
            console.log('ğŸ” [DEBUG] ì „í™˜ ê·¼ê±°:', reason);
            console.log('ğŸ” [DEBUG] í˜¸ì¶œ ìŠ¤íƒ:', stackTrace);

            // âœ… í…œí”Œë¦¿ ë§¤ì¹­ í›„ì—ë„ ê³„ì† ê°ì§€í•˜ê¸° ìœ„í•´ stopSceneChangeDetection í˜¸ì¶œ ì•ˆ í•¨
            // ëŒ€ì‹  í™”ë©´ ì „í™˜ ê°ì§€ ê´€ë ¨ ë³€ìˆ˜ë§Œ ë¦¬ì…‹
            detectedSceneChange = false;
            sceneChangeTime = null;
            silenceStartForSplit = null;
            frameBeforeSilence = null;
            silenceWaitStartTime = null;

            if (readyToAutoStop) {
                addLog(`ğŸ” [DEBUG] ë§ˆì§€ë§‰ ì±•í„° ìë™ ì¢…ë£Œ ì‹¤í–‰ (ê·¼ê±°: ${reason})`, 'info');
                updateStatus('ready', 'âœ… ëª¨ë“  ê°•ì˜ ë…¹ìŒ ì™„ë£Œ! (í…œí”Œë¦¿ ë§¤ì¹­ ê°ì§€)');
                stopRecording();
            } else if (chapterReadyToSplit && pendingSplitChapterIndex >= 0) {
                const endedIdx = pendingSplitChapterIndex;
                const endedName = chapters[endedIdx].name;
                currentChapterIndex = endedIdx + 1;

                addLog(`ğŸ”„ ì±•í„° ì „í™˜ ì‹¤í–‰: ${endedIdx} â†’ ${currentChapterIndex} (ê·¼ê±°: ${reason})`, 'success');

                splitRecordingWithName(endedName);
                renderChapters();

                chapterReadyToSplit = false;
                waitingForSilence = false;
                pendingSplitChapterIndex = -1;
                silenceIndicator.textContent = '(ì „í™˜ ì™„ë£Œ!)';
                silenceIndicator.className = 'silence-indicator';

                // ë‹¤ìŒ ì±•í„°ë¥¼ ìœ„í•´ í™”ë©´ ê°ì§€ê¸°ë§Œ ë¦¬ì…‹ (í…œí”Œë¦¿ ë§¤ì²˜ëŠ” ìœ ì§€)
                if (sceneChangeDetector) {
                    sceneChangeDetector.reset();
                }

                // âœ… íƒ€ì´ë¨¸ì™€ startTime ë¦¬ì…‹í•˜ì—¬ ë‹¤ìŒ ë…¹ìŒì˜ 30ì´ˆ ì¹´ìš´íŠ¸ ë‹¤ì‹œ ì‹œì‘
                startTime = Date.now();
                pausedTime = 0;
                forceSplitExecuted = false; // ê°•ì œ ë¶„í•  í”Œë˜ê·¸ ë¦¬ì…‹

                // í™”ë©´ ì „í™˜ ìë™ê°ì§€ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ë‹¤ì‹œ ê°ì§€ ì‹œì‘
                if (sceneChangeDetectionToggle.checked && currentChapterIndex < chapters.length) {
                    console.log('âœ… í™”ë©´ ì „í™˜ ìë™ê°ì§€: ë‹¤ìŒ ì±•í„° ê°ì§€ ì¬ì‹œì‘');
                    chapterReadyToSplit = true;
                    waitingForSilence = true;
                    pendingSplitChapterIndex = currentChapterIndex;
                    silenceIndicator.textContent = '(í™”ë©´ ì „í™˜ìœ¼ë¡œ ìë™ë¶„í•  ëŒ€ê¸° ì¤‘...)';
                    silenceIndicator.className = 'silence-indicator active';
                    startSceneChangeDetection();
                }
            } else {
                addLog('ğŸ” [DEBUG] ì „í™˜ ì¡°ê±´ ë¶ˆë§Œì¡± - ì•„ë¬´ ì‘ì—…ë„ ìˆ˜í–‰í•˜ì§€ ì•ŠìŒ', 'warning');
            }
        }

        // jsPDF ë¼ì´ë¸ŒëŸ¬ë¦¬ ë™ì  ë¡œë“œ
        async function loadJsPdf() {
            if (window.jspdf) return window.jspdf;

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                script.onload = () => resolve(window.jspdf);
                script.onerror = () => reject(new Error('jsPDF ë¡œë“œ ì‹¤íŒ¨'));
                document.head.appendChild(script);
            });
        }

        // ìº¡ì²˜ëœ ì´ë¯¸ì§€ë“¤ì„ PDFë¡œ ì €ì¥
        async function saveImagesAsPdf(images, filename) {
            if (!images || images.length === 0) {
                console.log('ì €ì¥í•  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                const isRecording = mediaRecorder && mediaRecorder.state === 'recording';
                const statusMsg = `ğŸ“„ PDF ìƒì„± ì¤‘... (${images.length}ì¥)`;

                if (isRecording) {
                    captureStatus.textContent = statusMsg;
                } else {
                    updateStatus('ready', statusMsg);
                }

                // jsPDF ë¡œë“œ
                const jsPdfLib = await loadJsPdf();
                const { jsPDF } = jsPdfLib;

                // 1280x720 ê°€ë¡œ ë°©í–¥ PDF ìƒì„± (px to mm ë³€í™˜: 1px â‰ˆ 0.264583mm)
                const pdfWidth = 1280 * 0.264583;  // mm
                const pdfHeight = 720 * 0.264583;  // mm

                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: [pdfWidth, pdfHeight]
                });

                for (let i = 0; i < images.length; i++) {
                    const imageData = images[i];

                    // WebP â†’ JPEG ë³€í™˜ (jsPDFëŠ” WebP ë¯¸ì§€ì›)
                    const jpegData = await convertWebPToJpeg(imageData);

                    if (i > 0) {
                        pdf.addPage([pdfWidth, pdfHeight], 'landscape');
                    }

                    // ì´ë¯¸ì§€ë¥¼ í˜ì´ì§€ì— ê½‰ ì°¨ê²Œ ì¶”ê°€
                    pdf.addImage(jpegData, 'JPEG', 0, 0, pdfWidth, pdfHeight);

                    // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
                    if (i % 10 === 0 || i === images.length - 1) {
                        const progressMsg = `ğŸ“„ PDF ìƒì„± ì¤‘... (${i + 1}/${images.length})`;
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            captureStatus.textContent = progressMsg;
                        } else {
                            updateStatus('ready', progressMsg);
                        }
                    }
                }

                // PDF ì €ì¥
                const pdfFilename = `${filename}.pdf`;
                pdf.save(pdfFilename);

                const finalMsg = `âœ… PDF ì €ì¥ ì™„ë£Œ: ${pdfFilename} (${images.length}í˜ì´ì§€)`;
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    captureStatus.textContent = finalMsg;
                    // 5ì´ˆ í›„ì— ì›ë˜ì˜ ìº¡ì²˜ ìƒíƒœ(ğŸ“¸ Nì¥)ë¡œ ë³µêµ¬í•˜ê±°ë‚˜ ë¹„ìš°ê¸°
                    setTimeout(() => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            updateCaptureStatus();
                        } else {
                            captureStatus.textContent = '';
                        }
                    }, 5000);
                } else {
                    updateStatus('ready', finalMsg);
                }
                console.log(`PDF ì €ì¥ ì™„ë£Œ: ${pdfFilename}`);

                // ë¡œê·¸ ì¶”ê°€
                addLog(`ğŸ“„ PDF ìƒì„± ì™„ë£Œ: "${filename}.pdf" (${images.length}í˜ì´ì§€)`, 'success');

            } catch (error) {
                console.error('PDF ìƒì„± ì˜¤ë¥˜:', error);
                updateStatus('error', `âŒ PDF ìƒì„± ì‹¤íŒ¨: ${error.message}`);
                addLog(`âŒ PDF ìƒì„± ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }

        // WebP â†’ JPEG ë³€í™˜ í•¨ìˆ˜
        function convertWebPToJpeg(webpDataUrl) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');

                    // í°ìƒ‰ ë°°ê²½ (JPEGëŠ” íˆ¬ëª…ë„ ë¯¸ì§€ì›)
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);

                    resolve(canvas.toDataURL('image/jpeg', 0.92));
                };
                img.onerror = () => reject(new Error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨'));
                img.src = webpDataUrl;
            });
        }

        function pauseRecording() {
            // ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.pause();
                isPaused = true;
                pausedTime += Date.now() - startTime;
                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <polygon points="5,3 19,12 5,21"/>
                    </svg>
                `;
                pauseBtn.title = 'ê³„ì†';
                updateStatus('paused', 'â¸ï¸ ì¼ì‹œì •ì§€ë¨');
            } else if (mediaRecorder && mediaRecorder.state === 'paused') {
                mediaRecorder.resume();
                isPaused = false;
                startTime = Date.now();
                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                `;
                pauseBtn.title = 'ì¼ì‹œì •ì§€';
                updateStatus('recording', 'ğŸ”´ ë…¹ìŒ ì¤‘...');
            }
        }

        function stopRecording() {
            try {
                isRecording = false; // ì •ì§€ ìƒíƒœë¡œ ë³€ê²½
                isWaitingForFirstSound = false; // ìµœì´ˆ ëŒ€ê¸° ìƒíƒœ í•´ì œ
                clearInterval(timerInterval);
                clearChapterTimers();

                // âœ… mediaRecorder.onstopì´ ì‹¤í–‰ë˜ê¸° ì „ì— í˜„ì¬ ì±•í„° ì´ë¦„ì„ ì €ì¥
                const finalChapterName = activeChapterName ||
                    (chapters[currentChapterIndex]?.name) ||
                    `ê°•ì˜${lectureCount}`;

                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    // ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚° ë° ë¡œê·¸
                    const actualDuration = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
                    const actualMin = Math.floor(actualDuration / 60);
                    const actualSec = Math.floor(actualDuration % 60);
                    const actualTimeStr = `${actualMin}ë¶„ ${actualSec}ì´ˆ`;

                    // ì˜ˆìƒ ì‹œê°„ê³¼ ë¹„êµ
                    const matchedChapter = chapters.find(ch => ch.name === finalChapterName);
                    if (matchedChapter && matchedChapter.duration && recordingStartTime) {
                        const expectedDuration = matchedChapter.duration;
                        const diff = actualDuration - expectedDuration;
                        const diffAbs = Math.abs(diff);
                        const diffMin = Math.floor(diffAbs / 60);
                        const diffSec = Math.floor(diffAbs % 60);
                        const diffStr = `${diffMin}ë¶„ ${diffSec}ì´ˆ`;

                        const expectedMin = Math.floor(expectedDuration / 60);
                        const expectedSec = Math.floor(expectedDuration % 60);
                        const expectedTimeStr = `${expectedMin}ë¶„ ${expectedSec}ì´ˆ`;

                        // ğŸ”§ ë§ˆì§€ë§‰ ì±•í„° ì˜¤ì°¨ ê¸°ë¡ (ë³´ì • ì—†ìŒ)
                        console.log(`ğŸ“Š [ì‹œê°„ ë³´ì •] ë§ˆì§€ë§‰ ì±•í„° ì˜¤ì°¨: ${diff > 0 ? '+' : ''}${diff.toFixed(1)}ì´ˆ`);

                        if (Math.abs(diff) < 5) {
                            addLog(`â¹ï¸ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ: "${finalChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (ì •í™•!)`, 'success');
                        } else if (diff > 0) {
                            addLog(`â¹ï¸ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ: "${finalChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (+${diffStr} ì´ˆê³¼)`, 'warning');
                        } else {
                            addLog(`â¹ï¸ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ: "${finalChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (-${diffStr} ë¶€ì¡±)`, 'warning');
                        }
                    } else {
                        addLog(`â¹ï¸ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ: "${finalChapterName}" | ì‹¤ì œ: ${actualTimeStr}`, 'info');
                        // ì±•í„° ì •ë³´ê°€ ì—†ìŒ
                    }

                    // âœ… ì €ì¥ëœ ì±•í„° ì´ë¦„ìœ¼ë¡œ ë…¹ìŒ ì €ì¥
                    stopCapture();
                    const imagesToSave = [...capturedImages];
                    capturedImages = [];
                    captureCount = 0;

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                        saveRecordingWithNameAndImages(audioBlob, currentRecordingType, finalChapterName, imagesToSave);
                        audioChunks = [];
                    };

                    mediaRecorder.stop();
                }

                // UI ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                recordBtn.classList.remove('recording');
                recordBtn.disabled = false;
                pauseBtn.disabled = true;
                stopBtn.disabled = true;
                newLectureBtn.disabled = true;
                includeSystemAudio.disabled = false;
                includeMic.disabled = false;
                silenceIndicator.textContent = '';
                remainingTimeIndicator.textContent = '';
                silenceStart = null;
                currentChapterIndex = 0;
                activeChapterName = '';
                renderChapters();

                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                `;
                pauseBtn.title = 'ì¼ì‹œì •ì§€';
                timerDisplay.textContent = '00:00:00';
                progressSection.style.display = 'none'; // ì •ì§€ ì‹œ ìˆ¨ê¹€
                progressBar.style.width = '0%';

                // ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼ ì¤‘ë‹¨)
                cleanup();

                updateStatus('ready', 'âœ… ë…¹ìŒ ì™„ë£Œ! ìƒˆ ë…¹ìŒì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            } catch (err) {
                console.error('ë…¹ìŒ ì •ì§€ ì¤‘ ì˜¤ë¥˜:', err);
                updateStatus('error', 'âŒ ë…¹ìŒ ì •ì§€ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + err.message);
                cleanup(); // ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë”ë¼ë„ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œë„
            }
        }

        function saveRecording(blob, type) {
            const now = new Date();
            const name = `ê°•ì˜${lectureCount}_${now.toLocaleDateString('ko-KR')}_${now.toLocaleTimeString('ko-KR').replace(/:/g, '-')}`;
            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type
            };

            recordings.unshift(recording);
            renderRecordings();

            if (capturedImages.length > 0) {
                saveImagesAsPdf([...capturedImages], name);
                capturedImages = [];
                captureCount = 0;
                updateCaptureStatus();
            }
        }

        function getTypeBadge(type) {
            // ê·¸ëŒ€ë¡œ
            switch (type) {
                case 'system':
                    return '<span class="recording-badge badge-system">ğŸ”Š ì‹œìŠ¤í…œ</span>';
                case 'mic':
                    return '<span class="recording-badge badge-mic">ğŸ¤ ë§ˆì´í¬</span>';
                case 'both':
                    return '<span class="recording-badge badge-both">ğŸ§ ì‹œìŠ¤í…œ+ë§ˆì´í¬</span>';
                default:
                    return '';
            }
        }

        function renderRecordings() {
            if (recordings.length === 0) {
                recordingsList.innerHTML = '<div class="empty-state">ë…¹ìŒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>';
                downloadAllBtn.disabled = true;
                return;
            }

            downloadAllBtn.disabled = false;

            recordingsList.innerHTML = recordings.map(rec => {
                const durationText = rec.duration ? ` â€¢ ì¬ìƒì‹œê°„: ${rec.duration}` : '';
                return `
                <div class="recording-item" data-id="${rec.id}">
                    <div class="recording-header">
                        <div class="recording-info">
                            <div class="recording-name">${rec.name}</div>
                            <div class="recording-meta">${rec.date} ${getTypeBadge(rec.type)}${durationText}</div>
                        </div>
                        <div class="recording-actions">
                            <button class="btn-small btn-download" onclick="downloadRecording(${rec.id})" title="ë‹¤ìš´ë¡œë“œ">
                                <svg viewBox="0 0 24 24">
                                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                                </svg>
                            </button>
                            <button class="btn-small btn-delete" onclick="deleteRecording(${rec.id})" title="ì‚­ì œ">
                                <svg viewBox="0 0 24 24">
                                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <audio controls src="${rec.url}" onloadedmetadata="updateRecordingDuration(${rec.id}, this)"></audio>
                </div>
                `;
            }).join('');
        }

        // ì˜¤ë””ì˜¤ ë©”íƒ€ë°ì´í„° ë¡œë“œ í›„ ì¬ìƒì‹œê°„ ì—…ë°ì´íŠ¸
        function updateRecordingDuration(id, audioElement) {
            const recording = recordings.find(r => r.id === id);
            if (recording && audioElement.duration && !isNaN(audioElement.duration) && isFinite(audioElement.duration)) {
                const actualDuration = Math.floor(audioElement.duration); // ì‹¤ì œ ì¬ìƒì‹œê°„ (ì´ˆ)

                // ë‚´ë¶€ì ìœ¼ë¡œë§Œ ì €ì¥ (UIì—ëŠ” í‘œì‹œí•˜ì§€ ì•ŠìŒ)
                recording.actualDuration = actualDuration;

                // UIì—ëŠ” ì‹œê°„ ì •ë³´ë¥¼ í‘œì‹œí•˜ì§€ ì•ŠìŒ (ë¡œê·¸ì—ë§Œ í‘œì‹œë¨)
            }
        }

        // (downloadAll / downloadRecording / deleteRecording / splitRecording í•¨ìˆ˜ëŠ” ê¸°ì¡´ê³¼ ë™ì¼)

        recordBtn.addEventListener('click', startRecording);
        pauseBtn.addEventListener('click', pauseRecording);
        stopBtn.addEventListener('click', stopRecording);
        newLectureBtn.addEventListener('click', () => splitRecording());

        // âœ… ì±•í„°ëª… ê¸°ë°˜ ë¶„í•  ì €ì¥
        function splitRecordingWithName(chapterName) {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                const endedChapterName =
                    chapterName ||
                    activeChapterName ||
                    (chapters[currentChapterIndex]?.name) ||
                    `ê°•ì˜${lectureCount}`;

                // ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚°
                const actualDuration = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0; // ì´ˆ ë‹¨ìœ„
                const actualMin = Math.floor(actualDuration / 60);
                const actualSec = Math.floor(actualDuration % 60);
                const actualTimeStr = `${actualMin}ë¶„ ${actualSec}ì´ˆ`;

                // ì˜ˆìƒ ì‹œê°„ê³¼ ë¹„êµ
                const matchedChapter = chapters.find(ch => ch.name === endedChapterName);
                if (matchedChapter && matchedChapter.duration && recordingStartTime) {
                    const expectedDuration = matchedChapter.duration; // ì´ˆ
                    const diff = actualDuration - expectedDuration;
                    const diffAbs = Math.abs(diff);
                    const diffMin = Math.floor(diffAbs / 60);
                    const diffSec = Math.floor(diffAbs % 60);
                    const diffStr = `${diffMin}ë¶„ ${diffSec}ì´ˆ`;

                    const expectedMin = Math.floor(expectedDuration / 60);
                    const expectedSec = Math.floor(expectedDuration % 60);
                    const expectedTimeStr = `${expectedMin}ë¶„ ${expectedSec}ì´ˆ`;

                    // ğŸ”§ ì±•í„° ì‹œê°„ ì˜¤ì°¨ ê¸°ë¡ (ë³´ì • ì—†ìŒ)
                    console.log(`ğŸ“Š [ì‹œê°„ ë³´ì •] í˜„ì¬ ì±•í„° ì˜¤ì°¨: ${diff > 0 ? '+' : ''}${diff.toFixed(1)}ì´ˆ â†’ ë‹¤ìŒ ì±•í„°ì— ë°˜ì˜ ì˜ˆì •`);

                    if (Math.abs(diff) < 5) {
                        // ì˜¤ì°¨ 5ì´ˆ ì´ë‚´ëŠ” ì •í™•
                        addLog(`â¹ï¸ ë…¹ìŒ ì¢…ë£Œ: "${endedChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (ì •í™•!)`, 'success');
                    } else if (diff > 0) {
                        // ì´ˆê³¼
                        addLog(`â¹ï¸ ë…¹ìŒ ì¢…ë£Œ: "${endedChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (+${diffStr} ì´ˆê³¼)`, 'warning');
                    } else {
                        // ë¶€ì¡±
                        addLog(`â¹ï¸ ë…¹ìŒ ì¢…ë£Œ: "${endedChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (-${diffStr} ë¶€ì¡±)`, 'warning');
                    }
                } else {
                    addLog(`â¹ï¸ ë…¹ìŒ ì¢…ë£Œ: "${endedChapterName}" | ì‹¤ì œ: ${actualTimeStr}`, 'info');
                    // ì±•í„° ì •ë³´ê°€ ì—†ìŒ
                }

                stopCapture();
                const imagesToSave = [...capturedImages];
                capturedImages = [];
                captureCount = 0;

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                    saveRecordingWithNameAndImages(audioBlob, currentRecordingType, endedChapterName, imagesToSave);
                    audioChunks = [];
                };

                mediaRecorder.stop();

                // âœ… ì¦‰ì‹œ ë‹¤ìŒ ë…¹ìŒ ì‹œì‘ (ë”œë ˆì´ ì œê±°)
                // ì •ì§€ ë²„íŠ¼ì´ ëˆŒë ¸ë‹¤ë©´ ìƒˆë¡œìš´ ë…¹ìŒì„ ì‹œì‘í•˜ì§€ ì•ŠìŒ
                if (!isRecording && !isWaitingForFirstSound) return;

                if (streams.length > 0 && streams.some(s => s.active)) {
                    let finalStream;
                    if (streams.length > 1) {
                        finalStream = mergeAudioStreams(streams);
                    } else {
                        finalStream = streams[0];
                    }

                    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                        ? 'audio/webm;codecs=opus'
                        : 'audio/webm';

                    mediaRecorder = new MediaRecorder(finalStream, { mimeType });

                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                        const finalName =
                            activeChapterName ||
                            (chapters[currentChapterIndex]?.name) ||
                            `ê°•ì˜${lectureCount}`;
                        saveRecordingWithName(audioBlob, currentRecordingType, finalName);
                        audioChunks = [];
                    };

                    // âœ… ë¶„í•  ì‹œì—ë„ ì†Œë¦¬ ê°ì§€ ì²´í¬
                    if (autoStartOnSound.checked) {
                        isWaitingForFirstSound = true;
                        isRecording = false; // ì‹¤ì œ ë…¹ìŒ ì „ê¹Œì§€ëŠ” false
                        const nextName = chapters[currentChapterIndex]?.shortName || chapters[currentChapterIndex]?.name || `ê°•ì˜ ${lectureCount}`;
                        updateStatus('recording', `ğŸµ ì†Œë¦¬ ëŒ€ê¸° ì¤‘... (${nextName})`);
                        // actuallyStartRecording()ì´ ë£¨í”„ì—ì„œ í˜¸ì¶œë  ê²ƒì„
                    } else {
                        // âœ… ë¶„í•  í›„ì—ëŠ” ë°”ë¡œ ì‹œì‘ (ë”œë ˆì´ ì—†ìŒ)
                        actuallyStartRecording();
                    }

                    // ê°•ì œ ë¶„í•  í”Œë˜ê·¸ ë¦¬ì…‹
                    forceSplitExecuted = false;
                }
            }
        }

        // ì¤‘ë³µë˜ì§€ ì•ŠëŠ” ê³ ìœ í•œ ë…¹ìŒ íŒŒì¼ëª… ìƒì„±
        function getUniqueRecordingName(name) {
            // ê¸°ì¡´ ë…¹ìŒ íŒŒì¼ëª… ëª©ë¡
            const existingNames = recordings.map(r => r.name);

            // ì¤‘ë³µì´ ì—†ìœ¼ë©´ ì›ë˜ ì´ë¦„ ë°˜í™˜
            if (!existingNames.includes(name)) {
                return name;
            }

            // ì¤‘ë³µì´ ìˆëŠ” ê²½ìš°: ëª¨ë“  ì±•í„°ê°€ ëë‚¬ëŠ”ë° ì¶”ê°€ ë…¹ìŒì´ ì§„í–‰ëœ ê²½ìš°ì—ë§Œ "ë…¹ìŒ1", "ë…¹ìŒ2" í˜•ì‹ìœ¼ë¡œ ë³€ê²½
            // ì •ìƒì ì¸ ì±•í„° ë…¹ìŒ ì¤‘ì´ë¼ë©´ ì¤‘ë³µì´ ë°œìƒí•˜ì§€ ì•Šì•„ì•¼ í•¨
            let counter = 1;
            let uniqueName = `ë…¹ìŒ${counter}`;
            while (existingNames.includes(uniqueName)) {
                counter++;
                uniqueName = `ë…¹ìŒ${counter}`;
            }

            console.log(`âš ï¸ [íŒŒì¼ëª… ì¤‘ë³µ] "${name}" â†’ "${uniqueName}"ë¡œ ë³€ê²½`);
            addLog(`âš ï¸ [íŒŒì¼ëª… ì¤‘ë³µ] "${name}" â†’ "${uniqueName}"ë¡œ ë³€ê²½`, 'warning');
            return uniqueName;
        }

        function saveRecordingWithNameAndImages(blob, type, name, images) {
            const now = new Date();

            // ì¤‘ë³µ ë°©ì§€: ê³ ìœ í•œ íŒŒì¼ëª… ìƒì„±
            const uniqueName = getUniqueRecordingName(name);

            // í•´ë‹¹ ì±•í„°ì˜ ì˜ˆìƒ ì¬ìƒì‹œê°„ ì°¾ê¸°
            let expectedDuration = null;
            const matchedChapter = chapters.find(ch => ch.name === name);
            if (matchedChapter && matchedChapter.duration) {
                expectedDuration = matchedChapter.duration; // seconds
            }

            const recording = {
                id: Date.now(),
                blob: blob,
                name: uniqueName,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type,
                expectedDuration: expectedDuration
            };

            recordings.unshift(recording);
            renderRecordings();

            // ë¡œê·¸ ì¶”ê°€
            const fileSizeMB = (blob.size / (1024 * 1024)).toFixed(2);
            if (uniqueName !== name) {
                addLog(`ğŸ’¾ ë…¹ìŒ ì €ì¥ ì™„ë£Œ: "${uniqueName}" (ì¤‘ë³µ ë°©ì§€) (${fileSizeMB}MB)`, 'success');
            } else {
                addLog(`ğŸ’¾ ë…¹ìŒ ì €ì¥ ì™„ë£Œ: "${uniqueName}" (${fileSizeMB}MB)`, 'success');
            }

            if (images && images.length > 0) {
                addLog(`ğŸ“¸ ìº¡ì²˜ ì´ë¯¸ì§€ ${images.length}ê°œ â†’ PDF ë³€í™˜ ì‹œì‘`, 'info');
                saveImagesAsPdf(images, uniqueName);
            }
        }

        function saveRecordingWithName(blob, type, name) {
            const now = new Date();

            // ì¤‘ë³µ ë°©ì§€: ê³ ìœ í•œ íŒŒì¼ëª… ìƒì„±
            const uniqueName = getUniqueRecordingName(name);

            // í•´ë‹¹ ì±•í„°ì˜ ì˜ˆìƒ ì¬ìƒì‹œê°„ ì°¾ê¸°
            let expectedDuration = null;
            const matchedChapter = chapters.find(ch => ch.name === name);
            if (matchedChapter && matchedChapter.duration) {
                expectedDuration = matchedChapter.duration; // seconds
            }

            const recording = {
                id: Date.now(),
                blob: blob,
                name: uniqueName,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type,
                expectedDuration: expectedDuration
            };

            recordings.unshift(recording);
            renderRecordings();

            if (capturedImages.length > 0) {
                saveImagesAsPdf([...capturedImages], uniqueName);
                capturedImages = [];
                captureCount = 0;
                updateCaptureStatus();
            }
        }

        // ëª©ì°¨ íŒŒì‹± í•¨ìˆ˜
        function parseCurriculum(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            const chapters = [];

            let currentLectureNum = '';
            let currentPart = '';
            let currentChapter = '';
            let lastTitleLine = '';

            for (const line of lines) {
                // 1. ê°•ì˜ ë²ˆí˜¸ (ìˆ«ìë§Œ ìˆëŠ” ì¤„, 1-3ìë¦¬ - ì˜ˆ: 24)
                if (/^\d{1,3}$/.test(line)) {
                    currentLectureNum = line;
                    // ë²ˆí˜¸ë§Œ ìˆëŠ” ì¤„ì€ ì œëª© í›„ë³´ë¡œ ì“°ì§€ ì•ŠìŒ
                    continue;
                }

                // 2. Part ì¸ì‹ (Part 1. ..., Part 1)
                const partMatch = line.match(/^Part\s*(\d+)[.\s-]*(.*)/i);
                if (partMatch) {
                    currentPart = `Part ${partMatch[1]}`;
                    const remaining = partMatch[2].trim();
                    if (remaining) {
                        lastTitleLine = remaining;
                    }
                    continue; // âœ… ë©”íƒ€ë°ì´í„° ì²˜ë¦¬ í›„ ë‹¤ìŒ ì¤„ë¡œ (ì¤‘ë³µ ë°©ì§€)
                }

                // 3. Chapter ì¸ì‹ (Ch 3. ..., Chapter 3. ...)
                const chapterMatch = line.match(/^(?:Ch|Chapter)\s*(\d+)[.\s-]*(.*)/i);
                if (chapterMatch) {
                    currentChapter = `Ch ${chapterMatch[1]}`;
                    const remaining = chapterMatch[2].trim();
                    if (remaining) {
                        lastTitleLine = remaining;
                    }
                    continue; // âœ… ë©”íƒ€ë°ì´í„° ì²˜ë¦¬ í›„ ë‹¤ìŒ ì¤„ë¡œ (ì¤‘ë³µ ë°©ì§€)
                }

                // 4. ì‹œê°„ì´ í¬í•¨ëœ ì¤„ì¸ì§€ í™•ì¸ (MM:SS)
                const timeMatch = line.match(/(\d+):(\d+)/);
                if (timeMatch) {
                    const minutes = parseInt(timeMatch[1]);
                    const seconds = parseInt(timeMatch[2]);
                    const totalSeconds = minutes * 60 + seconds;

                    // í˜„ì¬ ì¤„ì—ì„œ ì‹œê°„ ë¶€ë¶„ì„ ì œì™¸í•œ ê²ƒì´ ì œëª©ì¸ì§€ í™•ì¸
                    let titleInLine = line.replace(/(\d+):(\d+)/, '').replace(/^[.\s-]+/, '').trim();

                    // ì œëª© ê²°ì •: í˜„ì¬ ì¤„ì— ì œëª©ì´ ì—†ìœ¼ë©´ ì´ì „ ì¤„(lastTitleLine) ì‚¬ìš©
                    let finalTitle = titleInLine || lastTitleLine;

                    if (finalTitle) {
                        let nameParts = [];
                        if (currentLectureNum) nameParts.push(currentLectureNum);
                        if (currentPart) nameParts.push(currentPart);
                        if (currentChapter) nameParts.push(currentChapter);
                        nameParts.push(finalTitle);

                        const fullName = nameParts.join(' - ');

                        chapters.push({
                            name: fullName,
                            shortName: finalTitle,
                            originalDuration: totalSeconds,
                            duration: totalSeconds
                        });

                        // ì‚¬ìš©í•œ ì œëª©ì€ ë¹„ì›Œì¤Œ (ë‹¤ìŒ ì±•í„° ì˜¤ì¸ ë°©ì§€)
                        lastTitleLine = '';
                    }
                    continue;
                }

                // 5. ê¸°íƒ€ ì¼ë°˜ í…ìŠ¤íŠ¸ (ì œëª© í›„ë³´)
                // ì§„í–‰ë¥  í‘œì‹œ(0/4)ë‚˜ ë‚ ì§œ ë“± ë¶ˆí•„ìš” íŒ¨í„´ ì œì™¸
                if (/^\d+\/\d+$/.test(line)) continue;
                if (/^\d{2}:\d{2}$/.test(line)) continue; // ì‹œê°„ë§Œ ìˆëŠ” ì¤„ì€ ìœ„ 4ë²ˆì—ì„œ ì²˜ë¦¬ë¨

                // ë¶ˆí•„ìš”í•œ ì¥ì‹ ì œê±°í•˜ê³  ì œëª© í›„ë³´ë¡œ ì €ì¥
                lastTitleLine = line.replace(/^[.\s-]+/, '').trim();
            }

            return chapters;
        }

        // ì±•í„° ë Œë”ë§
        function renderChapters() {
            if (chapters.length === 0) {
                chapterList.innerHTML = '';
                chapterProgress.innerHTML = '';
                return;
            }

            const speed = parseFloat(playbackSpeed.value);

            let totalOriginal = 0;
            let totalAdjusted = 0;

            chapterList.innerHTML = chapters.map((ch, i) => {
                const adjustedDuration = Math.ceil(ch.originalDuration / speed);
                ch.duration = adjustedDuration;
                totalOriginal += ch.originalDuration;
                totalAdjusted += adjustedDuration;

                const isActive = i === currentChapterIndex;
                const isDone = i < currentChapterIndex;

                const originalTime = formatTime(ch.originalDuration * 1000);
                const adjustedTime = formatTime(adjustedDuration * 1000);

                return `
                    <div class="chapter-item ${isActive ? 'active' : ''} ${isDone ? 'done' : ''}">
                        <span class="chapter-number">${i + 1}</span>
                        <span class="chapter-name">${ch.name}</span>
                        <span class="chapter-time">${originalTime} â†’ ${adjustedTime}</span>
                    </div>
                `;
            }).join('');

            chapterProgress.innerHTML = `
                <div>ì´ ${chapters.length}ê°œ ì±•í„°</div>
                <div>ì›ë³¸: ${formatTime(totalOriginal * 1000)} â†’ ì¡°ì •: ${formatTime(totalAdjusted * 1000)}</div>
            `;
        }

        // ì±•í„° íƒ€ì´ë¨¸ ì‹œì‘
        function startChapterTimers(startIndex = 0) {
            clearChapterTimers();
            activeChapterName = chapters[startIndex]?.name || '';

            // ì œëª© ê°ì§€ ìë™ ë¶„í•  ëª¨ë“œ - ë³„ë„ íƒ€ì´ë¨¸ ë¶ˆí•„ìš”
            if (titleDetectionEnabled) {
                console.log('âœ… ì œëª© ê°ì§€ ìë™ ë¶„í•  ëª¨ë“œ í™œì„±í™”ë¨ - íƒ€ì´ë¨¸ ë¶ˆí•„ìš”');
                return;
            }

            // í…œí”Œë¦¿ ë§¤ì¹­ ë° í™”ë©´ ì „í™˜ ìë™ê°ì§€ ê¸°ëŠ¥ì€ ì œê±°ë¨
            console.log('â„¹ï¸ ìë™ ë¶„í•  ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë¨ - ìˆ˜ë™ ë¶„í• ë§Œ ê°€ëŠ¥');
        }

        // ì±•í„° íƒ€ì´ë¨¸ í´ë¦¬ì–´
        function clearChapterTimers() {
            chapterTimers.forEach(t => clearTimeout(t));
            chapterTimers = [];
            chapterReadyToSplit = false;
            waitingForSilence = false;
            pendingSplitChapterIndex = -1;
            readyToAutoStop = false;
            silenceStartForSplit = null;
            silenceWaitStartTime = null;

            // í™”ë©´ ë³€í™” ê°ì§€ ì¤‘ì§€
            stopSceneChangeDetection();
        }

        // ìˆ˜ë™ ë¶„í•  (ìƒˆ ê°•ì˜ ë²„íŠ¼)
        function splitRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                // âœ… ì±•í„° ëª¨ë“œì¼ ë•ŒëŠ” triggerChapterTransition í˜¸ì¶œ
                if (chapters.length > 0 && currentChapterIndex < chapters.length) {
                    console.log('ğŸ” [ë¬´ìŒ ê°ì§€ ìë™ë¶„í• ] ì±•í„° ëª¨ë“œ ê°ì§€ â†’ triggerChapterTransition í˜¸ì¶œ');

                    // ì±•í„° ì „í™˜ì„ ìœ„í•œ í”Œë˜ê·¸ ì„¤ì •
                    chapterReadyToSplit = true;
                    pendingSplitChapterIndex = currentChapterIndex;

                    triggerChapterTransition('ë¬´ìŒ ê°ì§€ ìë™ë¶„í• ');
                    return;
                }

                // âœ… ì¼ë°˜ ëª¨ë“œ (ì±•í„° ì—†ìŒ)
                const currentName = activeChapterName || `ê°•ì˜${lectureCount}`;
                lectureCount++;

                // ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚° ë° ë¡œê·¸
                const actualDuration = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
                const actualMin = Math.floor(actualDuration / 60);
                const actualSec = Math.floor(actualDuration % 60);
                const actualTimeStr = `${actualMin}ë¶„ ${actualSec}ì´ˆ`;
                addLog(`â¹ï¸ ìˆ˜ë™ ë¶„í• : "${currentName}" | ì‹¤ì œ: ${actualTimeStr}`, 'info');

                stopCapture();
                const imagesToSave = [...capturedImages];
                capturedImages = [];
                captureCount = 0;

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                    saveRecordingWithNameAndImages(audioBlob, currentRecordingType, currentName, imagesToSave);
                    audioChunks = [];
                };

                mediaRecorder.stop();

                setTimeout(() => {
                    // ì •ì§€ ë²„íŠ¼ì´ ëˆŒë ¸ë‹¤ë©´ ìƒˆë¡œìš´ ë…¹ìŒì„ ì‹œì‘í•˜ì§€ ì•ŠìŒ
                    if (!isRecording && !isWaitingForFirstSound) return;

                    if (streams.length > 0 && streams.some(s => s.active)) {
                        let finalStream;
                        if (streams.length > 1) {
                            finalStream = mergeAudioStreams(streams);
                        } else {
                            finalStream = streams[0];
                        }

                        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                            ? 'audio/webm;codecs=opus'
                            : 'audio/webm';

                        mediaRecorder = new MediaRecorder(finalStream, { mimeType });

                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: mimeType });
                            const finalName = activeChapterName || `ê°•ì˜${lectureCount}`;
                            saveRecordingWithName(audioBlob, currentRecordingType, finalName);
                            audioChunks = [];
                        };

                        // âœ… ë¶„í•  ì‹œì—ë„ ì†Œë¦¬ ê°ì§€ ì²´í¬
                        if (autoStartOnSound.checked) {
                            isWaitingForFirstSound = true;
                            isRecording = false;
                            activeChapterName = `ê°•ì˜${lectureCount}`;
                            updateStatus('recording', `ğŸµ ì†Œë¦¬ ëŒ€ê¸° ì¤‘... (ê°•ì˜ ${lectureCount})`);
                        } else {
                            actuallyStartRecording();
                        }
                    }
                }, 100);
            }
        }

        // ë…¹ìŒ ë‹¤ìš´ë¡œë“œ
        function downloadRecording(id) {
            const recording = recordings.find(r => r.id === id);
            if (recording) {
                const ext = currentMimeType.includes('ogg') ? 'ogg' : 'webm';
                const a = document.createElement('a');
                a.href = recording.url;
                a.download = `${recording.name}.${ext}`;
                a.click();
            }
        }

        // ë…¹ìŒ ì‚­ì œ
        function deleteRecording(id) {
            const index = recordings.findIndex(r => r.id === id);
            if (index > -1) {
                URL.revokeObjectURL(recordings[index].url);
                recordings.splice(index, 1);
                renderRecordings();
            }
        }

        // ì „ì²´ ë‹¤ìš´ë¡œë“œ
        async function downloadAll() {
            const ext = currentMimeType.includes('ogg') ? 'ogg' : 'webm';
            for (const recording of recordings) {
                const a = document.createElement('a');
                a.href = recording.url;
                a.download = `${recording.name}.${ext}`;
                a.click();
                await new Promise(r => setTimeout(r, 500));
            }
        }

        downloadAllBtn.addEventListener('click', downloadAll);

        // ë§ˆì§€ë§‰ ë¶€ë¶„ ì˜ˆì‹œ
        if (parseBtn) {
            parseBtn.addEventListener('click', () => {
                console.log('ëª©ì°¨ ë¶„ì„ ë²„íŠ¼ í´ë¦­ë¨');
                const text = curriculumInput.value;
                console.log('ì…ë ¥ëœ í…ìŠ¤íŠ¸:', text);
                chapters = parseCurriculum(text);
                console.log('íŒŒì‹±ëœ ì±•í„°:', chapters);
                currentChapterIndex = 0;
                activeChapterName = chapters[0]?.name || '';
                renderChapters();

                if (chapters.length > 0) {
                    updateStatus('ready', `âœ… ${chapters.length}ê°œ ì±•í„° ì¸ì‹ë¨`);
                } else {
                    updateStatus('ready', 'âš ï¸ ì±•í„°ë¥¼ ì¸ì‹í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì‹œê°„(MM:SS)ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.');
                }
            });
        } else {
            console.error('parseBtn ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        }

        clearBtn.addEventListener('click', () => {
            curriculumInput.value = '';
            chapters = [];
            currentChapterIndex = 0;
            activeChapterName = '';
            clearChapterTimers();
            renderChapters();
            updateStatus('ready', 'ì¤€ë¹„ë¨ - ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”');
        });

        playbackSpeed.addEventListener('change', () => {
            renderChapters();
        });

        // ë¶„í•  ëª¨ë“œ ë³€ê²½ ì´ë²¤íŠ¸
        const splitModeRadios = document.getElementsByName('splitMode');
        splitModeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                // ëª¨ë“  ìƒíƒœ í‘œì‹œ ìˆ¨ê¸°ê¸°
                if (autoSplitStatus) autoSplitStatus.style.display = 'none';
                if (clipboardSplitStatus) clipboardSplitStatus.style.display = 'none';

                if (e.target.value === 'title') {
                    console.log('ğŸ“Œ ì œëª© ê°ì§€ ìë™ ë¶„í•  ëª¨ë“œ (DOM) ì„ íƒë¨');
                    addLog('ğŸ“Œ ì œëª© ê°ì§€ ìë™ ë¶„í•  ëª¨ë“œ (DOM) ì„ íƒ - ë…¹ìŒ ì‹œ ìë™ìœ¼ë¡œ ì œëª© ê°ì§€ ì‹œì‘', 'info');

                    // ìƒíƒœ í‘œì‹œ
                    if (autoSplitStatus) autoSplitStatus.style.display = 'block';

                    // í˜„ì¬ ê°ì§€ ê°€ëŠ¥í•œì§€ í…ŒìŠ¤íŠ¸
                    const testTitle = getCurrentLectureTitle();
                    if (testTitle) {
                        addLog(`âœ… ì œëª© ê°ì§€ í…ŒìŠ¤íŠ¸ ì„±ê³µ: "${testTitle}"`, 'success');
                    } else {
                        addLog(`âš ï¸ í˜„ì¬ ì œëª©ì„ ê°ì§€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê°•ì˜ í˜ì´ì§€ì—ì„œ ì‚¬ìš©í•˜ì„¸ìš”.`, 'warning');
                    }
                } else if (e.target.value === 'clipboard') {
                    console.log('ğŸ“‹ í´ë¦½ë³´ë“œ ê¸°ë°˜ ìë™ ë¶„í•  ëª¨ë“œ ì„ íƒë¨');
                    addLog('ğŸ“‹ í´ë¦½ë³´ë“œ ê¸°ë°˜ ìë™ ë¶„í•  ëª¨ë“œ ì„ íƒ - ë…¹ìŒ ì‹œ í´ë¦½ë³´ë“œ ê°ì‹œ ì‹œì‘', 'info');

                    // ìƒíƒœ í‘œì‹œ
                    if (clipboardSplitStatus) clipboardSplitStatus.style.display = 'block';

                    // í´ë¦½ë³´ë“œ ê¶Œí•œ í…ŒìŠ¤íŠ¸
                    navigator.clipboard.readText()
                        .then(text => {
                            addLog(`âœ… í´ë¦½ë³´ë“œ ì ‘ê·¼ ê¶Œí•œ í™•ì¸ ì™„ë£Œ`, 'success');
                            if (text) {
                                addLog(`ğŸ“‹ í˜„ì¬ í´ë¦½ë³´ë“œ ë‚´ìš©: "${text}"`, 'info');
                            }
                        })
                        .catch(error => {
                            addLog(`âš ï¸ í´ë¦½ë³´ë“œ ì ‘ê·¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.`, 'warning');
                        });
                } else {
                    console.log('ğŸ“Œ ìˆ˜ë™ ë¶„í•  ëª¨ë“œ ì„ íƒë¨');
                }
            });
        });

        // CSV íŒŒì¼ ì—…ë¡œë“œ ì´ë²¤íŠ¸
        if (csvFileInput) {
            csvFileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    csvData = parseCSV(text);

                    csvStatus.textContent = `âœ… CSV íŒŒì¼ ë¡œë“œ ì„±ê³µ (${csvData.length}ê°œ ê°•ì˜)`;
                    csvStatus.style.color = '#4caf50';

                    addLog(`âœ… CSV íŒŒì¼ ë¡œë“œ ì„±ê³µ: ${csvData.length}ê°œ ê°•ì˜`, 'success');

                    // ì²˜ë¦¬ ë²„íŠ¼ í™œì„±í™” ì²´í¬
                    updateProcessBatchButton();
                } catch (error) {
                    csvStatus.textContent = `âŒ ì˜¤ë¥˜: ${error.message}`;
                    csvStatus.style.color = '#f44336';
                    addLog(`âŒ CSV íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: ${error.message}`, 'error');
                }
            });
        }

        // webm íŒŒì¼ ì—…ë¡œë“œ ì´ë²¤íŠ¸
        if (fullWebmInput) {
            fullWebmInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                fullWebmFile = file;
                webmStatus.textContent = `âœ… ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                webmStatus.style.color = '#4caf50';

                addLog(`âœ… webm íŒŒì¼ ì„ íƒ: ${file.name}`, 'success');

                // ì²˜ë¦¬ ë²„íŠ¼ í™œì„±í™” ì²´í¬
                updateProcessBatchButton();
            });
        }

        // ìº¡ì²˜ ì´ë¯¸ì§€ í´ë” ì—…ë¡œë“œ ì´ë²¤íŠ¸
        if (captureImagesInput) {
            captureImagesInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;

                captureImagesFiles = files;
                imagesStatus.textContent = `âœ… ${files.length}ê°œ ì´ë¯¸ì§€ ì„ íƒë¨`;
                imagesStatus.style.color = '#4caf50';

                addLog(`âœ… ìº¡ì²˜ ì´ë¯¸ì§€ ${files.length}ê°œ ì„ íƒë¨`, 'success');
            });
        }

        // CSV ì¼ê´„ ì²˜ë¦¬ ë²„íŠ¼ ì´ë²¤íŠ¸
        if (processCsvBatchBtn) {
            processCsvBatchBtn.addEventListener('click', processCsvBatch);
        }

        // ì²˜ë¦¬ ë²„íŠ¼ í™œì„±í™” ì²´í¬ í•¨ìˆ˜
        function updateProcessBatchButton() {
            if (csvData && fullWebmFile && processCsvBatchBtn) {
                processCsvBatchBtn.disabled = false;
                processCsvBatchBtn.style.cursor = 'pointer';
                processCsvBatchBtn.style.opacity = '1';
            }
        }

        // ì±•í„° ëª¨ë“œ ë¬´ìŒ ì„¤ì • ì´ë²¤íŠ¸
        chapterSilence5.addEventListener('change', (e) => {
            console.log(`[ì±•í„° ëª¨ë“œ] ì”ì—¬ 5ì´ˆ ì´í•˜ ë¬´ìŒ ì¡°ê±´ ë³€ê²½: ${parseInt(e.target.value) / 1000}ì´ˆ`);
        });

        // GitHub APIë¥¼ ì‚¬ìš©í•˜ì—¬ ë§ˆì§€ë§‰ ì»¤ë°‹ ë‚ ì§œ ê°€ì ¸ì˜¤ê¸°
        async function updateLastUpdateDate() {
            const owner = 'Goldloom';
            const repo = 'audio-recorder';
            const path = 'index.html';
            const url = `https://api.github.com/repos/${owner}/${repo}/commits?path=${path}&page=1&per_page=1`;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const commits = await response.json();
                if (commits && commits.length > 0) {
                    const lastCommitDate = new Date(commits[0].commit.committer.date);
                    const formattedDate = lastCommitDate.getFullYear() + '-' +
                        String(lastCommitDate.getMonth() + 1).padStart(2, '0') + '-' +
                        String(lastCommitDate.getDate()).padStart(2, '0') + ' ' +
                        String(lastCommitDate.getHours()).padStart(2, '0') + ':' +
                        String(lastCommitDate.getMinutes()).padStart(2, '0');
                    document.getElementById('lastUpdate').textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${formattedDate}`;
                } else {
                    // ì»¤ë°‹ ì •ë³´ê°€ ì—†ì„ ë•Œ
                    document.getElementById('lastUpdate').textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ì •ë³´ ì—†ìŒ`;
                }
            } catch (error) {
                console.error('ì—…ë°ì´íŠ¸ ë‚ ì§œë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:', error);
                // ì—ëŸ¬ ë°œìƒ ì‹œ í˜„ì¬ ë‚ ì§œ í‘œì‹œ
                const now = new Date();
                const formattedDate = now.getFullYear() + '-' +
                    String(now.getMonth() + 1).padStart(2, '0') + '-' +
                    String(now.getDate()).padStart(2, '0') + ' ' +
                    String(now.getHours()).padStart(2, '0') + ':' +
                    String(now.getMinutes()).padStart(2, '0');
                document.getElementById('lastUpdate').textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${formattedDate} (ë¡œì»¬)`;
            }
        }

        updateLastUpdateDate();
        drawVisualizer();

        function checkBrowserSupport() {
            const hasMediaDevices = !!(navigator.mediaDevices);
            const hasGetDisplayMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia);
            const isSecure = window.isSecureContext;
            const protocol = window.location.protocol;

            if (!hasMediaDevices || !hasGetDisplayMedia) {
                let reason = "ì´ ë¸Œë¼ìš°ì €ëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";

                if (!isSecure && protocol !== 'localhost:' && protocol !== '127.0.0.1:') {
                    reason = "ë³´ì•ˆ ì—°ê²°(HTTPS) í™˜ê²½ì´ ì•„ë‹ˆì–´ì„œ ê¸°ëŠ¥ì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ì£¼ì†Œì°½ì˜ ì£¼ì†Œê°€ https:// ë¡œ ì‹œì‘í•˜ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.";
                } else if (protocol === 'file:') {
                    reason = "ë¡œì»¬ íŒŒì¼(file://)ë¡œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. ì›¹ ì„œë²„(http://localhost ë“±)ë¥¼ í†µí•´ ì‹¤í–‰í•´ì•¼ ê¸°ëŠ¥ì´ ì‘ë™í•©ë‹ˆë‹¤.";
                } else if (/Android|iPhone|iPad/i.test(navigator.userAgent)) {
                    reason = "ëª¨ë°”ì¼ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. PCë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.";
                }

                const debugInfo = `(ì§„ë‹¨: MD=${hasMediaDevices}, GDM=${hasGetDisplayMedia}, Sec=${isSecure}, Proto=${protocol})`;
                updateStatus('error', `âŒ ${reason} ${debugInfo}`);
                recordBtn.disabled = true;
            }
        }

        checkBrowserSupport();
    </script>

</body>

</html>