<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ë…¹ìŒê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            position: relative;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 24px;
            padding: 40px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
        }

        h1 {
            text-align: center;
            color: #1a1a2e;
            margin-bottom: 8px;
            font-size: 28px;
            font-weight: 600;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
            font-size: 14px;
        }

        .format-badge {
            text-align: center;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
            margin: 0 auto 20px;
            width: fit-content;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .help-icon {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: help;
        }

        .help-icon:hover .tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .tooltip {
            position: absolute;
            top: 35px;
            right: 0;
            background: #1a1a2e;
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            line-height: 1.6;
            width: 280px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .tooltip strong {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .tooltip ol {
            margin-left: 18px;
            padding: 0;
        }

        .tooltip li {
            margin-bottom: 4px;
        }

        .source-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        .source-btn {
            flex: 1;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .source-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .source-btn.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .source-btn .icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .source-btn .label {
            font-size: 13px;
            font-weight: 600;
        }

        .source-btn .desc {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 3px;
        }

        .visualizer-container {
            background: #1a1a2e;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 25px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #visualizer {
            width: 100%;
            height: 60px;
        }

        .timer {
            text-align: center;
            font-size: 48px;
            font-weight: 300;
            color: #1a1a2e;
            margin-bottom: 25px;
            font-family: 'Courier New', monospace;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-record {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .btn-record.recording {
            animation: pulse 1.5s infinite;
        }

        .btn-stop {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .btn-pause {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7);
            }

            50% {
                box-shadow: 0 0 0 20px rgba(231, 76, 60, 0);
            }
        }

        .btn svg {
            width: 28px;
            height: 28px;
            fill: white;
        }

        .status {
            text-align: center;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .status.ready {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status.recording {
            background: #ffebee;
            color: #c62828;
        }

        .status.paused {
            background: #fff8e1;
            color: #f57f17;
        }

        .status.error {
            background: #fce4ec;
            color: #c2185b;
        }

        .recordings {
            max-height: 300px;
            overflow-y: auto;
        }

        .recordings h2 {
            color: #1a1a2e;
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .recordings-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-download-all {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-download-all:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        .btn-download-all:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recording-item {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .recording-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .recording-info {
            flex: 1;
        }

        .recording-name {
            font-weight: 600;
            color: #1a1a2e;
            font-size: 14px;
        }

        .recording-meta {
            font-size: 12px;
            color: #888;
            margin-top: 3px;
        }

        .recording-badge {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 20px;
            font-weight: 600;
        }

        .badge-system {
            background: #e3f2fd;
            color: #1565c0;
        }

        .badge-mic {
            background: #fce4ec;
            color: #c2185b;
        }

        .badge-both {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .recording-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .btn-small:hover {
            transform: scale(1.1);
        }

        .btn-small svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        .btn-download {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .btn-delete {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .recording-item audio {
            width: 100%;
            height: 40px;
            border-radius: 8px;
        }

        .empty-state {
            text-align: center;
            color: #888;
            padding: 30px;
            font-size: 14px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-item input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }

        .extra-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn-new-lecture {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-new-lecture:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }

        .btn-new-lecture:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 10px;
        }

        .toggle-label {
            font-size: 13px;
            color: #333;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked+.toggle-slider {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .toggle-switch input:checked+.toggle-slider:before {
            transform: translateX(24px);
        }

        .silence-indicator {
            font-size: 11px;
            color: #888;
            margin-left: 5px;
        }

        .silence-indicator.active {
            color: #27ae60;
            font-weight: 600;
        }

        .capture-section {
            background: #fff3e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .capture-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .capture-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .capture-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .capture-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }

        .capture-option select {
            padding: 5px 8px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 12px;
            cursor: pointer;
            background: white;
        }

        .capture-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .capture-status {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .capture-status.active {
            color: #e65100;
            font-weight: 500;
        }

        .curriculum-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
        }

        .curriculum-help {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .curriculum-help-icon {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
        }

        .curriculum-help-icon:hover+.curriculum-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .curriculum-tooltip {
            position: absolute;
            top: 25px;
            left: 0;
            background: #1a1a2e;
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            line-height: 1.7;
            width: 320px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .curriculum-tooltip strong {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #f093fb;
        }

        .curriculum-tooltip code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        .curriculum-tooltip ul {
            margin: 8px 0;
            padding-left: 18px;
        }

        .curriculum-tooltip li {
            margin-bottom: 4px;
        }

        .curriculum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .curriculum-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .speed-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-selector label {
            font-size: 13px;
            color: #555;
        }

        .speed-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 13px;
            cursor: pointer;
            background: white;
        }

        .curriculum-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            margin-bottom: 10px;
        }

        .curriculum-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .curriculum-textarea::placeholder {
            color: #aaa;
        }

        .btn-parse {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-parse:hover {
            transform: scale(1.02);
        }

        .chapter-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .chapter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .chapter-item.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .chapter-item.completed {
            background: #d4edda;
            color: #155724;
        }

        .chapter-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 10px;
        }

        .chapter-time {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            opacity: 0.8;
        }

        .chapter-progress {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .clear-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
        }

        .clear-btn:hover {
            background: #c0392b;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 12px 15px;
            border-radius: 10px;
            font-size: 12px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .update-date {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 11px;
            color: #999;
            font-family: inherit;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="lastUpdate" class="update-date">ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: í™•ì¸ ì¤‘...</div>
        <h1>ğŸ§ ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ë…¹ìŒê¸°</h1>
        <div class="format-badge">ğŸµ ë…¹ìŒ í˜•ì‹: OGG/Opus</div>

        <div class="help-icon">
            ?
            <div class="tooltip">
                <strong>ğŸ“Œ ì‚¬ìš© ë°©ë²•</strong>
                <ol>
                    <li>ë…¹ìŒ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</li>
                    <li>ê³µìœ  ì°½ì—ì„œ <strong>"Chrome íƒ­"</strong> ë˜ëŠ” <strong>"ì „ì²´ í™”ë©´"</strong> ì„ íƒ</li>
                    <li><strong>"ì˜¤ë””ì˜¤ ê³µìœ "</strong> ì²´í¬ âœ…</li>
                    <li>ê³µìœ  ë²„íŠ¼ í´ë¦­ í›„ ë…¹ìŒ ì‹œì‘!</li>
                </ol>
            </div>
        </div>

        <div class="warning">
            âš ï¸ <strong>Chrome, Edge ë¸Œë¼ìš°ì €</strong>ì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤. Firefox, SafariëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
        </div>

        <div class="checkbox-group">
            <div class="checkbox-item">
                <input type="checkbox" id="includeSystemAudio" checked>
                <label for="includeSystemAudio">ğŸ”Š ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤</label>
            </div>
            <div class="checkbox-item">
                <input type="checkbox" id="includeMic">
                <label for="includeMic">ğŸ¤ ë§ˆì´í¬ (ë‚´ ëª©ì†Œë¦¬)</label>
            </div>
        </div>

        <div id="status" class="status ready">ì¤€ë¹„ë¨ - ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”</div>

        <div class="extra-controls">
            <div class="toggle-container">
                <span class="toggle-label">ğŸ”‡ ë¬´ìŒ ê°ì§€ ìë™ë¶„í• </span>
                <label class="toggle-switch">
                    <input type="checkbox" id="silenceDetection">
                    <span class="toggle-slider"></span>
                </label>
                <span id="silenceIndicator" class="silence-indicator"></span>
            </div>
            <button class="btn-new-lecture" id="newLectureBtn" disabled>
                ğŸ“š ìƒˆ ê°•ì˜
            </button>
        </div>

        <div class="capture-section">
            <div class="capture-header">
                <div class="capture-toggle">
                    <span class="capture-title">ğŸ“¸ ì´ë¯¸ì§€ìº¡ì²˜(WebP->PDF)</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="captureEnabled" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="capture-options">
                    <div class="capture-option">
                        <label>ê°„ê²©:</label>
                        <select id="captureInterval">
                            <option value="1">1ì´ˆ</option>
                            <option value="2">2ì´ˆ</option>
                            <option value="5" selected>5ì´ˆ</option>
                            <option value="10">10ì´ˆ</option>
                        </select>
                    </div>
                    <div class="capture-option">
                        <label>í’ˆì§ˆ:</label>
                        <select id="captureQuality">
                            <option value="0.9">ê³ í™”ì§ˆ</option>
                            <option value="0.7" selected>ì¤‘í™”ì§ˆ</option>
                            <option value="0.5">ì €í™”ì§ˆ</option>
                        </select>
                    </div>
                </div>
            </div>
            <div id="captureStatus" class="capture-status"></div>
        </div>

        <div class="curriculum-section">
            <div class="curriculum-header">
                <span class="curriculum-title">
                    <span class="curriculum-help">
                        ğŸ“‹ ê°•ì˜ ëª©ì°¨ (ì„ íƒì‚¬í•­)
                        <span class="curriculum-help-icon">?</span>
                        <div class="curriculum-tooltip">
                            <strong>ğŸ“Œ ëª©ì°¨ ì…ë ¥ ë°©ë²•</strong>
                            ê°•ì˜ ì‚¬ì´íŠ¸ì—ì„œ ëª©ì°¨ë¥¼ ë³µì‚¬í•´ì„œ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.
                            <ul>
                                <li><code>55</code> â†’ ê°•ì˜ ë²ˆí˜¸</li>
                                <li><code>Part 4. Advanced</code> â†’ íŒŒíŠ¸ëª…</li>
                                <li><code>Ch01. ì œëª©</code> â†’ ì±•í„°ëª… (ì‹œê°„ ì—†ìŒ)</li>
                                <li><code>CH01-1. ì œëª© 7:58</code> â†’ ì†Œì±•í„° (ì‹œê°„ í•„ìˆ˜)</li>
                            </ul>
                            <strong>ğŸ’¾ ì €ì¥ë˜ëŠ” íŒŒì¼ëª… ì˜ˆì‹œ</strong>
                            <code>55 Part 4 - Ch01 - CH01-1. ì œëª©.webm</code>
                            <br><br>
                            â© ë°°ì† ì„¤ì •í•˜ë©´ ìë™ìœ¼ë¡œ ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚°ë¨
                        </div>
                    </span>
                </span>
                <div class="speed-selector">
                    <label>ì¬ìƒ ë°°ì†:</label>
                    <select id="playbackSpeed">
                        <option value="1">1ë°°ì†</option>
                        <option value="1.25">1.25ë°°ì†</option>
                        <option value="1.5">1.5ë°°ì†</option>
                        <option value="1.75">1.75ë°°ì†</option>
                        <option value="2" selected>2ë°°ì†</option>
                        <option value="2.5">2.5ë°°ì†</option>
                        <option value="3">3ë°°ì†</option>
                    </select>
                </div>
            </div>
            <textarea id="curriculumInput" class="curriculum-textarea" placeholder="ê°•ì˜ ëª©ì°¨ë¥¼ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”. ì˜ˆì‹œ:

001
Part 1. ê¸°ì´ˆí¸
Ch01. ì˜¤ë¦¬ì—”í…Œì´ì…˜
01. ê°•ì˜ ì†Œê°œ 5:00
02. í•™ìŠµ ë°©ë²• ì•ˆë‚´ 7:30"></textarea>
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <button class="btn-parse" id="parseBtn">ëª©ì°¨ ë¶„ì„</button>
                <button class="clear-btn" id="clearBtn">ì´ˆê¸°í™”</button>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;">
                    <input type="checkbox" id="autoStopCheckbox" checked style="width: 16px; height: 16px;">
                    ëª©ì°¨ ëë‚˜ë©´ ìë™ ì¢…ë£Œ
                </label>
            </div>
            <div id="chapterList" class="chapter-list"></div>
            <div id="chapterProgress" class="chapter-progress"></div>
        </div>

        <div class="visualizer-container">
            <canvas id="visualizer"></canvas>
        </div>

        <div class="timer" id="timer">00:00:00</div>

        <div class="controls">
            <button class="btn btn-record" id="recordBtn" title="ë…¹ìŒ ì‹œì‘">
                <svg viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="8" />
                </svg>
            </button>
            <button class="btn btn-pause" id="pauseBtn" disabled title="ì¼ì‹œì •ì§€">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="4" width="4" height="16" />
                    <rect x="14" y="4" width="4" height="16" />
                </svg>
            </button>
            <button class="btn btn-stop" id="stopBtn" disabled title="ì •ì§€">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="6" width="12" height="12" />
                </svg>
            </button>
        </div>

        <div class="recordings">
            <h2>
                <span class="recordings-title">ğŸ“ ë…¹ìŒ íŒŒì¼</span>
                <button class="btn-download-all" id="downloadAllBtn" disabled>
                    â¬‡ï¸ ì „ì²´ ë‹¤ìš´ë¡œë“œ
                </button>
            </h2>
            <div id="recordingsList">
                <div class="empty-state">ë…¹ìŒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>
            </div>
        </div>
    </div>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let recordings = [];
        let startTime;
        let timerInterval;
        let isPaused = false;
        let pausedTime = 0;
        let audioContext;
        let analyser;
        let dataArray;
        let animationId;
        let streams = [];
        let silenceStart = null;
        let silenceThreshold = 15; // ë³¼ë¥¨ ì„ê³„ê°’ (0-255)
        let silenceDuration = 4000; // 4ì´ˆ ë¬´ìŒ ì‹œ ë¶„í• 
        let lectureCount = 1;

        const recordBtn = document.getElementById('recordBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timerDisplay = document.getElementById('timer');
        const recordingsList = document.getElementById('recordingsList');
        const statusDisplay = document.getElementById('status');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        const includeSystemAudio = document.getElementById('includeSystemAudio');
        const includeMic = document.getElementById('includeMic');
        const silenceDetection = document.getElementById('silenceDetection');
        const silenceIndicator = document.getElementById('silenceIndicator');
        const newLectureBtn = document.getElementById('newLectureBtn');
        const curriculumInput = document.getElementById('curriculumInput');
        const parseBtn = document.getElementById('parseBtn');
        const clearBtn = document.getElementById('clearBtn');
        const chapterList = document.getElementById('chapterList');
        const chapterProgress = document.getElementById('chapterProgress');
        const playbackSpeed = document.getElementById('playbackSpeed');
        const autoStopCheckbox = document.getElementById('autoStopCheckbox');
        const captureEnabled = document.getElementById('captureEnabled');
        const captureInterval = document.getElementById('captureInterval');
        const captureQuality = document.getElementById('captureQuality');
        const captureStatus = document.getElementById('captureStatus');
        const downloadAllBtn = document.getElementById('downloadAllBtn');

        let chapters = [];
        let currentChapterIndex = 0;
        let chapterStartTime = 0;
        let chapterTimers = [];

        // ìº¡ì²˜ ê´€ë ¨ ë³€ìˆ˜
        let captureTimer = null;
        let capturedImages = [];
        let captureCount = 0;
        let videoStream = null;
        let videoElement = null;

        // ë¶„í•  ëŒ€ê¸° ìƒíƒœ ë³€ìˆ˜ë“¤
        let chapterReadyToSplit = false;
        let waitingForSilence = false;
        let pendingSplitChapterIndex = -1;
        let readyToAutoStop = false;
        let silenceStartForSplit = null;
        const silenceDurationForSplit = 2000; // âœ… 2ì´ˆ ë¬´ìŒ (ê¸°ì¡´ 3000ms â†’ 2000ms)

        // âœ… í˜„ì¬ ë…¹ìŒ ì¤‘ì¸ ì±•í„° ì´ë¦„
        let activeChapterName = '';

        function updateStatus(state, message) {
            statusDisplay.className = 'status ' + state;
            statusDisplay.textContent = message;
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            if (!isPaused) {
                const elapsed = Date.now() - startTime + pausedTime;
                timerDisplay.textContent = formatTime(elapsed);
            }
        }

        function setupVisualizer() {
            if (audioContext) {
                audioContext.close().catch(() => { });
            }

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.8;

            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            streams.forEach(s => {
                if (s.getAudioTracks().length > 0) {
                    try {
                        const source = audioContext.createMediaStreamSource(s);
                        source.connect(analyser);
                    } catch (e) {
                        console.log('Stream already connected or invalid');
                    }
                }
            });

            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            drawVisualizer();
        }

        function drawVisualizer() {
            animationId = requestAnimationFrame(drawVisualizer);

            canvas.width = canvas.offsetWidth * 2;
            canvas.height = canvas.offsetHeight * 2;
            canvasCtx.scale(2, 2);

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            canvasCtx.fillStyle = '#1a1a2e';
            canvasCtx.fillRect(0, 0, width, height);

            if (!analyser || !dataArray) {
                canvasCtx.strokeStyle = '#667eea';
                canvasCtx.lineWidth = 2;
                canvasCtx.beginPath();
                canvasCtx.moveTo(0, height / 2);
                canvasCtx.lineTo(width, height / 2);
                canvasCtx.stroke();
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            // (ê¸°ì¡´ ë¬´ìŒ ê°ì§€ ë¡œì§ ê·¸ëŒ€ë¡œ)

            if (silenceDetection.checked && mediaRecorder && mediaRecorder.state === 'recording' && !waitingForSilence) {
                const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                if (average < silenceThreshold) {
                    if (!silenceStart) {
                        silenceStart = Date.now();
                    } else {
                        const silentTime = Date.now() - silenceStart;
                        silenceIndicator.textContent = `(ë¬´ìŒ ${(silentTime / 1000).toFixed(1)}ì´ˆ)`;
                        silenceIndicator.className = 'silence-indicator active';

                        if (silentTime >= silenceDuration) {
                            splitRecording();
                            silenceStart = null;
                            silenceIndicator.textContent = '(ìë™ ë¶„í• ë¨!)';
                        }
                    }
                } else {
                    silenceStart = null;
                    silenceIndicator.textContent = '';
                    silenceIndicator.className = 'silence-indicator';
                }
            }

            // âœ… ì±•í„° ìë™ ë¶„í• ìš© ë¬´ìŒ ê°ì§€ (2ì´ˆ)
            if (waitingForSilence && mediaRecorder && mediaRecorder.state === 'recording') {
                const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                if (average < silenceThreshold) {
                    if (!silenceStartForSplit) {
                        silenceStartForSplit = Date.now();
                    } else {
                        const silentTime = Date.now() - silenceStartForSplit;
                        silenceIndicator.textContent = `(ë¬´ìŒ ${(silentTime / 1000).toFixed(1)}ì´ˆ / 2ì´ˆ)`;
                        silenceIndicator.className = 'silence-indicator active';

                        if (silentTime >= silenceDurationForSplit) {
                            if (readyToAutoStop) {
                                updateStatus('ready', 'âœ… ëª¨ë“  ê°•ì˜ ë…¹ìŒ ì™„ë£Œ! ìë™ ì¢…ë£Œë¨');
                                stopRecording();
                            } else if (chapterReadyToSplit && pendingSplitChapterIndex >= 0) {
                                // ë‹¤ìŒ ì±•í„°ë¡œ ì´ë™
                                const endedIdx = pendingSplitChapterIndex;
                                const endedName = chapters[endedIdx].name;
                                currentChapterIndex = endedIdx + 1;

                                splitRecordingWithName(endedName);
                                renderChapters();

                                chapterReadyToSplit = false;
                                waitingForSilence = false;
                                pendingSplitChapterIndex = -1;
                                silenceIndicator.textContent = '(ë¶„í•  ì™„ë£Œ!)';
                            }
                            silenceStartForSplit = null;
                        }
                    }
                } else {
                    silenceStartForSplit = null;
                    if (waitingForSilence) {
                        silenceIndicator.textContent = '(ë¬´ìŒ ëŒ€ê¸° ì¤‘...)';
                        silenceIndicator.className = 'silence-indicator active';
                    }
                }
            }

            const barCount = 64;
            const barWidth = width / barCount;
            const gap = 2;

            for (let i = 0; i < barCount; i++) {
                const dataIndex = Math.floor(i * dataArray.length / barCount);
                const barHeight = (dataArray[dataIndex] / 255) * height * 0.9;

                const x = i * barWidth;
                const y = height - barHeight;

                const gradient = canvasCtx.createLinearGradient(0, y, 0, height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(0.5, '#764ba2');
                gradient.addColorStop(1, '#f093fb');

                canvasCtx.fillStyle = gradient;
                canvasCtx.fillRect(x + gap / 2, y, barWidth - gap, barHeight);
            }
        }

        function mergeAudioStreams(streams) {
            const ctx = new AudioContext();
            const dest = ctx.createMediaStreamDestination();

            streams.forEach(stream => {
                if (stream.getAudioTracks().length > 0) {
                    const source = ctx.createMediaStreamSource(stream);
                    source.connect(dest);
                }
            });

            return dest.stream;
        }

        async function startRecording() {
            const wantSystem = includeSystemAudio.checked;
            const wantMic = includeMic.checked;

            if (!wantSystem && !wantMic) {
                updateStatus('error', 'âŒ ìµœì†Œ í•˜ë‚˜ì˜ ì˜¤ë””ì˜¤ ì†ŒìŠ¤ë¥¼ ì„ íƒí•˜ì„¸ìš”');
                return;
            }

            try {
                streams = [];
                let recordingType = '';

                // ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ íšë“
                if (wantSystem) {
                    updateStatus('ready', 'ğŸ”„ í™”ë©´ ê³µìœ  ì°½ì—ì„œ ì˜¤ë””ì˜¤ë¥¼ ì„ íƒí•˜ì„¸ìš”...');
                    const displayStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: true
                    });

                    // ë¹„ë””ì˜¤ íŠ¸ë™ì´ ìˆìœ¼ë©´ ìº¡ì²˜ìš©ìœ¼ë¡œ ì €ì¥
                    const videoTrack = displayStream.getVideoTracks()[0];
                    if (videoTrack && captureEnabled.checked) {
                        videoStream = new MediaStream([videoTrack]);
                        videoElement = document.createElement('video');
                        videoElement.srcObject = videoStream;
                        videoElement.muted = true;
                        videoElement.play();
                    } else if (videoTrack) {
                        videoTrack.stop();
                    }

                    // ì˜¤ë””ì˜¤ íŠ¸ë™ë§Œ ì¶”ì¶œ
                    const audioTrack = displayStream.getAudioTracks()[0];
                    if (audioTrack) {
                        const audioOnlyStream = new MediaStream([audioTrack]);
                        streams.push(audioOnlyStream);
                        recordingType = 'system';
                    }
                }

                // ë§ˆì´í¬ íšë“
                if (wantMic) {
                    const micStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    streams.push(micStream);
                    recordingType = recordingType === 'system' ? 'both' : 'mic';
                }

                if (streams.length === 0) {
                    throw new Error('ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ìŠ¤íŠ¸ë¦¼ ë³‘í•©
                let finalStream;
                if (streams.length > 1) {
                    finalStream = mergeAudioStreams(streams);
                } else {
                    finalStream = streams[0];
                }

                setupVisualizer();

                const mimeType = MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')
                    ? 'audio/ogg;codecs=opus'
                    : 'audio/ogg';

                mediaRecorder = new MediaRecorder(finalStream, { mimeType });
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                // ì²« ë…¹ìŒ onstop ì€ activeChapterName ê¸°ì¤€
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    const baseName =
                        activeChapterName ||
                        (chapters[currentChapterIndex]?.name) ||
                        `ê°•ì˜${lectureCount}`;
                    saveRecordingWithName(audioBlob, recordingType, baseName);
                    cleanup();
                };

                mediaRecorder.start(1000);
                startTime = Date.now();
                pausedTime = 0;
                isPaused = false;
                timerInterval = setInterval(updateTimer, 100);

                // ìº¡ì²˜ ì‹œì‘
                if (captureEnabled.checked && videoElement) {
                    startCapture();
                }

                recordBtn.classList.add('recording');
                recordBtn.disabled = true;
                pauseBtn.disabled = false;
                stopBtn.disabled = false;
                newLectureBtn.disabled = false;
                includeSystemAudio.disabled = true;
                includeMic.disabled = true;
                currentRecordingType = recordingType;
                lectureCount = 1;

                if (chapters.length > 0) {
                    startChapterTimers();
                    const firstChapter = chapters[0];
                    activeChapterName = firstChapter.name;
                    updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (${firstChapter.name})`);
                } else {
                    activeChapterName = '';
                    const sourceText = recordingType === 'both' ? 'ì‹œìŠ¤í…œ + ë§ˆì´í¬' :
                        recordingType === 'system' ? 'ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤' : 'ë§ˆì´í¬';
                    updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (ê°•ì˜ ${lectureCount}, ${sourceText})`);
                }

            } catch (err) {
                console.error('ë…¹ìŒ ì‹œì‘ ì˜¤ë¥˜:', err);
                cleanup();

                if (err.name === 'NotAllowedError') {
                    updateStatus('error', 'âŒ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.');
                } else if (err.name === 'NotSupportedError') {
                    updateStatus('error', 'âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome ë˜ëŠ” Edgeë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.');
                } else {
                    updateStatus('error', `âŒ ì˜¤ë¥˜: ${err.message}`);
                }
            }
        }

        function cleanup() {
            streams.forEach(stream => {
                stream.getTracks().forEach(track => track.stop());
            });
            streams = [];

            if (audioContext) {
                audioContext.close().catch(() => { });
                audioContext = null;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            analyser = null;
            dataArray = null;

            stopCapture();
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            if (videoElement) {
                videoElement.remove();
                videoElement = null;
            }
        }

        // ìº¡ì²˜ ê´€ë ¨ ìƒìˆ˜
        const TARGET_WIDTH = 1280;
        const TARGET_HEIGHT = 720;

        function startCapture() {
            if (!captureEnabled.checked || !videoElement) return;

            const interval = parseInt(captureInterval.value) * 1000;
            captureTimer = setInterval(captureFrame, interval);
            captureFrame(); // ì²« í”„ë ˆì„ ì¦‰ì‹œ ìº¡ì²˜
        }

        function stopCapture() {
            if (captureTimer) {
                clearInterval(captureTimer);
                captureTimer = null;
            }
        }

        function captureFrame() {
            if (!videoElement || videoElement.readyState < 2) return;

            const vw = videoElement.videoWidth;
            const vh = videoElement.videoHeight;

            // 1280x720 ê³ ì • ìº”ë²„ìŠ¤
            const canvas = document.createElement('canvas');
            canvas.width = TARGET_WIDTH;
            canvas.height = TARGET_HEIGHT;
            const ctx = canvas.getContext('2d');

            // ì›ë³¸ ë¹„ìœ¨ ìœ ì§€ + Contain ë°©ì‹
            const scale = Math.min(
                TARGET_WIDTH / vw,
                TARGET_HEIGHT / vh
            );

            const drawW = vw * scale;
            const drawH = vh * scale;

            const offsetX = (TARGET_WIDTH - drawW) / 2;
            const offsetY = (TARGET_HEIGHT - drawH) / 2;

            // ì—¬ë°± ë°°ê²½ìƒ‰ (ê²€ì • ë°”íƒ•)
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);

            // ë¹„ìœ¨ ìœ ì§€ëœ ìƒíƒœë¡œ ê°€ìš´ë° ì •ë ¬
            ctx.drawImage(videoElement, offsetX, offsetY, drawW, drawH);

            const quality = parseFloat(captureQuality.value);
            const imageData = canvas.toDataURL("image/webp", quality);

            capturedImages.push(imageData);
            captureCount++;

            updateCaptureStatus();
        }

        function updateCaptureStatus() {
            if (captureCount > 0) {
                captureStatus.textContent = `ğŸ“¸ ${captureCount}ì¥ ìº¡ì²˜ë¨`;
            } else {
                captureStatus.textContent = '';
            }
        }

        // jsPDF ë¼ì´ë¸ŒëŸ¬ë¦¬ ë™ì  ë¡œë“œ
        async function loadJsPdf() {
            if (window.jspdf) return window.jspdf;

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                script.onload = () => resolve(window.jspdf);
                script.onerror = () => reject(new Error('jsPDF ë¡œë“œ ì‹¤íŒ¨'));
                document.head.appendChild(script);
            });
        }

        // ìº¡ì²˜ëœ ì´ë¯¸ì§€ë“¤ì„ PDFë¡œ ì €ì¥
        async function saveImagesAsPdf(images, filename) {
            if (!images || images.length === 0) {
                console.log('ì €ì¥í•  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                updateStatus('ready', `ğŸ“„ PDF ìƒì„± ì¤‘... (${images.length}ì¥)`);

                // jsPDF ë¡œë“œ
                const jsPdfLib = await loadJsPdf();
                const { jsPDF } = jsPdfLib;

                // 1280x720 ê°€ë¡œ ë°©í–¥ PDF ìƒì„± (px to mm ë³€í™˜: 1px â‰ˆ 0.264583mm)
                const pdfWidth = 1280 * 0.264583;  // mm
                const pdfHeight = 720 * 0.264583;  // mm

                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: [pdfWidth, pdfHeight]
                });

                for (let i = 0; i < images.length; i++) {
                    const imageData = images[i];

                    // WebP â†’ JPEG ë³€í™˜ (jsPDFëŠ” WebP ë¯¸ì§€ì›)
                    const jpegData = await convertWebPToJpeg(imageData);

                    if (i > 0) {
                        pdf.addPage([pdfWidth, pdfHeight], 'landscape');
                    }

                    // ì´ë¯¸ì§€ë¥¼ í˜ì´ì§€ì— ê½‰ ì°¨ê²Œ ì¶”ê°€
                    pdf.addImage(jpegData, 'JPEG', 0, 0, pdfWidth, pdfHeight);

                    // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
                    if (i % 10 === 0 || i === images.length - 1) {
                        updateStatus('ready', `ğŸ“„ PDF ìƒì„± ì¤‘... (${i + 1}/${images.length})`);
                    }
                }

                // PDF ì €ì¥
                const pdfFilename = `${filename}.pdf`;
                pdf.save(pdfFilename);

                updateStatus('ready', `âœ… PDF ì €ì¥ ì™„ë£Œ: ${pdfFilename} (${images.length}í˜ì´ì§€)`);
                console.log(`PDF ì €ì¥ ì™„ë£Œ: ${pdfFilename}`);

            } catch (error) {
                console.error('PDF ìƒì„± ì˜¤ë¥˜:', error);
                updateStatus('error', `âŒ PDF ìƒì„± ì‹¤íŒ¨: ${error.message}`);
            }
        }

        // WebP â†’ JPEG ë³€í™˜ í•¨ìˆ˜
        function convertWebPToJpeg(webpDataUrl) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');

                    // í°ìƒ‰ ë°°ê²½ (JPEGëŠ” íˆ¬ëª…ë„ ë¯¸ì§€ì›)
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);

                    resolve(canvas.toDataURL('image/jpeg', 0.92));
                };
                img.onerror = () => reject(new Error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨'));
                img.src = webpDataUrl;
            });
        }

        function pauseRecording() {
            // ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.pause();
                isPaused = true;
                pausedTime += Date.now() - startTime;
                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <polygon points="5,3 19,12 5,21"/>
                    </svg>
                `;
                pauseBtn.title = 'ê³„ì†';
                updateStatus('paused', 'â¸ï¸ ì¼ì‹œì •ì§€ë¨');
            } else if (mediaRecorder && mediaRecorder.state === 'paused') {
                mediaRecorder.resume();
                isPaused = false;
                startTime = Date.now();
                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                `;
                pauseBtn.title = 'ì¼ì‹œì •ì§€';
                updateStatus('recording', 'ğŸ”´ ë…¹ìŒ ì¤‘...');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                clearInterval(timerInterval);

                recordBtn.classList.remove('recording');
                recordBtn.disabled = false;
                pauseBtn.disabled = true;
                stopBtn.disabled = true;
                newLectureBtn.disabled = true;
                includeSystemAudio.disabled = false;
                includeMic.disabled = false;
                silenceIndicator.textContent = '';
                silenceStart = null;
                clearChapterTimers();
                currentChapterIndex = 0;
                activeChapterName = '';   // âœ… ì´ˆê¸°í™”
                renderChapters();

                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                `;
                pauseBtn.title = 'ì¼ì‹œì •ì§€';

                timerDisplay.textContent = '00:00:00';
                updateStatus('ready', 'âœ… ë…¹ìŒ ì™„ë£Œ! ìƒˆ ë…¹ìŒì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            }
        }

        function saveRecording(blob, type) {
            const now = new Date();
            const name = `ê°•ì˜${lectureCount}_${now.toLocaleDateString('ko-KR')}_${now.toLocaleTimeString('ko-KR').replace(/:/g, '-')}`;
            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type
            };

            recordings.unshift(recording);
            renderRecordings();

            if (capturedImages.length > 0) {
                saveImagesAsPdf([...capturedImages], name);
                capturedImages = [];
                captureCount = 0;
                updateCaptureStatus();
            }
        }

        function getTypeBadge(type) {
            // ê·¸ëŒ€ë¡œ
            switch (type) {
                case 'system':
                    return '<span class="recording-badge badge-system">ğŸ”Š ì‹œìŠ¤í…œ</span>';
                case 'mic':
                    return '<span class="recording-badge badge-mic">ğŸ¤ ë§ˆì´í¬</span>';
                case 'both':
                    return '<span class="recording-badge badge-both">ğŸ§ ì‹œìŠ¤í…œ+ë§ˆì´í¬</span>';
                default:
                    return '';
            }
        }

        function renderRecordings() {
            // ê·¸ëŒ€ë¡œ
            if (recordings.length === 0) {
                recordingsList.innerHTML = '<div class="empty-state">ë…¹ìŒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>';
                downloadAllBtn.disabled = true;
                return;
            }

            downloadAllBtn.disabled = false;

            recordingsList.innerHTML = recordings.map(rec => `
                <div class="recording-item" data-id="${rec.id}">
                    <div class="recording-header">
                        <div class="recording-info">
                            <div class="recording-name">${rec.name}</div>
                            <div class="recording-meta">${rec.date} ${getTypeBadge(rec.type)}</div>
                        </div>
                        <div class="recording-actions">
                            <button class="btn-small btn-download" onclick="downloadRecording(${rec.id})" title="à¤¡à¤¾à¤‰à¤¨ë¡œë“œ">
                                <svg viewBox="0 0 24 24">
                                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                                </svg>
                            </button>
                            <button class="btn-small btn-delete" onclick="deleteRecording(${rec.id})" title="ì‚­ì œ">
                                <svg viewBox="0 0 24 24">
                                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <audio controls src="${rec.url}"></audio>
                </div>
            `).join('');
        }

        // (downloadAll / downloadRecording / deleteRecording / splitRecording í•¨ìˆ˜ëŠ” ê¸°ì¡´ê³¼ ë™ì¼)

        recordBtn.addEventListener('click', startRecording);
        pauseBtn.addEventListener('click', pauseRecording);
        stopBtn.addEventListener('click', stopRecording);
        newLectureBtn.addEventListener('click', () => splitRecording());

        // âœ… ì±•í„°ëª… ê¸°ë°˜ ë¶„í•  ì €ì¥
        function splitRecordingWithName(chapterName) {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                const endedChapterName =
                    chapterName ||
                    activeChapterName ||
                    (chapters[currentChapterIndex]?.name) ||
                    `ê°•ì˜${lectureCount}`;

                stopCapture();
                const imagesToSave = [...capturedImages];
                capturedImages = [];
                captureCount = 0;

                mediaRecorder.onstop = () => {
                    const mimeType = MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')
                        ? 'audio/ogg;codecs=opus'
                        : 'audio/ogg';
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    saveRecordingWithNameAndImages(audioBlob, currentRecordingType, endedChapterName, imagesToSave);
                    audioChunks = [];
                };

                mediaRecorder.stop();

                setTimeout(() => {
                    if (streams.length > 0 && streams.some(s => s.active)) {
                        let finalStream;
                        if (streams.length > 1) {
                            finalStream = mergeAudioStreams(streams);
                        } else {
                            finalStream = streams[0];
                        }

                        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                            ? 'audio/webm;codecs=opus'
                            : 'audio/webm';

                        mediaRecorder = new MediaRecorder(finalStream, { mimeType });

                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: mimeType });
                            const finalName =
                                activeChapterName ||
                                (chapters[currentChapterIndex]?.name) ||
                                `ê°•ì˜${lectureCount}`;
                            saveRecordingWithName(audioBlob, currentRecordingType, finalName);
                            audioChunks = [];
                        };

                        mediaRecorder.start(1000);
                        startTime = Date.now();
                        pausedTime = 0;

                        if (captureEnabled.checked && videoElement) {
                            startCapture();
                        }

                        activeChapterName = chapters[currentChapterIndex]?.name || activeChapterName; // âœ… ë‹¤ìŒ ì±•í„° ì´ë¦„ìœ¼ë¡œ ê°±ì‹ 
                        const nextChapter = chapters[currentChapterIndex];
                        updateStatus(
                            'recording',
                            `ğŸ”´ ë…¹ìŒ ì¤‘... (${nextChapter?.shortName || nextChapter?.name || 'ê°•ì˜'})`
                        );
                    }
                }, 100);
            }
        }

        function saveRecordingWithNameAndImages(blob, type, name, images) {
            const now = new Date();
            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type
            };

            recordings.unshift(recording);
            renderRecordings();

            if (images && images.length > 0) {
                saveImagesAsPdf(images, name);
            }
        }

        function saveRecordingWithName(blob, type, name) {
            const now = new Date();
            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type
            };

            recordings.unshift(recording);
            renderRecordings();

            if (capturedImages.length > 0) {
                saveImagesAsPdf([...capturedImages], name);
                capturedImages = [];
                captureCount = 0;
                updateCaptureStatus();
            }
        }

        // ëª©ì°¨ íŒŒì‹± í•¨ìˆ˜
        function parseCurriculum(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            const chapters = [];

            let currentLectureNum = '';
            let currentPart = '';
            let currentChapter = '';

            for (const line of lines) {
                // ê°•ì˜ ë²ˆí˜¸ (ìˆ«ìë§Œ ìˆëŠ” ì¤„, 1-3ìë¦¬)
                if (/^\d{1,3}$/.test(line)) {
                    currentLectureNum = line;
                    continue;
                }

                // Part ì¸ì‹
                const partMatch = line.match(/^Part\s*[\d.]+[.\s]*(.*)$/i);
                if (partMatch) {
                    currentPart = line;
                    continue;
                }

                // Chapter ì¸ì‹ (ì‹œê°„ ì—†ìŒ)
                const chapterMatch = line.match(/^Ch\d+[.\s]*(.*)$/i);
                if (chapterMatch && !line.match(/\d+:\d+/)) {
                    currentChapter = line;
                    continue;
                }

                // ì‹œê°„ì´ ìˆëŠ” ì¤„ â†’ ì‹¤ì œ ì±•í„°ë¡œ ì¶”ê°€
                const timeMatch = line.match(/(\d+):(\d+)/);
                if (timeMatch) {
                    const minutes = parseInt(timeMatch[1]);
                    const seconds = parseInt(timeMatch[2]);
                    const totalSeconds = minutes * 60 + seconds;

                    // ì±•í„° ì´ë¦„ êµ¬ì„±
                    let name = '';
                    if (currentLectureNum) name += currentLectureNum + ' ';
                    if (currentPart) name += currentPart.replace(/^Part\s*[\d.]+[.\s]*/, 'Part ').split('.')[0] + ' - ';
                    if (currentChapter) name += currentChapter.split('.')[0] + ' - ';

                    // í˜„ì¬ ì¤„ì—ì„œ ì‹œê°„ ë¶€ë¶„ ì œê±°í•˜ê³  ì œëª© ì¶”ì¶œ
                    const title = line.replace(/\s*\d+:\d+\s*$/, '').trim();
                    name += title;

                    chapters.push({
                        name: name.trim(),
                        shortName: title,
                        originalDuration: totalSeconds,
                        duration: totalSeconds
                    });
                }
            }

            return chapters;
        }

        // ì±•í„° ë Œë”ë§
        function renderChapters() {
            if (chapters.length === 0) {
                chapterList.innerHTML = '';
                chapterProgress.innerHTML = '';
                return;
            }

            const speed = parseFloat(playbackSpeed.value);

            let totalOriginal = 0;
            let totalAdjusted = 0;

            chapterList.innerHTML = chapters.map((ch, i) => {
                const adjustedDuration = Math.ceil(ch.originalDuration / speed);
                ch.duration = adjustedDuration;
                totalOriginal += ch.originalDuration;
                totalAdjusted += adjustedDuration;

                const isActive = i === currentChapterIndex;
                const isDone = i < currentChapterIndex;

                const originalTime = formatTime(ch.originalDuration * 1000);
                const adjustedTime = formatTime(adjustedDuration * 1000);

                return `
                    <div class="chapter-item ${isActive ? 'active' : ''} ${isDone ? 'done' : ''}">
                        <span class="chapter-number">${i + 1}</span>
                        <span class="chapter-name">${ch.shortName || ch.name}</span>
                        <span class="chapter-time">${originalTime} â†’ ${adjustedTime}</span>
                    </div>
                `;
            }).join('');

            chapterProgress.innerHTML = `
                <div>ì´ ${chapters.length}ê°œ ì±•í„°</div>
                <div>ì›ë³¸: ${formatTime(totalOriginal * 1000)} â†’ ì¡°ì •: ${formatTime(totalAdjusted * 1000)}</div>
            `;
        }

        // ì±•í„° íƒ€ì´ë¨¸ ì‹œì‘
        function startChapterTimers() {
            clearChapterTimers();
            activeChapterName = chapters[0]?.name || '';

            let cumulativeTime = 0;

            for (let i = 0; i < chapters.length; i++) {
                const ch = chapters[i];
                cumulativeTime += ch.duration * 1000;

                const timer = setTimeout(() => {
                    if (i < chapters.length - 1) {
                        // ë‹¤ìŒ ì±•í„°ë¡œ ì „í™˜ ì¤€ë¹„
                        chapterReadyToSplit = true;
                        waitingForSilence = true;
                        pendingSplitChapterIndex = i;
                        silenceIndicator.textContent = '(ë¬´ìŒ ëŒ€ê¸° ì¤‘...)';
                        silenceIndicator.className = 'silence-indicator active';
                    } else if (autoStopCheckbox.checked) {
                        // ë§ˆì§€ë§‰ ì±•í„° â†’ ìë™ ì¢…ë£Œ ì¤€ë¹„
                        readyToAutoStop = true;
                        waitingForSilence = true;
                        silenceIndicator.textContent = '(ë§ˆì§€ë§‰ ì±•í„°, ë¬´ìŒ ëŒ€ê¸°...)';
                        silenceIndicator.className = 'silence-indicator active';
                    }
                }, cumulativeTime);

                chapterTimers.push(timer);
            }
        }

        // ì±•í„° íƒ€ì´ë¨¸ í´ë¦¬ì–´
        function clearChapterTimers() {
            chapterTimers.forEach(t => clearTimeout(t));
            chapterTimers = [];
            chapterReadyToSplit = false;
            waitingForSilence = false;
            pendingSplitChapterIndex = -1;
            readyToAutoStop = false;
            silenceStartForSplit = null;
        }

        // ìˆ˜ë™ ë¶„í•  (ìƒˆ ê°•ì˜ ë²„íŠ¼)
        function splitRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                const currentName = activeChapterName || `ê°•ì˜${lectureCount}`;
                lectureCount++;

                stopCapture();
                const imagesToSave = [...capturedImages];
                capturedImages = [];
                captureCount = 0;

                mediaRecorder.onstop = () => {
                    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                        ? 'audio/webm;codecs=opus'
                        : 'audio/webm';
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    saveRecordingWithNameAndImages(audioBlob, currentRecordingType, currentName, imagesToSave);
                    audioChunks = [];
                };

                mediaRecorder.stop();

                setTimeout(() => {
                    if (streams.length > 0 && streams.some(s => s.active)) {
                        let finalStream;
                        if (streams.length > 1) {
                            finalStream = mergeAudioStreams(streams);
                        } else {
                            finalStream = streams[0];
                        }

                        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                            ? 'audio/webm;codecs=opus'
                            : 'audio/webm';

                        mediaRecorder = new MediaRecorder(finalStream, { mimeType });

                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: mimeType });
                            const finalName = activeChapterName || `ê°•ì˜${lectureCount}`;
                            saveRecordingWithName(audioBlob, currentRecordingType, finalName);
                            audioChunks = [];
                        };

                        mediaRecorder.start(1000);
                        startTime = Date.now();
                        pausedTime = 0;

                        if (captureEnabled.checked && videoElement) {
                            startCapture();
                        }

                        activeChapterName = `ê°•ì˜${lectureCount}`;
                        updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (ê°•ì˜ ${lectureCount})`);
                    }
                }, 100);
            }
        }

        // ë…¹ìŒ ë‹¤ìš´ë¡œë“œ
        function downloadRecording(id) {
            const recording = recordings.find(r => r.id === id);
            if (recording) {
                const a = document.createElement('a');
                a.href = recording.url;
                a.download = `${recording.name}.ogg`;
                a.click();
            }
        }

        // ë…¹ìŒ ì‚­ì œ
        function deleteRecording(id) {
            const index = recordings.findIndex(r => r.id === id);
            if (index > -1) {
                URL.revokeObjectURL(recordings[index].url);
                recordings.splice(index, 1);
                renderRecordings();
            }
        }

        // ì „ì²´ ë‹¤ìš´ë¡œë“œ
        async function downloadAll() {
            for (const recording of recordings) {
                const a = document.createElement('a');
                a.href = recording.url;
                a.download = `${recording.name}.ogg`;
                a.click();
                await new Promise(r => setTimeout(r, 500));
            }
        }

        downloadAllBtn.addEventListener('click', downloadAll);

        // ë§ˆì§€ë§‰ ë¶€ë¶„ ì˜ˆì‹œ
        parseBtn.addEventListener('click', () => {
            const text = curriculumInput.value;
            chapters = parseCurriculum(text);
            currentChapterIndex = 0;
            activeChapterName = chapters[0]?.name || '';
            renderChapters();

            if (chapters.length > 0) {
                updateStatus('ready', `âœ… ${chapters.length}ê°œ ì±•í„° ì¸ì‹ë¨`);
            } else {
                updateStatus('ready', 'âš ï¸ ì±•í„°ë¥¼ ì¸ì‹í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì‹œê°„(MM:SS)ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.');
            }
        });

        clearBtn.addEventListener('click', () => {
            curriculumInput.value = '';
            chapters = [];
            currentChapterIndex = 0;
            activeChapterName = '';
            clearChapterTimers();
            renderChapters();
            updateStatus('ready', 'ì¤€ë¹„ë¨ - ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”');
        });

        playbackSpeed.addEventListener('change', () => {
            renderChapters();
        });

        // GitHub APIë¥¼ ì‚¬ìš©í•˜ì—¬ ë§ˆì§€ë§‰ ì»¤ë°‹ ë‚ ì§œ ê°€ì ¸ì˜¤ê¸°
        async function updateLastUpdateDate() {
            const owner = 'Goldloom';
            const repo = 'audio-recorder';
            const path = 'index.html';
            const url = `https://api.github.com/repos/${owner}/${repo}/commits?path=${path}&page=1&per_page=1`;

            try {
                const response = await fetch(url);
                const commits = await response.json();
                if (commits && commits.length > 0) {
                    const lastCommitDate = new Date(commits[0].commit.committer.date);
                    const formattedDate = lastCommitDate.getFullYear() + '-' +
                        String(lastCommitDate.getMonth() + 1).padStart(2, '0') + '-' +
                        String(lastCommitDate.getDate()).padStart(2, '0') + ' ' +
                        String(lastCommitDate.getHours()).padStart(2, '0') + ':' +
                        String(lastCommitDate.getMinutes()).padStart(2, '0');
                    document.getElementById('lastUpdate').textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${formattedDate}`;
                }
            } catch (error) {
                console.error('ì—…ë°ì´íŠ¸ ë‚ ì§œë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:', error);
            }
        }

        updateLastUpdateDate();
        drawVisualizer();

        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            updateStatus('error', 'âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome ë˜ëŠ” Edgeë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.');
            recordBtn.disabled = true;
        }
    </script>

</body>

</html>