<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:; media-src 'self' blob:; connect-src 'self' https://api.github.com;">
    <title>ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ë…¹ìŒê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            position: relative;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 24px;
            padding: 40px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
        }

        h1 {
            text-align: center;
            color: #1a1a2e;
            margin-bottom: 8px;
            font-size: 28px;
            font-weight: 600;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
            font-size: 14px;
        }

        .format-badge {
            text-align: center;
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block;
            margin: 0 auto 20px;
            width: fit-content;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .help-icon {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: help;
        }

        .help-icon:hover .tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .tooltip {
            position: absolute;
            top: 35px;
            right: 0;
            background: #1a1a2e;
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            line-height: 1.6;
            width: 280px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .tooltip strong {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .tooltip ol {
            margin-left: 18px;
            padding: 0;
        }

        .tooltip li {
            margin-bottom: 4px;
        }

        .source-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        .source-btn {
            flex: 1;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .source-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .source-btn.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .source-btn .icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .source-btn .label {
            font-size: 13px;
            font-weight: 600;
        }

        .source-btn .desc {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 3px;
        }

        .visualizer-container {
            background: #1a1a2e;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 25px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #visualizer {
            width: 100%;
            height: 60px;
        }

        .timer {
            text-align: center;
            font-size: 48px;
            font-weight: 300;
            color: #1a1a2e;
            margin-bottom: 25px;
            font-family: 'Courier New', monospace;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-record {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .btn-record.recording {
            animation: pulse 1.5s infinite;
        }

        .btn-stop {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .btn-pause {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        @keyframes pulse {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7);
            }

            50% {
                box-shadow: 0 0 0 20px rgba(231, 76, 60, 0);
            }
        }

        .btn svg {
            width: 28px;
            height: 28px;
            fill: white;
        }

        .status {
            text-align: center;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .status.ready {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status.recording {
            background: #ffebee;
            color: #c62828;
        }

        .status.paused {
            background: #fff8e1;
            color: #f57f17;
        }

        .status.error {
            background: #fce4ec;
            color: #c2185b;
        }

        .recordings {
            max-height: 300px;
            overflow-y: auto;
        }

        .recordings h2 {
            color: #1a1a2e;
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .recordings-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-download-all {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-download-all:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        .btn-download-all:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recording-item {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .recording-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .recording-info {
            flex: 1;
        }

        .recording-name {
            font-weight: 600;
            color: #1a1a2e;
            font-size: 14px;
        }

        .recording-meta {
            font-size: 12px;
            color: #888;
            margin-top: 3px;
        }

        .recording-badge {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 20px;
            font-weight: 600;
        }

        .badge-system {
            background: #e3f2fd;
            color: #1565c0;
        }

        .badge-mic {
            background: #fce4ec;
            color: #c2185b;
        }

        .badge-both {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .recording-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .btn-small:hover {
            transform: scale(1.1);
        }

        .btn-small svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        .btn-download {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .btn-delete {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .recording-item audio {
            width: 100%;
            height: 40px;
            border-radius: 8px;
        }

        .empty-state {
            text-align: center;
            color: #888;
            padding: 30px;
            font-size: 14px;
        }

        /* ë¡œê·¸ ì°½ ìŠ¤íƒ€ì¼ */
        .log-panel {
            margin-top: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
        }

        /* ìë™í™” ì„¤ì • ê·¸ë£¹ ìŠ¤íƒ€ì¼ */
        .settings-group {
            margin-top: 20px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid #dee2e6;
        }

        .settings-title {
            color: #1a1a2e;
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
            font-weight: 600;
        }

        .settings-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .settings-content .toggle-container {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            transition: all 0.2s ease;
        }

        .settings-content .toggle-container:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
        }

        .log-panel h2 {
            color: #1a1a2e;
            font-size: 16px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .log-controls {
            display: flex;
            gap: 8px;
        }

        .btn-clear-log {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-clear-log:hover {
            background: #c0392b;
        }

        .btn-export-log {
            background: #3498db;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-export-log:hover {
            background: #2980b9;
        }

        .log-container {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 12px;
            max-height: 250px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            line-height: 1.6;
        }

        .log-container::-webkit-scrollbar {
            width: 8px;
        }

        .log-container::-webkit-scrollbar-track {
            background: #2c2c3e;
            border-radius: 4px;
        }

        .log-container::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .log-container::-webkit-scrollbar-thumb:hover {
            background: #764ba2;
        }

        .log-entry {
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.03);
        }

        .log-entry.log-info {
            color: #5dade2;
        }

        .log-entry.log-success {
            color: #52c41a;
        }

        .log-entry.log-warning {
            color: #faad14;
        }

        .log-entry.log-error {
            color: #ff4d4f;
        }

        .log-timestamp {
            color: #888;
            margin-right: 8px;
        }

        .log-message {
            color: inherit;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-item input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }

        .extra-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn-new-lecture {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-new-lecture:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }

        .btn-new-lecture:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 10px;
        }

        .toggle-label {
            font-size: 13px;
            color: #333;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked+.toggle-slider {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .toggle-switch input:checked+.toggle-slider:before {
            transform: translateX(24px);
        }

        .silence-indicator {
            font-size: 11px;
            color: #888;
            margin-left: 5px;
        }

        .silence-indicator.active {
            color: #27ae60;
            font-weight: 600;
        }

        .capture-section {
            background: #fff3e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .capture-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .capture-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .capture-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .capture-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }

        .capture-option select {
            padding: 5px 8px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 12px;
            cursor: pointer;
            background: white;
        }

        .capture-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .capture-status {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .capture-status.active {
            color: #e65100;
            font-weight: 500;
        }

        .sensitivity-slider {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 10px;
        }

        .sensitivity-slider input[type="range"] {
            width: 100px;
            cursor: pointer;
        }

        .sensitivity-value {
            font-size: 12px;
            color: #666;
            min-width: 30px;
        }

        .curriculum-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
        }

        .curriculum-help {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .curriculum-help-icon {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
        }

        .curriculum-help-icon:hover+.curriculum-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .curriculum-tooltip {
            position: absolute;
            top: 25px;
            left: 0;
            background: #1a1a2e;
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            line-height: 1.7;
            width: 320px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .curriculum-tooltip strong {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #f093fb;
        }

        .curriculum-tooltip code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        .curriculum-tooltip ul {
            margin: 8px 0;
            padding-left: 18px;
        }

        .curriculum-tooltip li {
            margin-bottom: 4px;
        }

        .curriculum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .curriculum-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .speed-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-selector label {
            font-size: 13px;
            color: #555;
        }

        .speed-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 13px;
            cursor: pointer;
            background: white;
        }

        .curriculum-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            margin-bottom: 10px;
        }

        .curriculum-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .curriculum-textarea::placeholder {
            color: #aaa;
        }

        .btn-parse {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-parse:hover {
            transform: scale(1.02);
        }

        .chapter-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .chapter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .chapter-item.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .chapter-item.completed {
            background: #d4edda;
            color: #155724;
        }

        .chapter-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 10px;
        }

        .chapter-time {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            opacity: 0.8;
        }

        .chapter-progress {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .clear-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
        }

        .clear-btn:hover {
            background: #c0392b;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 12px 15px;
            border-radius: 10px;
            font-size: 12px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .update-date {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 11px;
            color: #999;
            font-family: inherit;
        }

        /* í”„ë¡œê·¸ë ˆìŠ¤ ë°” ìŠ¤íƒ€ì¼ */
        .progress-section {
            margin-bottom: 25px;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .progress-container {
            width: 100%;
            height: 10px;
            background: #eee;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-bar.waiting {
            width: 100%;
            background: linear-gradient(90deg, #eee 0%, #667eea 50%, #eee 100%);
            background-size: 200% 100%;
            animation: waiting-shimmer 1.5s infinite linear;
        }

        @keyframes waiting-shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="lastUpdate" class="update-date">ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: í™•ì¸ ì¤‘...</div>
        <h1>ğŸ§ ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ë…¹ìŒê¸°</h1>


        <div class="help-icon">
            ?
            <div class="tooltip">
                <strong>ğŸ“Œ ì‚¬ìš© ë°©ë²•</strong>
                <ol>
                    <li>ë…¹ìŒ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</li>
                    <li>ê³µìœ  ì°½ì—ì„œ <strong>"Chrome íƒ­"</strong> ë˜ëŠ” <strong>"ì „ì²´ í™”ë©´"</strong> ì„ íƒ</li>
                    <li><strong>"ì˜¤ë””ì˜¤ ê³µìœ "</strong> ì²´í¬ âœ…</li>
                    <li>ê³µìœ  ë²„íŠ¼ í´ë¦­ í›„ ë…¹ìŒ ì‹œì‘!</li>
                </ol>
                <hr style="margin: 12px 0; border: none; border-top: 1px solid rgba(255,255,255,0.2);">
                <strong>âš ï¸ ë¸Œë¼ìš°ì € í˜¸í™˜ì„±</strong>
                <p style="margin-top: 6px; font-size: 11px; line-height: 1.5;">
                    <strong>Chrome, Edge</strong>ì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤.<br>
                    Firefox, SafariëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                </p>
            </div>
        </div>


        <div class="checkbox-group">
            <div class="checkbox-item">
                <input type="checkbox" id="includeSystemAudio" checked>
                <label for="includeSystemAudio">ğŸ”Š ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤</label>
            </div>
            <div class="checkbox-item">
                <input type="checkbox" id="includeMic">
                <label for="includeMic">ğŸ¤ ë§ˆì´í¬ (ë‚´ ëª©ì†Œë¦¬)</label>
            </div>
        </div>

        <div id="status" class="status ready">ì¤€ë¹„ë¨ - ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”</div>

        <div class="extra-controls">
            <button id="newLectureBtn" class="btn-new-lecture" title="í˜„ì¬ ë…¹ìŒì„ ì €ì¥í•˜ê³  ì¦‰ì‹œ ìƒˆë¡œìš´ ê°•ì˜ ë…¹ìŒì„ ì‹œì‘í•©ë‹ˆë‹¤">
                <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: white;">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                </svg>
                ìƒˆ ê°•ì˜ ì‹œì‘ (ìˆ˜ë™ ë¶„í• )
            </button>
        </div>

        <div class="curriculum-section">
            <div class="curriculum-header">
                <span class="curriculum-title">
                    <span class="curriculum-help">
                        ğŸ“‹ ê°•ì˜ ëª©ì°¨ (ì„ íƒì‚¬í•­)
                        <span class="curriculum-help-icon">?</span>
                        <div class="curriculum-tooltip">
                            <strong>ğŸ“Œ ëª©ì°¨ ì…ë ¥ ë°©ë²•</strong>
                            ê°•ì˜ ì‚¬ì´íŠ¸ì—ì„œ ëª©ì°¨ë¥¼ ë³µì‚¬í•´ì„œ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.
                            <ul>
                                <li><code>55</code> â†’ ê°•ì˜ ë²ˆí˜¸</li>
                                <li><code>Part 4. Advanced</code> â†’ íŒŒíŠ¸ëª…</li>
                                <li><code>Ch01. ì œëª©</code> â†’ ì±•í„°ëª… (ì‹œê°„ ì—†ìŒ)</li>
                                <li><code>CH01-1. ì œëª© 7:58</code> â†’ ì†Œì±•í„° (ì‹œê°„ í•„ìˆ˜)</li>
                            </ul>
                            <strong>ğŸ’¾ ì €ì¥ë˜ëŠ” íŒŒì¼ëª… ì˜ˆì‹œ</strong>
                            <code>55 Part 4 - Ch01 - CH01-1. ì œëª©.webm</code>
                            <br><br>
                            â© ë°°ì† ì„¤ì •í•˜ë©´ ìë™ìœ¼ë¡œ ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚°ë¨
                        </div>
                    </span>
                </span>
                <div class="speed-selector">
                    <label for="playbackSpeed">ì¬ìƒ ë°°ì†:</label>
                    <select id="playbackSpeed">
                        <option value="1">1ë°°ì†</option>
                        <option value="1.25">1.25ë°°ì†</option>
                        <option value="1.5">1.5ë°°ì†</option>
                        <option value="1.75">1.75ë°°ì†</option>
                        <option value="2" selected>2ë°°ì†</option>
                        <option value="2.5">2.5ë°°ì†</option>
                        <option value="3">3ë°°ì†</option>
                    </select>
                </div>
            </div>
            <textarea id="curriculumInput" class="curriculum-textarea" placeholder="ê°•ì˜ ëª©ì°¨ë¥¼ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”. ì˜ˆì‹œ:

001
Part 1. ê¸°ì´ˆí¸
Ch01. ì˜¤ë¦¬ì—”í…Œì´ì…˜
01. ê°•ì˜ ì†Œê°œ 5:00
02. í•™ìŠµ ë°©ë²• ì•ˆë‚´ 7:30"></textarea>
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <button class="btn-parse" id="parseBtn">ëª©ì°¨ ë¶„ì„</button>
                <button class="clear-btn" id="clearBtn">ì´ˆê¸°í™”</button>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;">
                    <input type="checkbox" id="autoStopCheckbox" checked style="width: 16px; height: 16px;">
                    ëª©ì°¨ ëë‚˜ë©´ ìë™ ì¢…ë£Œ
                </label>
            </div>
            <div id="chapterList" class="chapter-list"></div>
            <div id="chapterProgress" class="chapter-progress"></div>
        </div>

        <div class="visualizer-container">
            <canvas id="visualizer"></canvas>
        </div>

        <div class="progress-section" id="progressSection" style="display: none;">
            <div class="progress-info">
                <span id="progressElapsed">00:00:00</span>
                <span id="progressRemaining">ë‚¨ì€ ì‹œê°„: --:--:--</span>
            </div>
            <div class="progress-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
        </div>

        <div class="timer" id="timer">00:00:00</div>

        <div class="controls">
            <button class="btn btn-record" id="recordBtn" title="ë…¹ìŒ ì‹œì‘">
                <svg viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="8" />
                </svg>
            </button>
            <button class="btn btn-pause" id="pauseBtn" disabled title="ì¼ì‹œì •ì§€">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="4" width="4" height="16" />
                    <rect x="14" y="4" width="4" height="16" />
                </svg>
            </button>
            <button class="btn btn-stop" id="stopBtn" disabled title="ì •ì§€">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="6" width="12" height="12" />
                </svg>
            </button>
        </div>

        <div class="recordings">
            <h2>
                <span class="recordings-title">ğŸ“ ë…¹ìŒ íŒŒì¼</span>
                <button class="btn-download-all" id="downloadAllBtn" disabled>
                    â¬‡ï¸ ì „ì²´ ë‹¤ìš´ë¡œë“œ
                </button>
            </h2>
            <div id="recordingsList">
                <div class="empty-state">ë…¹ìŒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>
            </div>
        </div>

        <!-- ë¡œê·¸ íŒ¨ë„ -->
        <div class="log-panel">
            <h2>
                <span>ğŸ“‹ ì‹¤ì‹œê°„ ë¡œê·¸</span>
                <div class="log-controls">
                    <button class="btn-export-log" id="exportLogBtn" title="ë¡œê·¸ ë‚´ë³´ë‚´ê¸°">ğŸ“¥ ë‚´ë³´ë‚´ê¸°</button>
                    <button class="btn-clear-log" id="clearLogBtn" title="ë¡œê·¸ ì§€ìš°ê¸°">ğŸ—‘ï¸ ì§€ìš°ê¸°</button>
                </div>
            </h2>
            <div class="log-container" id="logContainer">
                <div class="log-entry log-info">
                    <span class="log-timestamp">[00:00:00]</span>
                    <span class="log-message">ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ</span>
                </div>
            </div>
        </div>

        <!-- ìë™í™” ì„¤ì • ê·¸ë£¹ -->
        <div class="settings-group">
            <h2 class="settings-title">âš™ï¸ ìë™í™” ì„¤ì •</h2>
            <div class="settings-content">
                <div class="toggle-container">
                    <span class="toggle-label">ğŸ¬ ì†Œë¦¬ ê°ì§€ ì‹œ ìë™ ì‹œì‘</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="autoStartOnSound" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label"
                        title="ë¬´ìŒì´ ê°ì§€ë˜ë©´ ìë™ìœ¼ë¡œ ë…¹ìŒì„ ë¶„í• í•©ë‹ˆë‹¤.&#13;&#10;&#13;&#10;[ì¼ë°˜ ëª¨ë“œ]&#13;&#10;â€¢ ì„¤ì •í•œ ë¬´ìŒ ì‹œê°„ ê°ì§€ ì‹œ ì¦‰ì‹œ ìë™ ë¶„í• &#13;&#10;&#13;&#10;[ì±•í„° ëª¨ë“œ]&#13;&#10;â€¢ ì”ì—¬ ì‹œê°„ì— ë”°ë¼ ë¬´ìŒ ì¡°ê±´ ìë™ ì¡°ì • (í•˜ë‹¨ ì„¤ì • ì°¸ê³ )">ğŸ”‡ ë¬´ìŒ ê°ì§€ ìë™ë¶„í• </span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="silenceDetection" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <span id="silenceIndicator" class="silence-indicator"></span>
                </div>
                <div class="toggle-container" style="margin-left: 20px; font-size: 12px;">
                    <span style="color: #666;" title="ì±•í„° ëª¨ë“œì—ì„œ ì”ì—¬ ì‹œê°„ì— ë”°ë¼ ìë™ ì¡°ì •ë©ë‹ˆë‹¤.&#13;&#10;â€¢ ì”ì—¬ â‰¤ 5ì´ˆ (0ì´ˆ í¬í•¨): ë¬´ìŒ ì¡°ê±´ 1ì´ˆ&#13;&#10;â€¢ ì”ì—¬ 5~10ì´ˆ: ë¬´ìŒ ì¡°ê±´ 1.5ì´ˆ&#13;&#10;â€¢ ì”ì—¬ > 10ì´ˆ: ë¶„í•  ì•ˆí•¨">ì±•í„° ëª¨ë“œ ì”ì—¬ 5ì´ˆ ì´í•˜:</span>
                    <select id="chapterSilence5"
                        style="margin-left: 5px; padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                        <option value="500">0.5ì´ˆ</option>
                        <option value="1000" selected>1.0ì´ˆ</option>
                        <option value="1500">1.5ì´ˆ</option>
                        <option value="2000">2.0ì´ˆ</option>
                    </select>
                    <span style="color: #666; margin-left: 10px;">ì”ì—¬ 5~10ì´ˆ:</span>
                    <select id="chapterSilence10"
                        style="margin-left: 5px; padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                        <option value="1000">1.0ì´ˆ</option>
                        <option value="1500" selected>1.5ì´ˆ</option>
                        <option value="2000">2.0ì´ˆ</option>
                        <option value="2500">2.5ì´ˆ</option>
                    </select>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label"
                        title="ë™ì˜ìƒ ì „í™˜ì„ ìë™ìœ¼ë¡œ ê°ì§€í•˜ì—¬ ì±•í„°ë¥¼ ë¶„í• í•©ë‹ˆë‹¤.&#13;&#10;&#13;&#10;ê°ì§€ ì¡°ê±´ (ì¤‘ë³µ ì„ íƒ ì‹œ AND ì¡°ê±´):&#13;&#10;â€¢ ê¸°ë³¸: í”½ì…€ ë³€í™”ìœ¨ + íˆìŠ¤í† ê·¸ë¨ ë¶„ì„&#13;&#10;â€¢ ëª¨ë“œ1: í•˜ì–€ ë°°ê²½ + ì¤‘ì•™ ë¡œê³  ê°ì§€&#13;&#10;â€¢ ëª¨ë“œ2: íŠ¹ì • ì´ë¯¸ì§€ í¬í•¨ ì—¬ë¶€ ê°ì§€">ğŸ¬
                        í™”ë©´ ì „í™˜ ìë™ê°ì§€ (ëª©ì°¨ìš©)</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="sceneChangeDetection">
                        <span class="toggle-slider"></span>
                    </label>
                    <div style="display: flex; gap: 15px; align-items: center; margin-top: 8px; flex-wrap: wrap;">
                        <!-- ê°ì§€ ì¡°ê±´ ì²´í¬ë°•ìŠ¤ë“¤ -->
                        <div style="display: flex; gap: 12px; align-items: center;">
                            <label
                                style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;"
                                title="í”½ì…€ ë³€í™”ìœ¨ + íˆìŠ¤í† ê·¸ë¨(ìƒ‰ìƒ ë¶„í¬) ë¶„ì„&#13;&#10;â€¢ 160x90ìœ¼ë¡œ ìƒ˜í”Œë§í•˜ì—¬ í”½ì…€ ë‹¨ìœ„ ë¹„êµ&#13;&#10;â€¢ 15% ì´ìƒ ë³€í™” ì‹œ ì¥ë©´ ì „í™˜ ê°ì§€&#13;&#10;â€¢ ì—°ì† 3í”„ë ˆì„ ë³€í™” ì¶”ì &#13;&#10;â€¢ 3ì´ˆ ì¿¨ë‹¤ìš´ìœ¼ë¡œ ì˜¤ê°ì§€ ë°©ì§€">
                                <input type="checkbox" id="detectBasic" checked style="cursor: pointer;">
                                <span>ê¸°ë³¸ (í”½ì…€+ìƒ‰ìƒ)</span>
                            </label>
                            <label
                                style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;"
                                title="í•˜ì–€ ë°°ê²½ + ì¤‘ì•™ ë¡œê³  íŒ¨í„´ ê°ì§€&#13;&#10;â€¢ í™”ë©´ì˜ 70% ì´ìƒì´ í•˜ì–€ìƒ‰ (ë°ê¸° 200 ì´ìƒ)&#13;&#10;â€¢ ì¤‘ì•™ 20% ì˜ì—­ì— 10% ì´ìƒ ì–´ë‘ìš´ ë¶€ë¶„ (ë¡œê³ )&#13;&#10;â€¢ ê°•ì˜ ì „í™˜ ì‹œ ë‚˜íƒ€ë‚˜ëŠ” ì¸íŠ¸ë¡œ í™”ë©´ ê°ì§€ì— ìœ ìš©">
                                <input type="checkbox" id="detectMode1" style="cursor: pointer;">
                                <span>ëª¨ë“œ1 (í•˜ì–€ë°°ê²½)</span>
                            </label>
                            <label
                                style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;"
                                title="ì—…ë¡œë“œí•œ íŠ¹ì • ì´ë¯¸ì§€ í¬í•¨ ì—¬ë¶€ ê°ì§€&#13;&#10;â€¢ ì•„ë˜ 'ğŸ“ ê°ì§€ìš© ì´ë¯¸ì§€ ì—…ë¡œë“œ' ë²„íŠ¼ìœ¼ë¡œ ì°¸ì¡° ì´ë¯¸ì§€ ë“±ë¡&#13;&#10;â€¢ í˜„ì¬ í™”ë©´ê³¼ 70% ì´ìƒ ìœ ì‚¬í•˜ë©´ ë§¤ì¹­ ì„±ê³µ&#13;&#10;â€¢ íŠ¹ì • ìŠ¬ë¼ì´ë“œë‚˜ í™”ë©´ì´ ë‚˜íƒ€ë‚  ë•Œ ì „í™˜í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©">
                                <input type="checkbox" id="detectMode2" style="cursor: pointer;">
                                <span>ëª¨ë“œ2 (ì´ë¯¸ì§€ë§¤ì¹­)</span>
                            </label>
                            <label
                                style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;"
                                title="4ì´ˆ ì´ìƒ ë¬´ìŒ ê°ì§€&#13;&#10;â€¢ ì˜¤ë””ì˜¤ ë ˆë²¨ì´ ì„ê³„ê°’ ë¯¸ë§Œìœ¼ë¡œ 4ì´ˆ ì§€ì† ì‹œ ê°ì§€&#13;&#10;â€¢ ê°•ì˜ ì „í™˜ ì‹œ ë¬´ìŒ êµ¬ê°„ì´ ìˆì„ ë•Œ ìœ ìš©&#13;&#10;â€¢ ë‹¤ë¥¸ ì¡°ê±´ê³¼ ì¡°í•©í•˜ì—¬ ì •í™•ë„ í–¥ìƒ">
                                <input type="checkbox" id="detectMode3" style="cursor: pointer;">
                                <span>ëª¨ë“œ3 (4ì´ˆë¬´ìŒ)</span>
                            </label>
                        </div>
                        <div class="sensitivity-slider">
                            <span style="font-size: 11px; color: #666;">ë¯¼ê°ë„:</span>
                            <input type="range" id="sceneChangeSensitivity" min="5" max="30" value="15" step="1">
                            <span class="sensitivity-value" id="sensitivityValue">15%</span>
                        </div>
                    </div>
                    <!-- ëª¨ë“œ2 ì „ìš©: ì´ë¯¸ì§€ ì—…ë¡œë“œ -->
                    <div id="mode2ImageUpload" style="padding-left: 30px; margin-top: 8px; display: none;">
                        <input type="file" id="mode2ImageInput" accept="image/*" style="display: none;">
                        <button id="uploadMode2ImageBtn"
                            style="padding: 4px 12px; border-radius: 4px; border: 1px solid #ddd; background: white; cursor: pointer; font-size: 12px;">
                            ğŸ“ ê°ì§€ìš© ì´ë¯¸ì§€ ì—…ë¡œë“œ
                        </button>
                        <span id="mode2ImageStatus" style="font-size: 11px; color: #666; margin-left: 8px;"></span>
                    </div>
                </div>
                <div class="toggle-container" style="padding-left: 30px; margin-top: -10px;">
                    <label
                        style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: #666; cursor: pointer;"
                        title="ì²´í¬ ì‹œ: ë¬´ìŒ 4.5ì´ˆ + í™”ë©´ ì „í™˜ ëª¨ë‘ ë§Œì¡±í•´ì•¼ ë¶„í•  (ì •ë°€, ê°•ì˜ ì „í™˜ êµ¬ê°„ ì •í™• ê°ì§€)&#13;&#10;ì²´í¬ ì•ˆ í•¨: í™”ë©´ ì „í™˜ë§Œìœ¼ë¡œ ì¦‰ì‹œ ë¶„í•  (ë¹ ë¦„, ê¸°ë³¸ê°’)">
                        <input type="checkbox" id="requireSilenceForSceneChange"
                            style="width: 16px; height: 16px; cursor: pointer;">
                        <span>ë¬´ìŒ 4.5ì´ˆ + í™”ë©´ ì „í™˜ ì¡°ê±´ (AND)</span>
                    </label>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label"
                        title="ì—…ë¡œë“œí•œ ì´ë¯¸ì§€ì™€ í™”ë©´ì„ ì‹¤ì‹œê°„ ë¹„êµí•˜ì—¬ ìë™ ë¶„í• í•©ë‹ˆë‹¤.&#13;&#10;ì˜ˆìƒ ë…¹ìŒ ì‹œê°„ ê²½ê³¼ í›„ ìµœëŒ€ 20ì´ˆê¹Œì§€ í…œí”Œë¦¿ ë§¤ì¹­ì„ ëŒ€ê¸°í•˜ë©°,&#13;&#10;20ì´ˆ ë‚´ì— ë§¤ì¹­ë˜ì§€ ì•Šìœ¼ë©´ ìë™ìœ¼ë¡œ ë‹¤ìŒ ë…¹ìŒìœ¼ë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.">ğŸ–¼ï¸
                        í…œí”Œë¦¿ ë§¤ì¹­ ìë™ë¶„í• </span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="templateMatching">
                        <span class="toggle-slider"></span>
                    </label>
                    <div style="margin-left: 10px; display: flex; gap: 10px; align-items: center;">
                        <input type="file" id="templateImageInput" accept="image/*" style="display: none;">
                        <button id="uploadTemplateBtn"
                            style="padding: 4px 12px; border-radius: 4px; border: 1px solid #ddd; background: white; cursor: pointer; font-size: 12px;">
                            ğŸ“ ì´ë¯¸ì§€ ì—…ë¡œë“œ
                        </button>
                        <span id="templateStatus" style="font-size: 11px; color: #666;"></span>
                        <div class="sensitivity-slider" style="margin-left: auto;">
                            <span style="font-size: 11px; color: #666;">ìœ ì‚¬ë„:</span>
                            <input type="range" id="templateSimilarity" min="70" max="99" value="99" step="1">
                            <span class="sensitivity-value" id="similarityValue">99%</span>
                        </div>
                    </div>
                </div>
                <div class="toggle-container">
                    <span class="toggle-label">ğŸ“¸ ì´ë¯¸ì§€ìº¡ì²˜(WebP->PDF)</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="captureEnabled" checked>
                        <span class="toggle-slider"></span>
                    </label>
                    <div style="margin-left: 10px; display: flex; gap: 15px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label for="captureInterval" style="font-size: 12px; color: #666;">ê°„ê²©:</label>
                            <select id="captureInterval"
                                style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                                <option value="1">1ì´ˆ</option>
                                <option value="2">2ì´ˆ</option>
                                <option value="5" selected>5ì´ˆ</option>
                                <option value="10">10ì´ˆ</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <label for="captureQuality" style="font-size: 12px; color: #666;">í’ˆì§ˆ:</label>
                            <select id="captureQuality"
                                style="padding: 4px 8px; border-radius: 4px; border: 1px solid #ddd; font-size: 12px;">
                                <option value="0.9">ê³ í™”ì§ˆ</option>
                                <option value="0.7" selected>ì¤‘í™”ì§ˆ</option>
                                <option value="0.5">ì €í™”ì§ˆ</option>
                            </select>
                        </div>
                        <span id="captureStatus" style="font-size: 11px; color: #666;"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let recordings = [];
        let startTime;
        let timerInterval;
        let isPaused = false;
        let isRecording = false; // ì¶”ê°€: ë…¹ìŒ ì§„í–‰ ì—¬ë¶€ í”Œë˜ê·¸
        let isWaitingForFirstSound = false; // ì¶”ê°€: ì²« ì†Œë¦¬ ëŒ€ê¸° ì—¬ë¶€
        let pausedTime = 0;
        let recordingStartTime = null; // í˜„ì¬ ë…¹ìŒ ì„¸ì…˜ì˜ ì‹¤ì œ ì‹œì‘ ì‹œê°„
        let audioContext;
        let analyser;
        let dataArray;
        let animationId;
        let streams = [];
        let currentMimeType = ''; // ì¶”ê°€: ì‹¤ì œ ì‚¬ìš© ì¤‘ì¸ ë…¹ìŒ í˜•ì‹
        let currentRecordingType = ''; // ì¶”ê°€: ë…¹ìŒ ì†ŒìŠ¤ íƒ€ì… (system, mic, both)
        let silenceStart = null;
        let silenceThreshold = 30; // ë³¼ë¥¨ ì„ê³„ê°’ (0-255) - ì´ ê°’ë³´ë‹¤ ë‚®ìœ¼ë©´ ë¬´ìŒìœ¼ë¡œ íŒë‹¨
        let silenceDuration = 5000; // 5ì´ˆ ë¬´ìŒ ì‹œ ë¶„í•  (ê¸°ë³¸ê°’)
        let lastLoggedSecond = -1; // ë§ˆì§€ë§‰ ë¡œê·¸ ì¶œë ¥ëœ ì´ˆ (ì¤‘ë³µ ë°©ì§€)
        let lectureCount = 1;

        const recordBtn = document.getElementById('recordBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timerDisplay = document.getElementById('timer');
        const recordingsList = document.getElementById('recordingsList');
        const statusDisplay = document.getElementById('status');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        const includeSystemAudio = document.getElementById('includeSystemAudio');
        const includeMic = document.getElementById('includeMic');
        const autoStartOnSound = document.getElementById('autoStartOnSound'); // ì¶”ê°€
        const silenceDetection = document.getElementById('silenceDetection');
        const chapterSilence5 = document.getElementById('chapterSilence5'); // ì±•í„° ëª¨ë“œ ì”ì—¬ 5ì´ˆ ì´í•˜
        const chapterSilence10 = document.getElementById('chapterSilence10'); // ì±•í„° ëª¨ë“œ ì”ì—¬ 5~10ì´ˆ
        const silenceIndicator = document.getElementById('silenceIndicator');
        const sceneChangeDetectionToggle = document.getElementById('sceneChangeDetection');
        const sceneChangeSensitivity = document.getElementById('sceneChangeSensitivity');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const detectBasic = document.getElementById('detectBasic');
        const detectMode1 = document.getElementById('detectMode1');
        const detectMode2 = document.getElementById('detectMode2');
        const detectMode3 = document.getElementById('detectMode3');
        const mode2ImageUpload = document.getElementById('mode2ImageUpload');
        const mode2ImageInput = document.getElementById('mode2ImageInput');
        const uploadMode2ImageBtn = document.getElementById('uploadMode2ImageBtn');
        const mode2ImageStatus = document.getElementById('mode2ImageStatus');
        const requireSilenceForSceneChange = document.getElementById('requireSilenceForSceneChange');
        const templateMatchingToggle = document.getElementById('templateMatching');
        const templateImageInput = document.getElementById('templateImageInput');
        const uploadTemplateBtn = document.getElementById('uploadTemplateBtn');
        const templateStatus = document.getElementById('templateStatus');
        const templateSimilarity = document.getElementById('templateSimilarity');
        const similarityValue = document.getElementById('similarityValue');
        const newLectureBtn = document.getElementById('newLectureBtn');
        const curriculumInput = document.getElementById('curriculumInput');
        const parseBtn = document.getElementById('parseBtn');
        const clearBtn = document.getElementById('clearBtn');
        const chapterList = document.getElementById('chapterList');
        const logContainer = document.getElementById('logContainer');
        const clearLogBtn = document.getElementById('clearLogBtn');
        const exportLogBtn = document.getElementById('exportLogBtn');
        const chapterProgress = document.getElementById('chapterProgress');
        const playbackSpeed = document.getElementById('playbackSpeed');
        const autoStopCheckbox = document.getElementById('autoStopCheckbox');
        const captureEnabled = document.getElementById('captureEnabled');
        const captureInterval = document.getElementById('captureInterval');
        const captureQuality = document.getElementById('captureQuality');
        const captureStatus = document.getElementById('captureStatus');
        const downloadAllBtn = document.getElementById('downloadAllBtn');
        const progressBar = document.getElementById('progressBar');
        const progressElapsed = document.getElementById('progressElapsed');
        const progressRemaining = document.getElementById('progressRemaining');
        const progressSection = document.getElementById('progressSection');

        let chapters = [];
        let currentChapterIndex = 0;
        let chapterStartTime = 0;
        let chapterTimers = [];

        // ìº¡ì²˜ ê´€ë ¨ ë³€ìˆ˜
        let captureTimer = null;
        let capturedImages = [];
        let captureCount = 0;
        let videoStream = null;
        let videoElement = null;

        // ë¶„í•  ëŒ€ê¸° ìƒíƒœ ë³€ìˆ˜ë“¤
        let chapterReadyToSplit = false;
        let waitingForSilence = false;
        let pendingSplitChapterIndex = -1;
        let readyToAutoStop = false;
        let silenceStartForSplit = null;
        let silenceWaitStartTime = null; // âœ… ì±•í„° ì¢…ë£Œ ëŒ€ê¸° ì‹œì‘ ì‹œê°„
        const silenceDurationForSplit = 2000; // âœ… 2ì´ˆ ë¬´ìŒ (ê¸°ì¡´ 3000ms â†’ 2000ms)

        // âœ… í˜„ì¬ ë…¹ìŒ ì¤‘ì¸ ì±•í„° ì´ë¦„
        let activeChapterName = '';

        // í™”ë©´ ë³€í™” ê°ì§€ ë³€ìˆ˜ë“¤
        let sceneChangeDetector = null;
        let lastFrameData = null;
        let sceneChangeCheckInterval = null;
        let detectedSceneChange = false;
        let sceneChangeTime = null;
        let frameBeforeSilence = null; // âœ… ë¬´ìŒ ì‹œì‘ ì§ì „ í™”ë©´ ì €ì¥

        // í…œí”Œë¦¿ ë§¤ì¹­ ë³€ìˆ˜ë“¤
        let templateImage = null; // í…œí”Œë¦¿ ì´ë¯¸ì§€ ë°ì´í„°
        let templateMatcher = null;
        let templateCheckInterval = null;

        function updateStatus(state, message) {
            statusDisplay.className = 'status ' + state;
            statusDisplay.textContent = message;
        }

        // ============ ë¡œê·¸ ì‹œìŠ¤í…œ ============
        let logEntries = [];

        function addLog(message, type = 'info') {
            const now = new Date();
            const timestamp = now.toLocaleTimeString('ko-KR', { hour12: false });
            const logEntry = {
                timestamp,
                message,
                type,
                fullTime: now
            };

            logEntries.push(logEntry);

            // ë¡œê·¸ ì—”íŠ¸ë¦¬ ìƒì„±
            const logDiv = document.createElement('div');
            logDiv.className = `log-entry log-${type}`;
            logDiv.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span>
                <span class="log-message">${message}</span>
            `;

            logContainer.appendChild(logDiv);

            // ìë™ ìŠ¤í¬ë¡¤ (ìµœì‹  ë¡œê·¸ê°€ ë³´ì´ë„ë¡)
            logContainer.scrollTop = logContainer.scrollHeight;

            // ì½˜ì†”ì—ë„ ì¶œë ¥
            console.log(`[${type.toUpperCase()}] ${timestamp} - ${message}`);
        }

        function clearLog() {
            logEntries = [];
            logContainer.innerHTML = '<div class="log-entry log-info"><span class="log-timestamp">[' +
                new Date().toLocaleTimeString('ko-KR', { hour12: false }) +
                ']</span><span class="log-message">ë¡œê·¸ê°€ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤</span></div>';
        }

        function exportLog() {
            if (logEntries.length === 0) {
                alert('ë‚´ë³´ë‚¼ ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const logText = logEntries.map(entry =>
                `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}`
            ).join('\n');

            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `recording-log-${new Date().toISOString().replace(/:/g, '-').slice(0, 19)}.txt`;
            a.click();
            URL.revokeObjectURL(url);

            addLog('ë¡œê·¸ë¥¼ íŒŒì¼ë¡œ ë‚´ë³´ëƒˆìŠµë‹ˆë‹¤', 'success');
        }

        // ë¡œê·¸ ë²„íŠ¼ ì´ë²¤íŠ¸
        clearLogBtn.addEventListener('click', clearLog);
        exportLogBtn.addEventListener('click', exportLog);

        // ============ ë¡œê·¸ ì‹œìŠ¤í…œ ë ============

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            if (isWaitingForFirstSound) {
                timerDisplay.textContent = 'ëŒ€ê¸° ì¤‘...';
                progressBar.className = 'progress-bar waiting';
                progressBar.style.width = '100%';
                progressElapsed.textContent = 'ì†Œë¦¬ ëŒ€ê¸° ì¤‘';
                progressRemaining.textContent = '';
                return;
            }

            if (isRecording && !isPaused) {
                const elapsedMs = Date.now() - startTime + pausedTime;
                const timeStr = formatTime(elapsedMs);
                timerDisplay.textContent = timeStr;
                progressElapsed.textContent = timeStr;

                // í”„ë¡œê·¸ë ˆìŠ¤ ë°” ì—…ë°ì´íŠ¸
                if (chapters.length > 0 && chapters[currentChapterIndex]) {
                    const durationMs = chapters[currentChapterIndex].duration * 1000;
                    const percent = Math.min((elapsedMs / durationMs) * 100, 100);
                    const remainingMs = Math.max(durationMs - elapsedMs, 0);

                    progressBar.className = 'progress-bar';
                    progressBar.style.width = `${percent}%`;
                    progressRemaining.textContent = `ë‚¨ì€ ì‹œê°„: ${formatTime(remainingMs)}`;
                } else {
                    // ëª©ì°¨ ì—†ì„ ë•Œ
                    progressBar.className = 'progress-bar';
                    progressBar.style.width = '100%';
                    progressRemaining.textContent = 'ì—°ì† ë…¹ìŒ ì¤‘';
                }
            }
        }

        function setupVisualizer() {
            if (audioContext) {
                audioContext.close().catch(() => { });
            }

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.8;

            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            streams.forEach(s => {
                if (s.getAudioTracks().length > 0) {
                    try {
                        const source = audioContext.createMediaStreamSource(s);
                        source.connect(analyser);
                    } catch (e) {
                        console.log('Stream already connected or invalid');
                    }
                }
            });

            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            drawVisualizer();
        }

        function drawVisualizer() {
            animationId = requestAnimationFrame(drawVisualizer);

            canvas.width = canvas.offsetWidth * 2;
            canvas.height = canvas.offsetHeight * 2;
            canvasCtx.scale(2, 2);

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            canvasCtx.fillStyle = '#1a1a2e';
            canvasCtx.fillRect(0, 0, width, height);

            if (!analyser || !dataArray) {
                canvasCtx.strokeStyle = '#667eea';
                canvasCtx.lineWidth = 2;
                canvasCtx.beginPath();
                canvasCtx.moveTo(0, height / 2);
                canvasCtx.lineTo(width, height / 2);
                canvasCtx.stroke();
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

            // âœ… ìµœì´ˆ ì†Œë¦¬ ê°ì§€ ëŒ€ê¸° ë¡œì§
            if (isWaitingForFirstSound) {
                if (average > silenceThreshold) {
                    actuallyStartRecording();
                } else {
                    // ëŒ€ê¸° ìƒíƒœ ì‹œê°ì  í”¼ë“œë°± (í•„ìš” ì‹œ)
                }
            }

            // (ê¸°ì¡´ ë¬´ìŒ ê°ì§€ ë¡œì§ ê·¸ëŒ€ë¡œ)
            // ë¬´ìŒ ê°ì§€ ìë™ë¶„í• : í™”ë©´ ì „í™˜ ëŒ€ê¸° ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ì‘ë™
            if (silenceDetection.checked && mediaRecorder && mediaRecorder.state === 'recording' && !waitingForSilence) {
                if (average < silenceThreshold) {
                    if (!silenceStart) {
                        silenceStart = Date.now();
                        lastLoggedSecond = -1; // ë¦¬ì…‹
                        console.log(`ğŸ”‡ [ë¬´ìŒ ê°ì§€] ë¬´ìŒ ì‹œì‘ (í‰ê·  ë ˆë²¨: ${average.toFixed(1)}, ì„ê³„ê°’: ${silenceThreshold})`);
                    } else {
                        const silentTime = Date.now() - silenceStart;
                        silenceIndicator.textContent = `(ë¬´ìŒ ${(silentTime / 1000).toFixed(1)}ì´ˆ)`;
                        silenceIndicator.className = 'silence-indicator active';

                        // 1.5ì´ˆ ì´ìƒì¼ ë•Œ ë¬´ì¡°ê±´ ë¡œê·¸ (ì½˜ì†” + UI)
                        const silentTimeSec = (silentTime / 1000).toFixed(1);
                        if (silentTime >= 1500) {
                            const targetSec = (silenceDuration / 1000).toFixed(1);

                            // ì”ì—¬ ì‹œê°„ ê³„ì‚°
                            let remainingInfo = '';
                            if (chapters.length > 0 && currentChapterIndex < chapters.length) {
                                const currentChapter = chapters[currentChapterIndex];
                                const expectedDuration = currentChapter.duration * 1000; // ì´ˆ â†’ ms
                                const elapsedTime = Date.now() - recordingStartTime;
                                const remainingTime = Math.max(0, expectedDuration - elapsedTime); // ìŒìˆ˜ë©´ 0ìœ¼ë¡œ
                                remainingInfo = `, ì”ì—¬: ${(remainingTime/1000).toFixed(1)}ì´ˆ`;
                            }

                            console.log(`ğŸ”‡ [ë¬´ìŒ ê°ì§€] ë¬´ìŒ ${silentTimeSec}ì´ˆ / ${targetSec}ì´ˆ (í‰ê·  ë ˆë²¨: ${average.toFixed(1)}, ì„ê³„ê°’: ${silenceThreshold}${remainingInfo})`);
                            addLog(`ğŸ”‡ [ë¬´ìŒ ê°ì§€] ${silentTimeSec}ì´ˆ / ${targetSec}ì´ˆ${remainingInfo}`, 'info');
                        }

                        // ì±•í„° ëª¨ë“œì¼ ë•Œ ì”ì—¬ ì‹œê°„ì— ë”°ë¼ ë¬´ìŒ ì¡°ê±´ ì„¸ë¶„í™”
                        let canSplit = false;
                        let remainingTime = null;
                        let requiredSilence = silenceDuration; // ê¸°ë³¸ê°’

                        if (chapters.length > 0 && currentChapterIndex < chapters.length) {
                            const currentChapter = chapters[currentChapterIndex];
                            const expectedDuration = currentChapter.duration * 1000; // ì´ˆ â†’ ms
                            const elapsedTime = Date.now() - recordingStartTime; // ì‹¤ì œ ê²½ê³¼ ì‹œê°„
                            remainingTime = Math.max(0, expectedDuration - elapsedTime); // ìŒìˆ˜ë©´ 0ìœ¼ë¡œ

                            // ì”ì—¬ ì‹œê°„ì— ë”°ë¥¸ ë¬´ìŒ ì¡°ê±´ (ì‚¬ìš©ì ì„¤ì •ê°’ ì‚¬ìš©)
                            if (remainingTime <= 5000) {
                                // ì”ì—¬ 5ì´ˆ ì´í•˜ (0ì´ˆ í¬í•¨): ì‚¬ìš©ì ì„¤ì • ê°’ ì‚¬ìš©
                                requiredSilence = parseInt(chapterSilence5.value);
                            } else if (remainingTime <= 10000) {
                                // ì”ì—¬ 5~10ì´ˆ (5ì´ˆ í¬í•¨): ì‚¬ìš©ì ì„¤ì • ê°’ ì‚¬ìš©
                                requiredSilence = parseInt(chapterSilence10.value);
                            } else {
                                // ì”ì—¬ 10ì´ˆ ì´ˆê³¼: ë¶„í•  ì•ˆí•¨
                                requiredSilence = Infinity;
                            }
                        } else {
                            // ì¼ë°˜ ëª¨ë“œ: ì„¤ì •ëœ ë¬´ìŒ ì‹œê°„ ì‚¬ìš©
                            requiredSilence = silenceDuration;
                        }

                        if (silentTime >= requiredSilence) {
                            if (remainingTime !== null && remainingTime >= 10000) {
                                // ì”ì—¬ ì‹œê°„ì´ 10ì´ˆ ì´ìƒì´ë©´ ë¶„í•  ì•ˆí•¨
                                canSplit = false;
                                console.log(`â¸ï¸ [ìë™ë¶„í•  ë³´ë¥˜] ì”ì—¬ ì˜ˆì • ì‹œê°„ 10ì´ˆ ì´ìƒ (ë¬´ìŒ: ${(silentTime/1000).toFixed(1)}ì´ˆ, ì”ì—¬: ${(remainingTime/1000).toFixed(1)}ì´ˆ)`);
                                addLog(`â¸ï¸ [ìë™ë¶„í•  ë³´ë¥˜] ì”ì—¬ ì‹œê°„ ${(remainingTime/1000).toFixed(1)}ì´ˆ (10ì´ˆ ë¯¸ë§Œì´ì–´ì•¼ í•¨)`, 'warning');
                            } else {
                                canSplit = true;
                                if (remainingTime !== null) {
                                    console.log(`âœ… [ìë™ë¶„í•  ê°€ëŠ¥] ì”ì—¬ ${(remainingTime/1000).toFixed(1)}ì´ˆ, ë¬´ìŒ ${(silentTime/1000).toFixed(1)}ì´ˆ â†’ ì¡°ê±´ ì¶©ì¡±`);
                                }
                            }

                            if (canSplit) {
                                console.log(`âœ… [ìë™ë¶„í•  ì‹¤ì‹œ] ë¬´ìŒ ${(silentTime/1000).toFixed(1)}ì´ˆ ê°ì§€ (í•„ìš”: ${(requiredSilence/1000).toFixed(1)}ì´ˆ) â†’ ìë™ ë¶„í•  ì‹¤í–‰`);

                                // UI ë¡œê·¸ì— ì”ì—¬ ì‹œê°„ í‘œì‹œ
                                if (remainingTime !== null) {
                                    addLog(`âœ… [ìë™ë¶„í•  ì‹¤ì‹œ] ë¬´ìŒ ${(silentTime/1000).toFixed(1)}ì´ˆ (ì”ì—¬: ${(remainingTime/1000).toFixed(1)}ì´ˆ)`, 'success');
                                } else {
                                    addLog(`âœ… [ìë™ë¶„í•  ì‹¤ì‹œ] ë¬´ìŒ ${(silentTime/1000).toFixed(1)}ì´ˆ`, 'success');
                                }

                                splitRecording();
                                silenceStart = null;
                                lastLoggedSecond = -1;
                                silenceIndicator.textContent = '(ìë™ ë¶„í• ë¨!)';
                            } else {
                                // ì”ì—¬ ì‹œê°„ì´ 10ì´ˆ ì´ìƒì´ë©´ ë¬´ìŒ íƒ€ì´ë¨¸ ë¦¬ì…‹
                                silenceStart = null;
                                lastLoggedSecond = -1;
                            }
                        }
                    }
                } else {
                    if (silenceStart) {
                        const interruptedTime = ((Date.now() - silenceStart) / 1000).toFixed(1);

                        // ì±•í„° ëª¨ë“œì¼ ë•Œ ì”ì—¬ ì‹œê°„ ê³„ì‚°
                        let remainingInfo = '';
                        if (chapters.length > 0 && currentChapterIndex < chapters.length) {
                            const currentChapter = chapters[currentChapterIndex];
                            const expectedDuration = currentChapter.duration * 1000; // ì´ˆ â†’ ms
                            const elapsedTime = Date.now() - recordingStartTime; // ì‹¤ì œ ê²½ê³¼ ì‹œê°„
                            const remainingTime = Math.max(0, expectedDuration - elapsedTime); // ìŒìˆ˜ë©´ 0ìœ¼ë¡œ
                            remainingInfo = `, ì”ì—¬: ${(remainingTime/1000).toFixed(1)}ì´ˆ`;
                        }

                        console.log(`âŒ [ë¬´ìŒ ê°ì§€] ë¬´ìŒ ì¤‘ë‹¨ (í‰ê·  ë ˆë²¨: ${average.toFixed(1)}, ì„ê³„ê°’: ${silenceThreshold}, ${interruptedTime}ì´ˆì—ì„œ ì¤‘ë‹¨${remainingInfo})`);

                        // 2.5ì´ˆ ì´ìƒ ë¬´ìŒì´ì—ˆì„ ë•Œë§Œ UI ë¡œê·¸ í‘œì‹œ (ì§§ì€ ì¤‘ë‹¨ì€ ë„ˆë¬´ ë§ì•„ì„œ ì œì™¸)
                        if (parseFloat(interruptedTime) >= 2.5) {
                            if (remainingInfo) {
                                addLog(`âŒ ë¬´ìŒ ì¤‘ë‹¨ (${interruptedTime}ì´ˆ${remainingInfo})`, 'warning');
                            } else {
                                addLog(`âŒ ë¬´ìŒ ì¤‘ë‹¨ (${interruptedTime}ì´ˆì—ì„œ ì†Œë¦¬ ê°ì§€)`, 'warning');
                            }
                        }
                    }
                    silenceStart = null;
                    lastLoggedSecond = -1; // ë¦¬ì…‹
                    silenceIndicator.textContent = '';
                    silenceIndicator.className = 'silence-indicator';
                }
            } else if (silenceDetection.checked && waitingForSilence) {
                // í™”ë©´ ì „í™˜ ëŒ€ê¸° ì¤‘ì¼ ë•ŒëŠ” ë¬´ìŒ ê°ì§€ ìë™ë¶„í• ì´ ë¹„í™œì„±í™”ë¨ì„ ë¡œê·¸
                if (silenceStart) {
                    console.log('â¸ï¸ [ë¬´ìŒ ê°ì§€ ìë™ë¶„í• ] í™”ë©´ ì „í™˜ ëŒ€ê¸° ì¤‘ì´ë¯€ë¡œ ì¼ì‹œ ì¤‘ë‹¨');
                    addLog('â¸ï¸ í™”ë©´ ì „í™˜ ëŒ€ê¸° ì¤‘ - ë¬´ìŒ ê°ì§€ ì¼ì‹œ ì¤‘ë‹¨', 'info');
                    silenceStart = null;
                    silenceIndicator.textContent = '';
                    silenceIndicator.className = 'silence-indicator';
                }
            }

            // 20ì´ˆ í˜ì¼ì„¸ì´í”„ ì œê±° - í™”ë©´ ì „í™˜ ìë™ê°ì§€ë§Œ ì‚¬ìš©

            const barCount = 64;
            const barWidth = width / barCount;
            const gap = 2;

            for (let i = 0; i < barCount; i++) {
                const dataIndex = Math.floor(i * dataArray.length / barCount);
                const barHeight = (dataArray[dataIndex] / 255) * height * 0.9;

                const x = i * barWidth;
                const y = height - barHeight;

                const gradient = canvasCtx.createLinearGradient(0, y, 0, height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(0.5, '#764ba2');
                gradient.addColorStop(1, '#f093fb');

                canvasCtx.fillStyle = gradient;
                canvasCtx.fillRect(x + gap / 2, y, barWidth - gap, barHeight);
            }
        }

        function mergeAudioStreams(streams) {
            const ctx = new AudioContext();
            const dest = ctx.createMediaStreamDestination();

            streams.forEach(stream => {
                if (stream.getAudioTracks().length > 0) {
                    const source = ctx.createMediaStreamSource(stream);
                    source.connect(dest);
                }
            });

            return dest.stream;
        }

        async function startRecording() {
            const wantSystem = includeSystemAudio.checked;
            const wantMic = includeMic.checked;

            if (!wantSystem && !wantMic) {
                updateStatus('error', 'âŒ ìµœì†Œ í•˜ë‚˜ì˜ ì˜¤ë””ì˜¤ ì†ŒìŠ¤ë¥¼ ì„ íƒí•˜ì„¸ìš”');
                return;
            }

            try {
                streams = [];
                let recordingType = '';

                // ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ íšë“
                if (wantSystem) {
                    updateStatus('ready', 'ğŸ”„ í™”ë©´ ê³µìœ  ì°½ì—ì„œ ì˜¤ë””ì˜¤ë¥¼ ì„ íƒí•˜ì„¸ìš”...');
                    const displayStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: true
                    });

                    // ë¹„ë””ì˜¤ íŠ¸ë™ì´ ìˆìœ¼ë©´ ìº¡ì²˜ìš©ìœ¼ë¡œ ì €ì¥
                    const videoTrack = displayStream.getVideoTracks()[0];
                    if (videoTrack && captureEnabled.checked) {
                        videoStream = new MediaStream([videoTrack]);
                        videoElement = document.createElement('video');
                        videoElement.srcObject = videoStream;
                        videoElement.muted = true;
                        videoElement.play();
                    } else if (videoTrack) {
                        videoTrack.stop();
                    }

                    // ì˜¤ë””ì˜¤ íŠ¸ë™ë§Œ ì¶”ì¶œ
                    const audioTrack = displayStream.getAudioTracks()[0];
                    if (audioTrack) {
                        const audioOnlyStream = new MediaStream([audioTrack]);
                        streams.push(audioOnlyStream);
                        recordingType = 'system';
                    }
                }

                // ë§ˆì´í¬ íšë“
                if (wantMic) {
                    const micStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    streams.push(micStream);
                    recordingType = recordingType === 'system' ? 'both' : 'mic';
                }

                if (streams.length === 0) {
                    throw new Error('ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í™”ë©´ ê³µìœ  ì‹œ [ì˜¤ë””ì˜¤ ê³µìœ ] ì²´í¬ë°•ìŠ¤ë¥¼ ì„ íƒí–ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }

                // ìŠ¤íŠ¸ë¦¼ ë³‘í•©
                let finalStream;
                if (streams.length > 1) {
                    finalStream = mergeAudioStreams(streams);
                } else {
                    finalStream = streams[0];
                }

                setupVisualizer();

                // ë¸Œë¼ìš°ì €ê°€ ì§€ì›í•˜ëŠ” ìµœì ì˜ íƒ€ì… ì„ íƒ
                const types = [
                    'audio/webm;codecs=opus',
                    'audio/ogg;codecs=opus',
                    'audio/webm',
                    'audio/ogg'
                ];
                let mimeType = '';
                for (const t of types) {
                    if (MediaRecorder.isTypeSupported(t)) {
                        mimeType = t;
                        break;
                    }
                }

                if (!mimeType) {
                    throw new Error('ë¸Œë¼ìš°ì €ê°€ ì§€ì›í•˜ëŠ” ë…¹ìŒ í˜•ì‹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }

                currentMimeType = mimeType;
                mediaRecorder = new MediaRecorder(finalStream, { mimeType });
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                // ì²« ë…¹ìŒ onstop ì€ activeChapterName ê¸°ì¤€
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                    const baseName =
                        activeChapterName ||
                        (chapters[currentChapterIndex]?.name) ||
                        `ê°•ì˜${lectureCount}`;
                    saveRecordingWithName(audioBlob, currentRecordingType, baseName);
                    cleanup();
                };

                currentRecordingType = recordingType; // ë³€ìˆ˜ ëŒ€ì…
                lectureCount = 1;

                if (autoStartOnSound.checked) {
                    isWaitingForFirstSound = true;
                    updateStatus('recording', 'ğŸµ ì†Œë¦¬ ëŒ€ê¸° ì¤‘... ì†Œë¦¬ê°€ ê°ì§€ë˜ë©´ ë…¹ìŒì´ ì‹œì‘ë©ë‹ˆë‹¤.');
                    progressSection.style.display = 'block'; // ëŒ€ê¸° ì¤‘ì—ë„ ì§„í–‰ ë°” ì„¹ì…˜ í‘œì‹œ
                    updateTimer(); // ëŒ€ê¸° ìƒíƒœ ì¦‰ì‹œ ë°˜ì˜
                    recordBtn.classList.add('recording');
                    recordBtn.disabled = true;
                    stopBtn.disabled = false;
                    pauseBtn.disabled = true;
                    includeSystemAudio.disabled = true;
                    includeMic.disabled = true;
                } else {
                    // âœ… 1ì´ˆ í›„ ìë™ ë…¹ìŒ ì‹œì‘
                    updateStatus('ready', 'â³ 1ì´ˆ í›„ ë…¹ìŒ ì‹œì‘...');
                    recordBtn.disabled = true;
                    setTimeout(() => {
                        actuallyStartRecording();
                    }, 1000);
                }

            } catch (err) {
                console.error('ë…¹ìŒ ì‹œì‘ ì˜¤ë¥˜:', err);
                cleanup();

                if (err.name === 'NotAllowedError') {
                    updateStatus('error', 'âŒ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ê³µìœ  ì°½ì—ì„œ [ê³µìœ ]ë¥¼ ëˆ„ë¥´ê³  [ì˜¤ë””ì˜¤ ê³µìœ ]ë¥¼ ì²´í¬í–ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
                } else if (err.name === 'NotSupportedError') {
                    let reason = 'ì´ ë¸Œë¼ìš°ì €ëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.';
                    if (!window.isSecureContext) {
                        reason = 'ë³´ì•ˆ ì—°ê²°(HTTPS) í™˜ê²½ì´ ì•„ë‹™ë‹ˆë‹¤. HTTPS ì£¼ì†Œë¡œ ì ‘ì†í•´ì•¼ í•©ë‹ˆë‹¤.';
                    }
                    updateStatus('error', `âŒ ${reason} (Chrome/Edge ê¶Œì¥)`);
                } else {
                    // ì‹¤ì œ ë°œìƒí•œ ì—ëŸ¬ì˜ ì´ë¦„ê³¼ ë©”ì‹œì§€ë¥¼ ìƒì„¸íˆ ì „ë‹¬
                    const debugInfo = `(ì—ëŸ¬ëª…: ${err.name}, ë©”ì‹œì§€: ${err.message})`;
                    updateStatus('error', `âŒ ë…¹ìŒ ì‹œì‘ ì‹¤íŒ¨: ${debugInfo}`);
                }
            }
        }

        function updateTimer() {
            const progressBar = document.querySelector('.progress-bar');
            const progressInfo = document.querySelector('.progress-info');

            let elapsedTime = 0;
            if (startTime) {
                elapsedTime = Date.now() - startTime - pausedTime;
            }

            const formatTime = (ms) => {
                const totalSeconds = Math.floor(ms / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            };

            timerDisplay.textContent = formatTime(elapsedTime);

            // Progress bar update logic - ê° ì±•í„°ë³„ ì‹¤ì‹œê°„ ì§„í–‰ë¥ 
            if (chapters.length > 0 && currentChapterIndex >= 0 && currentChapterIndex < chapters.length) {
                const currentChapter = chapters[currentChapterIndex];
                const chapterDuration = currentChapter.duration; // duration in seconds

                if (chapterDuration && chapterDuration > 0) {
                    // í˜„ì¬ ì±•í„°ì˜ ì‹¤ì œ ê²½ê³¼ ì‹œê°„ ê³„ì‚° (startTime ê¸°ì¤€)
                    const chapterElapsedTimeSec = elapsedTime / 1000;

                    let percentage = (chapterElapsedTimeSec / chapterDuration) * 100;
                    percentage = Math.min(100, Math.max(0, percentage)); // Clamp between 0 and 100

                    const remainingTimeSec = Math.max(0, chapterDuration - chapterElapsedTimeSec);

                    progressBar.style.width = `${percentage}%`;
                    progressElapsed.textContent = formatTime(elapsedTime);
                    progressRemaining.textContent = `ë‚¨ì€ ì‹œê°„: ${formatTime(remainingTimeSec * 1000)}`;
                } else {
                    // Chapter has no duration defined, show total elapsed time
                    progressBar.style.width = '100%';
                    progressElapsed.textContent = formatTime(elapsedTime);
                    progressRemaining.textContent = 'ì—°ì† ë…¹ìŒ ì¤‘';
                }
            } else {
                // No curriculum or invalid chapter index, show total elapsed time
                progressBar.style.width = '100%';
                progressElapsed.textContent = formatTime(elapsedTime);
                progressRemaining.textContent = 'ì—°ì† ë…¹ìŒ ì¤‘';
            }
        }

        function actuallyStartRecording() {
            if (!mediaRecorder) return;

            isWaitingForFirstSound = false;
            mediaRecorder.start(1000);
            startTime = Date.now(); // ìƒˆ ì±•í„° ì‹œì‘ ì‹œê°„ ë¦¬ì…‹
            recordingStartTime = Date.now(); // ì‹¤ì œ ë…¹ìŒ ì‹œì‘ ì‹œê°„ ê¸°ë¡
            pausedTime = 0;
            isPaused = false;
            isRecording = true; // ë…¹ìŒ ìƒíƒœ ì‹œì‘
            timerInterval = setInterval(updateTimer, 100);
            progressSection.style.display = 'block'; // ì§„í–‰ ë°” í‘œì‹œ

            // ìº¡ì²˜ ì‹œì‘
            if (captureEnabled.checked && videoElement) {
                startCapture();
            }

            recordBtn.classList.add('recording');
            recordBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            newLectureBtn.disabled = false;

            if (chapters.length > 0) {
                // í˜„ì¬ ì±•í„°ì˜ ì´ë¦„ ì„¤ì •
                const currentChapter = chapters[currentChapterIndex];
                activeChapterName = currentChapter.name;
                updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (${currentChapter.shortName || currentChapter.name})`);

                // ë¡œê·¸ ì¶”ê°€ (ì˜ˆìƒ ì‹œê°„ í¬í•¨)
                const expectedMin = Math.floor(currentChapter.duration / 60);
                const expectedSec = Math.floor(currentChapter.duration % 60);
                const expectedTimeStr = `${expectedMin}ë¶„ ${expectedSec}ì´ˆ`;
                addLog(`ğŸ¬ ë…¹ìŒ ì‹œì‘: "${currentChapter.name}" (ì±•í„° ${currentChapterIndex + 1}/${chapters.length}, ì˜ˆìƒ: ${expectedTimeStr})`, 'success');

                // í™œì„±í™”ëœ ì„¤ì • ë¡œê·¸ í‘œì‹œ
                const activeSettings = [];
                if (autoStartOnSound.checked) activeSettings.push('ì†Œë¦¬ ê°ì§€ ìë™ ì‹œì‘');
                if (silenceDetection.checked) {
                    const silence5 = (parseInt(chapterSilence5.value) / 1000).toFixed(1);
                    const silence10 = (parseInt(chapterSilence10.value) / 1000).toFixed(1);
                    activeSettings.push(`ë¬´ìŒ ê°ì§€ ìë™ë¶„í•  (ì±•í„° ëª¨ë“œ ì”ì—¬ 5ì´ˆ ì´í•˜:${silence5}ì´ˆ, ì”ì—¬ 5~10ì´ˆ:${silence10}ì´ˆ)`);
                }
                if (sceneChangeDetectionToggle.checked) {
                    const modes = [];
                    if (detectBasic.checked) modes.push('ê¸°ë³¸');
                    if (detectMode1.checked) modes.push('ëª¨ë“œ1');
                    if (detectMode2.checked) modes.push('ëª¨ë“œ2');
                    if (detectMode3.checked) modes.push('ëª¨ë“œ3');
                    activeSettings.push(`í™”ë©´ ì „í™˜ ìë™ê°ì§€ (${modes.join('+')})`);
                }
                if (activeSettings.length > 0) {
                    addLog(`âš™ï¸ í™œì„±í™”ëœ ì„¤ì •: ${activeSettings.join(' | ')}`, 'info');
                }

                // ì±•í„° íƒ€ì´ë¨¸ëŠ” ì²« ë…¹ìŒ ì‹œì‘ ì‹œì—ë§Œ ì‹œì‘ (ë¶„í•  ì‹œì—ëŠ” ì´ë¯¸ ì‹œì‘ë¨)
                console.log(`ğŸ” [DEBUG] ì¡°ê±´ í™•ì¸ - currentChapterIndex: ${currentChapterIndex}, chapterTimers.length: ${chapterTimers.length}`);
                if (currentChapterIndex === 0 || chapterTimers.length === 0) {
                    console.log(`ğŸ” [DEBUG] startChapterTimers() í˜¸ì¶œ - currentChapterIndex: ${currentChapterIndex}`);
                    startChapterTimers(currentChapterIndex);
                } else {
                    console.log(`âš ï¸ [DEBUG] startChapterTimers() í˜¸ì¶œ ìƒëµ - ì´ë¯¸ íƒ€ì´ë¨¸ê°€ ì„¤ì •ë¨`);
                }
            } else {
                const sourceText = currentRecordingType === 'both' ? 'ì‹œìŠ¤í…œ + ë§ˆì´í¬' :
                    currentRecordingType === 'system' ? 'ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤' : 'ë§ˆì´í¬';
                updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (ê°•ì˜ ${lectureCount}, ${sourceText})`);
                addLog(`ğŸ¬ ë…¹ìŒ ì‹œì‘: ê°•ì˜${lectureCount} (ì†ŒìŠ¤: ${sourceText})`, 'success');

                // í™œì„±í™”ëœ ì„¤ì • ë¡œê·¸ í‘œì‹œ
                const activeSettings = [];
                if (autoStartOnSound.checked) activeSettings.push('ì†Œë¦¬ ê°ì§€ ìë™ ì‹œì‘');
                if (silenceDetection.checked) {
                    const silence5 = (parseInt(chapterSilence5.value) / 1000).toFixed(1);
                    const silence10 = (parseInt(chapterSilence10.value) / 1000).toFixed(1);
                    activeSettings.push(`ë¬´ìŒ ê°ì§€ ìë™ë¶„í•  (ì±•í„° ëª¨ë“œ ì”ì—¬ 5ì´ˆ ì´í•˜:${silence5}ì´ˆ, ì”ì—¬ 5~10ì´ˆ:${silence10}ì´ˆ)`);
                }
                if (sceneChangeDetectionToggle.checked) {
                    const modes = [];
                    if (detectBasic.checked) modes.push('ê¸°ë³¸');
                    if (detectMode1.checked) modes.push('ëª¨ë“œ1');
                    if (detectMode2.checked) modes.push('ëª¨ë“œ2');
                    if (detectMode3.checked) modes.push('ëª¨ë“œ3');
                    activeSettings.push(`í™”ë©´ ì „í™˜ ìë™ê°ì§€ (${modes.join('+')})`);
                }
                if (activeSettings.length > 0) {
                    addLog(`âš™ï¸ í™œì„±í™”ëœ ì„¤ì •: ${activeSettings.join(' | ')}`, 'info');
                }
            }
        }

        function cleanup() {
            streams.forEach(stream => {
                stream.getTracks().forEach(track => track.stop());
            });
            streams = [];

            if (audioContext) {
                audioContext.close().catch(() => { });
                audioContext = null;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
            }

            analyser = null;
            dataArray = null;

            stopCapture();
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            if (videoElement) {
                videoElement.remove();
                videoElement = null;
            }

            // í™”ë©´ ë³€í™” ê°ì§€ ì •ë¦¬
            stopSceneChangeDetection();
            if (sceneChangeDetector) {
                sceneChangeDetector.destroy();
                sceneChangeDetector = null;
            }

            // í…œí”Œë¦¿ ë§¤ì¹­ ì •ë¦¬
            stopTemplateMatching();
            if (templateMatcher) {
                templateMatcher.destroy();
                templateMatcher = null;
            }
        }

        // ìº¡ì²˜ ê´€ë ¨ ìƒìˆ˜
        const TARGET_WIDTH = 1280;
        const TARGET_HEIGHT = 720;

        function startCapture() {
            if (!captureEnabled.checked || !videoElement) return;

            const interval = parseInt(captureInterval.value) * 1000;
            captureTimer = setInterval(captureFrame, interval);
            captureFrame(); // ì²« í”„ë ˆì„ ì¦‰ì‹œ ìº¡ì²˜
        }

        function stopCapture() {
            if (captureTimer) {
                clearInterval(captureTimer);
                captureTimer = null;
            }
        }

        function captureFrame() {
            if (!videoElement || videoElement.readyState < 2) return;

            const vw = videoElement.videoWidth;
            const vh = videoElement.videoHeight;

            // 1280x720 ê³ ì • ìº”ë²„ìŠ¤
            const canvas = document.createElement('canvas');
            canvas.width = TARGET_WIDTH;
            canvas.height = TARGET_HEIGHT;
            const ctx = canvas.getContext('2d');

            // ì›ë³¸ ë¹„ìœ¨ ìœ ì§€ + Contain ë°©ì‹
            const scale = Math.min(
                TARGET_WIDTH / vw,
                TARGET_HEIGHT / vh
            );

            const drawW = vw * scale;
            const drawH = vh * scale;

            const offsetX = (TARGET_WIDTH - drawW) / 2;
            const offsetY = (TARGET_HEIGHT - drawH) / 2;

            // ì—¬ë°± ë°°ê²½ìƒ‰ (ê²€ì • ë°”íƒ•)
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);

            // ë¹„ìœ¨ ìœ ì§€ëœ ìƒíƒœë¡œ ê°€ìš´ë° ì •ë ¬
            ctx.drawImage(videoElement, offsetX, offsetY, drawW, drawH);

            const quality = parseFloat(captureQuality.value);
            const imageData = canvas.toDataURL("image/webp", quality);

            capturedImages.push(imageData);
            captureCount++;

            updateCaptureStatus();
        }

        function updateCaptureStatus() {
            if (captureCount > 0) {
                captureStatus.textContent = `ğŸ“¸ ${captureCount}ì¥ ìº¡ì²˜ë¨`;
            } else {
                captureStatus.textContent = '';
            }
        }

        // í™”ë©´ ë³€í™” ê°ì§€ ì‹œìŠ¤í…œ
        class SceneChangeDetector {
            constructor(videoElement) {
                this.video = videoElement;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.lastFrameData = null;
                this.lastHistogram = null;
                this.changeThreshold = 0.15; // 15% ì´ìƒ ë³€í™” ì‹œ ì¥ë©´ ì „í™˜ìœ¼ë¡œ íŒë‹¨
                this.minChangePixels = 50000; // ìµœì†Œ ë³€í™” í”½ì…€ ìˆ˜
                this.histogramThreshold = 0.25; // 25% ì´ìƒ íˆìŠ¤í† ê·¸ë¨ ë³€í™” ì‹œ ì¥ë©´ ì „í™˜
                this.lastChangeTime = 0;
                this.cooldownPeriod = 3000; // 3ì´ˆ ì¿¨ë‹¤ìš´ (ê°™ì€ ê°•ì˜ ë‚´ ì „í™˜ ë¬´ì‹œ)

                // ìƒ˜í”Œë§ í•´ìƒë„ (ì„±ëŠ¥ ìµœì í™”)
                this.sampleWidth = 160;
                this.sampleHeight = 90;
                this.canvas.width = this.sampleWidth;
                this.canvas.height = this.sampleHeight;

                // ì—°ì† í”„ë ˆì„ ë³€í™” ì¶”ì  (ë™ì˜ìƒ ì „í™˜ ê°ì§€ìš©)
                this.consecutiveChanges = 0;
                this.consecutiveThreshold = 3; // 3í”„ë ˆì„ ì—°ì† ë³€í™” ì‹œ ë™ì˜ìƒ ì „í™˜ìœ¼ë¡œ íŒë‹¨

                // ê°ì§€ ëª¨ë“œ ('basic', 'mode1', 'mode2', 'mode3')
                this.detectionMode = 'basic';
                this.mode2ReferenceImage = null; // ëª¨ë“œ2ìš© ì°¸ì¡° ì´ë¯¸ì§€

                // ëª¨ë“œ3: ë¬´ìŒ ê°ì§€ìš© ë³€ìˆ˜
                this.silenceStartTime = null;
                this.silenceDuration = 4000; // 4ì´ˆ
            }

            captureFrame() {
                if (!this.video || this.video.readyState < 2) return null;

                const vw = this.video.videoWidth;
                const vh = this.video.videoHeight;

                if (!vw || !vh) return null;

                // ë¹„ìœ¨ ìœ ì§€í•˜ë©° ìº”ë²„ìŠ¤ì— ë§ì¶¤ (letterbox ì œê±°)
                const scale = Math.min(
                    this.sampleWidth / vw,
                    this.sampleHeight / vh
                );

                const drawW = vw * scale;
                const drawH = vh * scale;
                const offsetX = (this.sampleWidth - drawW) / 2;
                const offsetY = (this.sampleHeight - drawH) / 2;

                // ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (ê²€ì€ ë°°ê²½)
                this.ctx.fillStyle = "#000";
                this.ctx.fillRect(0, 0, this.sampleWidth, this.sampleHeight);

                // ì‹¤ì œ ë¹„ë””ì˜¤ ì½˜í…ì¸ ë§Œ ê·¸ë¦¬ê¸°
                this.ctx.drawImage(this.video, offsetX, offsetY, drawW, drawH);

                return this.ctx.getImageData(0, 0, this.sampleWidth, this.sampleHeight);
            }

            // íˆìŠ¤í† ê·¸ë¨ ê³„ì‚° (ìƒ‰ìƒ ë¶„í¬ ë¶„ì„)
            calculateHistogram(frameData) {
                if (!frameData) return null;

                const histogram = {
                    r: new Array(16).fill(0),
                    g: new Array(16).fill(0),
                    b: new Array(16).fill(0),
                    brightness: new Array(16).fill(0)
                };

                const data = frameData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // 16ê°œ êµ¬ê°„ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì¹´ìš´íŠ¸
                    histogram.r[Math.floor(r / 16)]++;
                    histogram.g[Math.floor(g / 16)]++;
                    histogram.b[Math.floor(b / 16)]++;

                    // ë°ê¸° ê³„ì‚° (ê°„ë‹¨í•œ í‰ê· )
                    const brightness = (r + g + b) / 3;
                    histogram.brightness[Math.floor(brightness / 16)]++;
                }

                // ì •ê·œí™”
                const totalPixels = data.length / 4;
                for (let i = 0; i < 16; i++) {
                    histogram.r[i] /= totalPixels;
                    histogram.g[i] /= totalPixels;
                    histogram.b[i] /= totalPixels;
                    histogram.brightness[i] /= totalPixels;
                }

                return histogram;
            }

            // íˆìŠ¤í† ê·¸ë¨ ì°¨ì´ ê³„ì‚°
            compareHistograms(hist1, hist2) {
                if (!hist1 || !hist2) return 0;

                let totalDiff = 0;
                const channels = ['r', 'g', 'b', 'brightness'];

                for (const channel of channels) {
                    for (let i = 0; i < 16; i++) {
                        totalDiff += Math.abs(hist1[channel][i] - hist2[channel][i]);
                    }
                }

                return totalDiff / (16 * channels.length);
            }

            calculateDifference(frame1, frame2) {
                if (!frame1 || !frame2) return 0;

                const data1 = frame1.data;
                const data2 = frame2.data;
                let diffPixels = 0;
                let totalDiff = 0;

                // í”½ì…€ ë‹¨ìœ„ë¡œ RGB ì°¨ì´ ê³„ì‚° (4í”½ì…€ì”© ê±´ë„ˆë›°ë©° ìƒ˜í”Œë§)
                for (let i = 0; i < data1.length; i += 16) { // RGBAì´ë¯€ë¡œ 4í”½ì…€ = 16ë°”ì´íŠ¸
                    const r1 = data1[i];
                    const g1 = data1[i + 1];
                    const b1 = data1[i + 2];
                    const r2 = data2[i];
                    const g2 = data2[i + 1];
                    const b2 = data2[i + 2];

                    const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);

                    // ì„ê³„ê°’ ì´ìƒì˜ ë³€í™”ë§Œ ì¹´ìš´íŠ¸ (ë¯¸ì„¸í•œ ë³€í™” ë¬´ì‹œ)
                    if (diff > 30) {
                        diffPixels++;
                        totalDiff += diff;
                    }
                }

                const totalPixels = (data1.length / 4) / 4; // ìƒ˜í”Œë§í•œ í”½ì…€ ìˆ˜
                const changeRatio = diffPixels / totalPixels;
                const avgDiff = diffPixels > 0 ? totalDiff / diffPixels : 0;

                return { changeRatio, diffPixels, avgDiff };
            }

            // ì˜¬ë¸”ë™ í™”ë©´ ê°ì§€
            isBlackScreen(frameData) {
                if (!frameData) return false;

                const data = frameData.data;
                let totalBrightness = 0;
                const sampleSize = Math.min(1000, data.length / 4); // ìµœëŒ€ 1000ê°œ í”½ì…€ ìƒ˜í”Œë§

                for (let i = 0; i < sampleSize * 4; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    totalBrightness += (r + g + b) / 3;
                }

                const avgBrightness = totalBrightness / sampleSize;
                const isBlack = avgBrightness < 15; // í‰ê·  ë°ê¸°ê°€ 15 ë¯¸ë§Œì´ë©´ ë¸”ë™

                if (isBlack) {
                    console.log(`â¬› ì˜¬ë¸”ë™ í™”ë©´ ê°ì§€! í‰ê·  ë°ê¸°: ${avgBrightness.toFixed(1)}`);
                }

                return isBlack;
            }

            checkSceneChange() {
                // ì²´í¬ë°•ìŠ¤ë¡œ ì„ íƒëœ ì¡°ê±´ë“¤ì„ AND ì¡°ê±´ìœ¼ë¡œ ê²°í•©
                const conditions = [];
                let allSatisfied = true;

                // ê¸°ë³¸ ê°ì§€ ì²´í¬
                if (detectBasic.checked) {
                    const basicDetected = this.checkBasicSceneChange();
                    conditions.push({ name: 'ê¸°ë³¸', result: basicDetected });
                    if (!basicDetected) allSatisfied = false;
                }

                // ëª¨ë“œ1 ê°ì§€ ì²´í¬ (ê¸°ë³¸ì´ ë§Œì¡±ëœ ê²½ìš°ë§Œ)
                if (detectMode1.checked && allSatisfied) {
                    const mode1Detected = this.checkMode1WhiteBackground();
                    conditions.push({ name: 'ëª¨ë“œ1', result: mode1Detected });
                    if (!mode1Detected) allSatisfied = false;
                }

                // ëª¨ë“œ2 ê°ì§€ ì²´í¬ (ì´ì „ ì¡°ê±´ë“¤ì´ ëª¨ë‘ ë§Œì¡±ëœ ê²½ìš°ë§Œ)
                if (detectMode2.checked && allSatisfied) {
                    const mode2Detected = this.checkMode2ImageMatch();
                    conditions.push({ name: 'ëª¨ë“œ2', result: mode2Detected });
                    if (!mode2Detected) allSatisfied = false;
                }

                // ëª¨ë“œ3 ê°ì§€ ì²´í¬ (ì´ì „ ì¡°ê±´ë“¤ì´ ëª¨ë‘ ë§Œì¡±ëœ ê²½ìš°ë§Œ)
                if (detectMode3.checked && allSatisfied) {
                    const mode3Detected = this.checkMode3Silence();
                    conditions.push({ name: 'ëª¨ë“œ3', result: mode3Detected });
                    if (!mode3Detected) allSatisfied = false;
                }

                // ëª¨ë“  ì¡°ê±´ì´ ë§Œì¡±ë˜ì—ˆì„ ë•Œë§Œ ì „í™˜
                if (allSatisfied && conditions.length > 0) {
                    const conditionNames = conditions.map(c => c.name).join(' + ');
                    console.log(`âœ… [ì¡°í•© ê°ì§€] ${conditionNames} ì¡°ê±´ ëª¨ë‘ ë§Œì¡±!`);
                    addLog(`âœ… ${conditionNames} ì¡°ê±´ ëª¨ë‘ ë§Œì¡± â†’ ì „í™˜`, 'success');
                    return true;
                }

                return false;
            }

            // ê¸°ë³¸ ëª¨ë“œ: í”½ì…€ + íˆìŠ¤í† ê·¸ë¨ ë¶„ì„
            checkBasicSceneChange() {
                const currentFrame = this.captureFrame();
                if (!currentFrame) return false;

                // íˆìŠ¤í† ê·¸ë¨ ê³„ì‚°
                const currentHistogram = this.calculateHistogram(currentFrame);

                if (!this.lastFrameData || !this.lastHistogram) {
                    this.lastFrameData = currentFrame;
                    this.lastHistogram = currentHistogram;
                    this.consecutiveChanges = 0;
                    return false;
                }

                const now = Date.now();
                if (now - this.lastChangeTime < this.cooldownPeriod) {
                    this.lastFrameData = currentFrame;
                    this.lastHistogram = currentHistogram;
                    this.consecutiveChanges = 0;
                    return false;
                }

                // í”½ì…€ ë‹¨ìœ„ ì°¨ì´ ê³„ì‚°
                const diff = this.calculateDifference(this.lastFrameData, currentFrame);

                // íˆìŠ¤í† ê·¸ë¨ ì°¨ì´ ê³„ì‚° (ìƒ‰ìƒ ë¶„í¬ ë³€í™”)
                const histDiff = this.compareHistograms(this.lastHistogram, currentHistogram);

                this.lastFrameData = currentFrame;
                this.lastHistogram = currentHistogram;

                // ë™ì˜ìƒ ì „í™˜ ê°ì§€ ì¡°ê±´:
                // 1. í”½ì…€ ë³€í™”ìœ¨ì´ ë†’ìŒ (ê¸‰ê²©í•œ í™”ë©´ ë³€í™”)
                // 2. íˆìŠ¤í† ê·¸ë¨ ë³€í™”ê°€ í¼ (ìƒ‰ìƒ ë¶„í¬ ë³€í™”)
                // 3. ì—°ì† í”„ë ˆì„ ë³€í™” ì¶”ì 
                const hasPixelChange = diff.changeRatio > this.changeThreshold && diff.diffPixels > this.minChangePixels;
                const hasHistogramChange = histDiff > this.histogramThreshold;

                // ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë„ í° ë³€í™”ê°€ ìˆìœ¼ë©´ ì¹´ìš´íŠ¸ ì¦ê°€
                if (hasPixelChange || hasHistogramChange) {
                    this.consecutiveChanges++;
                    console.log(`ğŸ” í™”ë©´ ë³€í™” (${this.consecutiveChanges}/${this.consecutiveThreshold}) - í”½ì…€: ${(diff.changeRatio * 100).toFixed(1)}%, íˆìŠ¤í† ê·¸ë¨: ${(histDiff * 100).toFixed(1)}%`);
                    addLog(`ğŸ” [DEBUG] í™”ë©´ ë³€í™” ê°ì§€ (${this.consecutiveChanges}/${this.consecutiveThreshold}) - í”½ì…€: ${(diff.changeRatio * 100).toFixed(1)}%, íˆìŠ¤í† ê·¸ë¨: ${(histDiff * 100).toFixed(1)}%`, 'info');
                } else {
                    this.consecutiveChanges = 0;
                }

                // ì—°ì† Ní”„ë ˆì„ ì´ìƒ ë³€í™” ì‹œ ë™ì˜ìƒ ì „í™˜ìœ¼ë¡œ íŒë‹¨
                const isVideoTransition = this.consecutiveChanges >= this.consecutiveThreshold;

                if (isVideoTransition) {
                    this.lastChangeTime = now;
                    this.consecutiveChanges = 0;
                    console.log(`ğŸ¬ ë™ì˜ìƒ ì „í™˜ ê°ì§€! í”½ì…€ ë³€í™”ìœ¨: ${(diff.changeRatio * 100).toFixed(1)}%, íˆìŠ¤í† ê·¸ë¨ ë³€í™”: ${(histDiff * 100).toFixed(1)}%`);
                    addLog(`ğŸ¬ ë™ì˜ìƒ ì „í™˜ ê°ì§€! (í”½ì…€: ${(diff.changeRatio * 100).toFixed(1)}%, ìƒ‰ìƒë¶„í¬: ${(histDiff * 100).toFixed(1)}%)`, 'success');
                }

                return isVideoTransition;
            }

            // ëª¨ë“œ1: í•˜ì–€ ë°°ê²½ + ì¤‘ì•™ ì‘ì€ ë¡œê³  ê°ì§€
            checkMode1WhiteBackground() {
                const currentFrame = this.captureFrame();
                if (!currentFrame) return false;

                const data = currentFrame.data;
                let whitePixels = 0;
                let darkCenterPixels = 0;
                const totalPixels = data.length / 4;

                // ì¤‘ì•™ ì˜ì—­ ê³„ì‚° (ì „ì²´ì˜ 20% ì¤‘ì•™ ì˜ì—­)
                const centerStartX = Math.floor(this.sampleWidth * 0.4);
                const centerEndX = Math.floor(this.sampleWidth * 0.6);
                const centerStartY = Math.floor(this.sampleHeight * 0.4);
                const centerEndY = Math.floor(this.sampleHeight * 0.6);

                for (let y = 0; y < this.sampleHeight; y++) {
                    for (let x = 0; x < this.sampleWidth; x++) {
                        const idx = (y * this.sampleWidth + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const brightness = (r + g + b) / 3;

                        // í•˜ì–€ìƒ‰ íŒì • (ë°ê¸° 200 ì´ìƒ)
                        if (brightness > 200) {
                            whitePixels++;
                        }

                        // ì¤‘ì•™ ì˜ì—­ì˜ ì–´ë‘ìš´ í”½ì…€ (ë¡œê³  ì˜ì—­)
                        if (x >= centerStartX && x <= centerEndX &&
                            y >= centerStartY && y <= centerEndY) {
                            if (brightness < 150) { // ì¤‘ì•™ì— ì–´ë‘ìš´ ì˜ì—­ ìˆìŒ
                                darkCenterPixels++;
                            }
                        }
                    }
                }

                const whiteRatio = whitePixels / totalPixels;
                const centerArea = (centerEndX - centerStartX) * (centerEndY - centerStartY);
                const darkCenterRatio = darkCenterPixels / centerArea;

                // í™”ë©´ì˜ 70% ì´ìƒì´ í•˜ì–—ê³ , ì¤‘ì•™ì— 10% ì´ìƒ ì–´ë‘ìš´ ì˜ì—­ (ë¡œê³ )
                const isWhiteBackgroundWithLogo = whiteRatio > 0.7 && darkCenterRatio > 0.1;

                if (isWhiteBackgroundWithLogo) {
                    console.log(`âœ“ [ëª¨ë“œ1 ì¡°ê±´] í•˜ì–€ ë°°ê²½ + ì¤‘ì•™ ë¡œê³  ê°ì§€! (í•˜ì–€ìƒ‰: ${(whiteRatio * 100).toFixed(1)}%, ì¤‘ì•™ ë¡œê³ : ${(darkCenterRatio * 100).toFixed(1)}%)`);
                    return true;
                }

                this.lastFrameData = currentFrame;
                return false;
            }

            // ëª¨ë“œ2: íŠ¹ì • ì´ë¯¸ì§€ ë§¤ì¹­
            checkMode2ImageMatch() {
                if (!this.mode2ReferenceImage) {
                    console.warn('âš ï¸ ëª¨ë“œ2: ì°¸ì¡° ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    return false;
                }

                const currentFrame = this.captureFrame();
                if (!currentFrame) return false;

                // ì°¸ì¡° ì´ë¯¸ì§€ë¥¼ í˜„ì¬ í”„ë ˆì„ í¬ê¸°ë¡œ ë¦¬ìƒ˜í”Œë§
                const refCanvas = document.createElement('canvas');
                refCanvas.width = this.sampleWidth;
                refCanvas.height = this.sampleHeight;
                const refCtx = refCanvas.getContext('2d');

                // ì°¸ì¡° ì´ë¯¸ì§€ë¥¼ ì„ì‹œ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.mode2ReferenceImage.width;
                tempCanvas.height = this.mode2ReferenceImage.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(this.mode2ReferenceImage, 0, 0);

                // ë¦¬ìƒ˜í”Œë§
                refCtx.drawImage(tempCanvas, 0, 0, this.sampleWidth, this.sampleHeight);
                const resizedRef = refCtx.getImageData(0, 0, this.sampleWidth, this.sampleHeight);

                // ìœ ì‚¬ë„ ê³„ì‚°
                const similarity = this.calculateImageSimilarity(currentFrame, resizedRef);

                // 70% ì´ìƒ ìœ ì‚¬í•˜ë©´ ë§¤ì¹­
                const matched = similarity > 0.7;

                if (matched) {
                    console.log(`âœ“ [ëª¨ë“œ2 ì¡°ê±´] íŠ¹ì • ì´ë¯¸ì§€ ë§¤ì¹­ ê°ì§€! (ìœ ì‚¬ë„: ${(similarity * 100).toFixed(1)}%)`);
                    return true;
                }

                this.lastFrameData = currentFrame;
                return false;
            }

            // ë‘ ì´ë¯¸ì§€ì˜ ìœ ì‚¬ë„ ê³„ì‚° (í”½ì…€ ë‹¨ìœ„ ë¹„êµ)
            calculateImageSimilarity(frame1, frame2) {
                if (!frame1 || !frame2) return 0;

                const data1 = frame1.data;
                const data2 = frame2.data;
                let matchPixels = 0;
                const totalPixels = data1.length / 4;

                for (let i = 0; i < data1.length; i += 4) {
                    const r1 = data1[i];
                    const g1 = data1[i + 1];
                    const b1 = data1[i + 2];
                    const r2 = data2[i];
                    const g2 = data2[i + 1];
                    const b2 = data2[i + 2];

                    const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);

                    // 30 ì´í•˜ ì°¨ì´ë©´ ìœ ì‚¬í•œ í”½ì…€ë¡œ ê°„ì£¼
                    if (diff < 30) {
                        matchPixels++;
                    }
                }

                return matchPixels / totalPixels;
            }

            // ëª¨ë“œ3: 4ì´ˆ ë¬´ìŒ ê°ì§€
            checkMode3Silence() {
                // analyserì™€ dataArrayê°€ ì „ì—­ ë³€ìˆ˜ë¡œ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                if (!window.analyser || !window.dataArray) {
                    return false;
                }

                // í˜„ì¬ ì˜¤ë””ì˜¤ ë ˆë²¨ ê³„ì‚°
                window.analyser.getByteFrequencyData(window.dataArray);
                const average = window.dataArray.reduce((a, b) => a + b, 0) / window.dataArray.length;
                const isSilent = average < silenceThreshold;

                if (isSilent) {
                    // ë¬´ìŒ ì‹œì‘ ì‹œê°„ ê¸°ë¡
                    if (!this.silenceStartTime) {
                        this.silenceStartTime = Date.now();
                        console.log('ğŸ”‡ [ëª¨ë“œ3] ë¬´ìŒ ê°ì§€ ì‹œì‘');
                    } else {
                        const silentDuration = Date.now() - this.silenceStartTime;

                        // 0.5ì´ˆë§ˆë‹¤ ë¡œê·¸ (ë„ˆë¬´ ë§ì€ ë¡œê·¸ ë°©ì§€)
                        if (Math.floor(silentDuration / 500) !== Math.floor((silentDuration - 500) / 500)) {
                            console.log(`ğŸ”‡ [ëª¨ë“œ3] ë¬´ìŒ ì§€ì† ì¤‘... ${(silentDuration / 1000).toFixed(1)}ì´ˆ / 4.0ì´ˆ`);
                        }

                        // 4ì´ˆ ì´ìƒ ë¬´ìŒì´ë©´ ê°ì§€ ì„±ê³µ
                        if (silentDuration >= this.silenceDuration) {
                            console.log(`âœ“ [ëª¨ë“œ3 ì¡°ê±´] 4ì´ˆ ë¬´ìŒ ê°ì§€! (${(silentDuration / 1000).toFixed(1)}ì´ˆ)`);
                            this.silenceStartTime = null; // ë¦¬ì…‹
                            return true;
                        }
                    }
                } else {
                    // ì†Œë¦¬ê°€ ë“¤ë¦¬ë©´ ë¬´ìŒ íƒ€ì´ë¨¸ ë¦¬ì…‹
                    if (this.silenceStartTime) {
                        console.log('âŒ [ëª¨ë“œ3] ë¬´ìŒ ì¤‘ë‹¨ (ì†Œë¦¬ ê°ì§€) - íƒ€ì´ë¨¸ ë¦¬ì…‹');
                        this.silenceStartTime = null;
                    }
                }

                return false;
            }

            reset() {
                this.lastFrameData = null;
                this.lastHistogram = null;
                this.lastChangeTime = 0;
                this.consecutiveChanges = 0;
                this.silenceStartTime = null; // ëª¨ë“œ3 ë¬´ìŒ íƒ€ì´ë¨¸ ë¦¬ì…‹
            }

            destroy() {
                this.lastFrameData = null;
                this.canvas = null;
                this.ctx = null;
            }
        }

        // í…œí”Œë¦¿ ë§¤ì¹­ ê°ì§€ ì‹œìŠ¤í…œ
        class TemplateMatcher {
            constructor(videoElement, templateImageData) {
                this.video = videoElement;
                this.template = templateImageData;
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.similarityThreshold = 0.90; // 90% ìœ ì‚¬ë„

                // í…œí”Œë¦¿ í¬ê¸°ë¡œ ìº”ë²„ìŠ¤ ì„¤ì •
                this.canvas.width = this.template.width;
                this.canvas.height = this.template.height;
            }

            captureVideoFrame() {
                if (!this.video || this.video.readyState < 2) return null;

                const vw = this.video.videoWidth;
                const vh = this.video.videoHeight;

                if (!vw || !vh) return null;

                // ë¹„ìœ¨ ìœ ì§€í•˜ë©° ìº”ë²„ìŠ¤ì— ë§ì¶¤ (letterbox ì œê±°)
                const scale = Math.min(
                    this.canvas.width / vw,
                    this.canvas.height / vh
                );

                const drawW = vw * scale;
                const drawH = vh * scale;
                const offsetX = (this.canvas.width - drawW) / 2;
                const offsetY = (this.canvas.height - drawH) / 2;

                // ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (ê²€ì€ ë°°ê²½)
                this.ctx.fillStyle = "#000";
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // ì‹¤ì œ ë¹„ë””ì˜¤ ì½˜í…ì¸ ë§Œ ê·¸ë¦¬ê¸°
                this.ctx.drawImage(this.video, offsetX, offsetY, drawW, drawH);

                return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
            }

            calculateSimilarity(frame1, frame2) {
                if (!frame1 || !frame2) return 0;

                const data1 = frame1.data;
                const data2 = frame2.data;
                let matchingPixels = 0;
                const totalPixels = data1.length / 4;

                // í”½ì…€ ë‹¨ìœ„ë¡œ RGB ë¹„êµ
                for (let i = 0; i < data1.length; i += 4) {
                    const r1 = data1[i];
                    const g1 = data1[i + 1];
                    const b1 = data1[i + 2];
                    const r2 = data2[i];
                    const g2 = data2[i + 1];
                    const b2 = data2[i + 2];

                    // RGB ê°ê°ì˜ ì°¨ì´ ê³„ì‚°
                    const diff = Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2);

                    // ì°¨ì´ê°€ 30 ì´í•˜ë©´ ìœ ì‚¬í•œ í”½ì…€ë¡œ íŒë‹¨
                    if (diff <= 30) {
                        matchingPixels++;
                    }
                }

                return matchingPixels / totalPixels;
            }

            checkMatch() {
                const currentFrame = this.captureVideoFrame();
                if (!currentFrame) return { matched: false, similarity: 0 };

                const similarity = this.calculateSimilarity(this.template, currentFrame);
                const matched = similarity >= this.similarityThreshold;

                return { matched, similarity };
            }

            destroy() {
                this.template = null;
                this.canvas = null;
                this.ctx = null;
            }
        }

        function startSceneChangeDetection() {
            console.log(`ğŸ” [DEBUG] startSceneChangeDetection í˜¸ì¶œ - sceneChangeDetectionToggle: ${sceneChangeDetectionToggle.checked}, templateMatchingToggle: ${templateMatchingToggle.checked}, videoElement: ${!!videoElement}, waitingForSilence: ${waitingForSilence}`);

            // í™”ë©´ ë³€í™” ê°ì§€ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì‹œì‘í•˜ì§€ ì•ŠìŒ
            if (!sceneChangeDetectionToggle.checked && !templateMatchingToggle.checked) {
                console.log('âš ï¸ [DEBUG] í™”ë©´ ì „í™˜ ê°ì§€/í…œí”Œë¦¿ ë§¤ì¹­ ë‘˜ ë‹¤ ë¹„í™œì„±í™” â†’ ê°ì§€ ì‹œì‘ ì•ˆ í•¨');
                return;
            }
            if (!videoElement || !waitingForSilence) {
                console.log(`âš ï¸ [DEBUG] videoElement ë˜ëŠ” waitingForSilence ëˆ„ë½ â†’ ê°ì§€ ì‹œì‘ ì•ˆ í•¨ (videoElement: ${!!videoElement}, waitingForSilence: ${waitingForSilence})`);
                return;
            }

            if (!sceneChangeDetector) {
                sceneChangeDetector = new SceneChangeDetector(videoElement);
                // ìŠ¬ë¼ì´ë” ê°’ìœ¼ë¡œ ë¯¼ê°ë„ ì„¤ì •
                sceneChangeDetector.changeThreshold = parseInt(sceneChangeSensitivity.value) / 100;
                // ëª¨ë“œ2 ì°¸ì¡° ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì„¤ì •
                if (mode2ReferenceImage) {
                    sceneChangeDetector.mode2ReferenceImage = mode2ReferenceImage;
                }
            }

            // í™”ë©´ ë³€í™” ê°ì§€ ì¤‘ì§€ (ì´ë¯¸ ì‹¤í–‰ ì¤‘ì´ë©´)
            stopSceneChangeDetection();

            // âœ… í…œí”Œë¦¿ ë§¤ì¹­: ë…¹ìŒ ì‹œì‘ ì¦‰ì‹œ ì‹¤ì‹œê°„ ë§¤ì¹­
            // 500msë§ˆë‹¤ ì²´í¬
            sceneChangeCheckInterval = setInterval(() => {
                if (!waitingForSilence) {
                    stopSceneChangeDetection();
                    return;
                }

                // âœ… í…œí”Œë¦¿ ë§¤ì¹­ í™œì„±í™” ì‹œ ì¦‰ì‹œ ì‹¤ì‹œê°„ ë§¤ì¹­
                if (templateMatchingToggle.checked) {
                    // í…œí”Œë¦¿ ë§¤ì²˜ê°€ ì—†ìœ¼ë©´ ìƒì„±
                    if (templateImage && !templateMatcher) {
                        templateMatcher = new TemplateMatcher(videoElement, templateImage);
                        templateMatcher.similarityThreshold = parseInt(templateSimilarity.value) / 100;
                        console.log('âœ… ì‹¤ì‹œê°„ í…œí”Œë¦¿ ë§¤ì¹­ ì‹œì‘');
                    }

                    // ì‹¤ì‹œê°„ í…œí”Œë¦¿ ë§¤ì¹­ ì‹œë„
                    if (templateMatcher) {
                        const result = templateMatcher.checkMatch();

                        if (result.matched) {
                            const similarity = (result.similarity * 100).toFixed(1);
                            console.log(`ğŸ–¼ï¸ í…œí”Œë¦¿ ë§¤ì¹­ ê°ì§€! ìœ ì‚¬ë„: ${similarity}% â†’ ìë™ë¶„í• `);
                            addLog(`ğŸ–¼ï¸ í…œí”Œë¦¿ ë§¤ì¹­ ê°ì§€! (ìœ ì‚¬ë„: ${similarity}%) â†’ ë‹¤ìŒ ì±•í„°ë¡œ ì „í™˜`, 'success');
                            addLog(`ğŸ” [DEBUG] í…œí”Œë¦¿ ë§¤ì¹­ìœ¼ë¡œ triggerChapterTransition í˜¸ì¶œ`, 'info');
                            triggerChapterTransition(`í…œí”Œë¦¿ ë§¤ì¹­ (ìœ ì‚¬ë„: ${similarity}%)`);
                        }
                    }
                }

                // í™”ë©´ ì „í™˜ ìë™ê°ì§€ (ëª©ì°¨ìš©)
                if (sceneChangeDetectionToggle.checked) {
                    const average = dataArray ? dataArray.reduce((a, b) => a + b, 0) / dataArray.length : 0;
                    const isSilent = average < silenceThreshold;

                    // ë¬´ìŒ ì¡°ê±´ì´ í•„ìš”í•œ ê²½ìš° (AND ì¡°ê±´)
                    if (requireSilenceForSceneChange.checked) {
                        // ë¬´ìŒ 4.5ì´ˆ + í™”ë©´ ì „í™˜ ì¡°í•© ë¡œì§
                        if (!isSilent) {
                            if (silenceStartForSplit && !detectedSceneChange) {
                                console.log('âŒ ë¬´ìŒ ì¤‘ë‹¨ (ì†Œë¦¬ ê°ì§€) - íƒ€ì´ë¨¸ ë¦¬ì…‹');
                                silenceStartForSplit = null;
                                frameBeforeSilence = null;
                            }
                        } else {
                            if (!silenceStartForSplit) {
                                silenceStartForSplit = Date.now();
                                frameBeforeSilence = sceneChangeDetector.captureFrame();
                                console.log('ğŸ”‡ ë¬´ìŒ ê°ì§€ ì‹œì‘ â†’ í˜„ì¬ í™”ë©´ ì €ì¥');
                            } else {
                                const silentTime = Date.now() - silenceStartForSplit;

                                // ë¬´ìŒ ì‹œê°„ ì‹¤ì‹œê°„ ë¡œê·¸ (0.5ì´ˆë§ˆë‹¤)
                                if (Math.floor(silentTime / 500) !== Math.floor((silentTime - 500) / 500)) {
                                    console.log(`ğŸ”‡ ë¬´ìŒ ì§€ì† ì¤‘... ${(silentTime / 1000).toFixed(1)}ì´ˆ / 4.5ì´ˆ`);
                                }

                                // ë¬´ìŒ 4.5ì´ˆ ê²½ê³¼ ì‹œ í™”ë©´ ì „í™˜ ê°ì§€ ì‹œì‘
                                if (silentTime >= 4500 && !detectedSceneChange) {
                                    detectedSceneChange = true;
                                    console.log('âœ… ë¬´ìŒ 4.5ì´ˆ ê²½ê³¼ â†’ í™”ë©´ ì „í™˜ ê°ì§€ ì‹œì‘');
                                    addLog(`âœ… ë¬´ìŒ 4.5ì´ˆ ê²½ê³¼ â†’ í™”ë©´ ì „í™˜ ê°ì§€ ëŒ€ê¸° ì¤‘`, 'info');
                                }

                                if (detectedSceneChange) {
                                    const currentFrame = sceneChangeDetector.captureFrame();
                                    const diff = sceneChangeDetector.calculateDifference(frameBeforeSilence, currentFrame);

                                    if (diff.changeRatio >= sceneChangeDetector.changeThreshold) {
                                        const elapsed = recordingStartTime ? ((Date.now() - recordingStartTime) / 1000).toFixed(0) : '?';
                                        console.log(`ğŸ¬ í™”ë©´ ì „í™˜ ê°ì§€! (ë¬´ìŒ 4.5ì´ˆ + í™”ë©´) ë³€í™”ìœ¨: ${(diff.changeRatio * 100).toFixed(1)}% â†’ ìë™ë¶„í• `);
                                        addLog(`ğŸ¬ í™”ë©´ ì „í™˜ ê°ì§€! (ë¬´ìŒ 4.5ì´ˆ + í™”ë©´, ë³€í™”ìœ¨: ${(diff.changeRatio * 100).toFixed(1)}%, ${elapsed}ì´ˆ ê²½ê³¼) â†’ ë‹¤ìŒ ì±•í„°ë¡œ ì „í™˜`, 'success');
                                        addLog(`ğŸ” [DEBUG] í™”ë©´ ì „í™˜(ë¬´ìŒ+í™”ë©´)ìœ¼ë¡œ triggerChapterTransition í˜¸ì¶œ - chapterReadyToSplit: ${chapterReadyToSplit}, pendingIndex: ${pendingSplitChapterIndex}`, 'info');
                                        triggerChapterTransition(`ë¬´ìŒ 4.5ì´ˆ + í™”ë©´ ì „í™˜ (ë³€í™”ìœ¨: ${(diff.changeRatio * 100).toFixed(1)}%, ${elapsed}ì´ˆ ê²½ê³¼)`);
                                    }
                                }
                            }
                        }
                    } else {
                        // ìƒˆë¡œìš´ ë¡œì§: í™”ë©´ ì „í™˜ë§Œìœ¼ë¡œ ê°ì§€
                        const isTransition = sceneChangeDetector.checkSceneChange();

                        // 5ì´ˆë§ˆë‹¤ ê°ì§€ ìƒíƒœ ë¡œê·¸ (ë„ˆë¬´ ë§ì€ ë¡œê·¸ ë°©ì§€)
                        const now = Date.now();
                        if (!window.lastSceneCheckLog || now - window.lastSceneCheckLog > 5000) {
                            console.log(`ğŸ” [DEBUG] í™”ë©´ ì „í™˜ ê°ì§€ ì¤‘... (í™”ë©´ë§Œ ëª¨ë“œ, ë¯¼ê°ë„: ${(sceneChangeDetector.changeThreshold * 100).toFixed(0)}%)`);
                            window.lastSceneCheckLog = now;
                        }

                        if (isTransition) {
                            console.log(`ğŸ¬ í™”ë©´ ì „í™˜ ê°ì§€! (í™”ë©´ë§Œ) â†’ ìë™ë¶„í• `);
                            const elapsed = recordingStartTime ? ((Date.now() - recordingStartTime) / 1000).toFixed(0) : '?';
                            addLog(`ğŸ¬ í™”ë©´ ì „í™˜ ê°ì§€! (í™”ë©´ë§Œ, ${elapsed}ì´ˆ ê²½ê³¼) â†’ ë‹¤ìŒ ì±•í„°ë¡œ ì „í™˜`, 'success');
                            addLog(`ğŸ” [DEBUG] í™”ë©´ ì „í™˜(í™”ë©´ë§Œ)ìœ¼ë¡œ triggerChapterTransition í˜¸ì¶œ - chapterReadyToSplit: ${chapterReadyToSplit}, pendingIndex: ${pendingSplitChapterIndex}`, 'info');
                            triggerChapterTransition(`í™”ë©´ ì „í™˜ ê°ì§€ (${elapsed}ì´ˆ ê²½ê³¼)`);
                        }
                    }
                }
            }, 500);
        }

        function stopSceneChangeDetection() {
            if (sceneChangeCheckInterval) {
                clearInterval(sceneChangeCheckInterval);
                sceneChangeCheckInterval = null;
            }
            detectedSceneChange = false;
            sceneChangeTime = null;
            silenceStartForSplit = null;
            frameBeforeSilence = null;
        }

        // í…œí”Œë¦¿ ë§¤ì¹­ ì¤‘ì§€ (cleanupìš©)
        function stopTemplateMatching() {
            if (templateCheckInterval) {
                clearInterval(templateCheckInterval);
                templateCheckInterval = null;
            }
        }

        function triggerChapterTransition(reason = 'ì•Œ ìˆ˜ ì—†ìŒ') {
            // ğŸ” ë””ë²„ê¹…: í˜¸ì¶œ ì¶”ì 
            const stackTrace = new Error().stack;
            console.log('ğŸ” [DEBUG] triggerChapterTransition í˜¸ì¶œë¨');
            console.log('ğŸ” [DEBUG] readyToAutoStop:', readyToAutoStop);
            console.log('ğŸ” [DEBUG] chapterReadyToSplit:', chapterReadyToSplit);
            console.log('ğŸ” [DEBUG] pendingSplitChapterIndex:', pendingSplitChapterIndex);
            console.log('ğŸ” [DEBUG] currentChapterIndex:', currentChapterIndex);
            console.log('ğŸ” [DEBUG] ì „í™˜ ê·¼ê±°:', reason);
            console.log('ğŸ” [DEBUG] í˜¸ì¶œ ìŠ¤íƒ:', stackTrace);

            // âœ… í…œí”Œë¦¿ ë§¤ì¹­ í›„ì—ë„ ê³„ì† ê°ì§€í•˜ê¸° ìœ„í•´ stopSceneChangeDetection í˜¸ì¶œ ì•ˆ í•¨
            // ëŒ€ì‹  í™”ë©´ ì „í™˜ ê°ì§€ ê´€ë ¨ ë³€ìˆ˜ë§Œ ë¦¬ì…‹
            detectedSceneChange = false;
            sceneChangeTime = null;
            silenceStartForSplit = null;
            frameBeforeSilence = null;
            silenceWaitStartTime = null;

            if (readyToAutoStop) {
                addLog(`ğŸ” [DEBUG] ë§ˆì§€ë§‰ ì±•í„° ìë™ ì¢…ë£Œ ì‹¤í–‰ (ê·¼ê±°: ${reason})`, 'info');
                updateStatus('ready', 'âœ… ëª¨ë“  ê°•ì˜ ë…¹ìŒ ì™„ë£Œ! (í…œí”Œë¦¿ ë§¤ì¹­ ê°ì§€)');
                stopRecording();
            } else if (chapterReadyToSplit && pendingSplitChapterIndex >= 0) {
                const endedIdx = pendingSplitChapterIndex;
                const endedName = chapters[endedIdx].name;
                currentChapterIndex = endedIdx + 1;

                addLog(`ğŸ”„ ì±•í„° ì „í™˜ ì‹¤í–‰: ${endedIdx} â†’ ${currentChapterIndex} (ê·¼ê±°: ${reason})`, 'success');

                splitRecordingWithName(endedName);
                renderChapters();

                chapterReadyToSplit = false;
                waitingForSilence = false;
                pendingSplitChapterIndex = -1;
                silenceIndicator.textContent = '(ì „í™˜ ì™„ë£Œ!)';
                silenceIndicator.className = 'silence-indicator';

                // ë‹¤ìŒ ì±•í„°ë¥¼ ìœ„í•´ í™”ë©´ ê°ì§€ê¸°ë§Œ ë¦¬ì…‹ (í…œí”Œë¦¿ ë§¤ì²˜ëŠ” ìœ ì§€)
                if (sceneChangeDetector) {
                    sceneChangeDetector.reset();
                }

                // âœ… íƒ€ì´ë¨¸ì™€ startTime ë¦¬ì…‹í•˜ì—¬ ë‹¤ìŒ ë…¹ìŒì˜ 30ì´ˆ ì¹´ìš´íŠ¸ ë‹¤ì‹œ ì‹œì‘
                startTime = Date.now();
                pausedTime = 0;

                // í™”ë©´ ì „í™˜ ìë™ê°ì§€ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ë‹¤ì‹œ ê°ì§€ ì‹œì‘
                if (sceneChangeDetectionToggle.checked && currentChapterIndex < chapters.length) {
                    console.log('âœ… í™”ë©´ ì „í™˜ ìë™ê°ì§€: ë‹¤ìŒ ì±•í„° ê°ì§€ ì¬ì‹œì‘');
                    chapterReadyToSplit = true;
                    waitingForSilence = true;
                    pendingSplitChapterIndex = currentChapterIndex;
                    silenceIndicator.textContent = '(í™”ë©´ ì „í™˜ìœ¼ë¡œ ìë™ë¶„í•  ëŒ€ê¸° ì¤‘...)';
                    silenceIndicator.className = 'silence-indicator active';
                    startSceneChangeDetection();
                }
            } else {
                addLog('ğŸ” [DEBUG] ì „í™˜ ì¡°ê±´ ë¶ˆë§Œì¡± - ì•„ë¬´ ì‘ì—…ë„ ìˆ˜í–‰í•˜ì§€ ì•ŠìŒ', 'warning');
            }
        }

        // jsPDF ë¼ì´ë¸ŒëŸ¬ë¦¬ ë™ì  ë¡œë“œ
        async function loadJsPdf() {
            if (window.jspdf) return window.jspdf;

            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                script.onload = () => resolve(window.jspdf);
                script.onerror = () => reject(new Error('jsPDF ë¡œë“œ ì‹¤íŒ¨'));
                document.head.appendChild(script);
            });
        }

        // ìº¡ì²˜ëœ ì´ë¯¸ì§€ë“¤ì„ PDFë¡œ ì €ì¥
        async function saveImagesAsPdf(images, filename) {
            if (!images || images.length === 0) {
                console.log('ì €ì¥í•  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            try {
                const isRecording = mediaRecorder && mediaRecorder.state === 'recording';
                const statusMsg = `ğŸ“„ PDF ìƒì„± ì¤‘... (${images.length}ì¥)`;

                if (isRecording) {
                    captureStatus.textContent = statusMsg;
                } else {
                    updateStatus('ready', statusMsg);
                }

                // jsPDF ë¡œë“œ
                const jsPdfLib = await loadJsPdf();
                const { jsPDF } = jsPdfLib;

                // 1280x720 ê°€ë¡œ ë°©í–¥ PDF ìƒì„± (px to mm ë³€í™˜: 1px â‰ˆ 0.264583mm)
                const pdfWidth = 1280 * 0.264583;  // mm
                const pdfHeight = 720 * 0.264583;  // mm

                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: [pdfWidth, pdfHeight]
                });

                for (let i = 0; i < images.length; i++) {
                    const imageData = images[i];

                    // WebP â†’ JPEG ë³€í™˜ (jsPDFëŠ” WebP ë¯¸ì§€ì›)
                    const jpegData = await convertWebPToJpeg(imageData);

                    if (i > 0) {
                        pdf.addPage([pdfWidth, pdfHeight], 'landscape');
                    }

                    // ì´ë¯¸ì§€ë¥¼ í˜ì´ì§€ì— ê½‰ ì°¨ê²Œ ì¶”ê°€
                    pdf.addImage(jpegData, 'JPEG', 0, 0, pdfWidth, pdfHeight);

                    // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
                    if (i % 10 === 0 || i === images.length - 1) {
                        const progressMsg = `ğŸ“„ PDF ìƒì„± ì¤‘... (${i + 1}/${images.length})`;
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            captureStatus.textContent = progressMsg;
                        } else {
                            updateStatus('ready', progressMsg);
                        }
                    }
                }

                // PDF ì €ì¥
                const pdfFilename = `${filename}.pdf`;
                pdf.save(pdfFilename);

                const finalMsg = `âœ… PDF ì €ì¥ ì™„ë£Œ: ${pdfFilename} (${images.length}í˜ì´ì§€)`;
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    captureStatus.textContent = finalMsg;
                    // 5ì´ˆ í›„ì— ì›ë˜ì˜ ìº¡ì²˜ ìƒíƒœ(ğŸ“¸ Nì¥)ë¡œ ë³µêµ¬í•˜ê±°ë‚˜ ë¹„ìš°ê¸°
                    setTimeout(() => {
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            updateCaptureStatus();
                        } else {
                            captureStatus.textContent = '';
                        }
                    }, 5000);
                } else {
                    updateStatus('ready', finalMsg);
                }
                console.log(`PDF ì €ì¥ ì™„ë£Œ: ${pdfFilename}`);

                // ë¡œê·¸ ì¶”ê°€
                addLog(`ğŸ“„ PDF ìƒì„± ì™„ë£Œ: "${filename}.pdf" (${images.length}í˜ì´ì§€)`, 'success');

            } catch (error) {
                console.error('PDF ìƒì„± ì˜¤ë¥˜:', error);
                updateStatus('error', `âŒ PDF ìƒì„± ì‹¤íŒ¨: ${error.message}`);
                addLog(`âŒ PDF ìƒì„± ì‹¤íŒ¨: ${error.message}`, 'error');
            }
        }

        // WebP â†’ JPEG ë³€í™˜ í•¨ìˆ˜
        function convertWebPToJpeg(webpDataUrl) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');

                    // í°ìƒ‰ ë°°ê²½ (JPEGëŠ” íˆ¬ëª…ë„ ë¯¸ì§€ì›)
                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);

                    resolve(canvas.toDataURL('image/jpeg', 0.92));
                };
                img.onerror = () => reject(new Error('ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨'));
                img.src = webpDataUrl;
            });
        }

        function pauseRecording() {
            // ê¸°ì¡´ ì½”ë“œ ê·¸ëŒ€ë¡œ
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.pause();
                isPaused = true;
                pausedTime += Date.now() - startTime;
                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <polygon points="5,3 19,12 5,21"/>
                    </svg>
                `;
                pauseBtn.title = 'ê³„ì†';
                updateStatus('paused', 'â¸ï¸ ì¼ì‹œì •ì§€ë¨');
            } else if (mediaRecorder && mediaRecorder.state === 'paused') {
                mediaRecorder.resume();
                isPaused = false;
                startTime = Date.now();
                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                `;
                pauseBtn.title = 'ì¼ì‹œì •ì§€';
                updateStatus('recording', 'ğŸ”´ ë…¹ìŒ ì¤‘...');
            }
        }

        function stopRecording() {
            try {
                isRecording = false; // ì •ì§€ ìƒíƒœë¡œ ë³€ê²½
                isWaitingForFirstSound = false; // ìµœì´ˆ ëŒ€ê¸° ìƒíƒœ í•´ì œ
                clearInterval(timerInterval);
                clearChapterTimers();

                // âœ… mediaRecorder.onstopì´ ì‹¤í–‰ë˜ê¸° ì „ì— í˜„ì¬ ì±•í„° ì´ë¦„ì„ ì €ì¥
                const finalChapterName = activeChapterName ||
                    (chapters[currentChapterIndex]?.name) ||
                    `ê°•ì˜${lectureCount}`;

                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    // ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚° ë° ë¡œê·¸
                    const actualDuration = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
                    const actualMin = Math.floor(actualDuration / 60);
                    const actualSec = Math.floor(actualDuration % 60);
                    const actualTimeStr = `${actualMin}ë¶„ ${actualSec}ì´ˆ`;

                    // ì˜ˆìƒ ì‹œê°„ê³¼ ë¹„êµ
                    const matchedChapter = chapters.find(ch => ch.name === finalChapterName);
                    if (matchedChapter && matchedChapter.duration && recordingStartTime) {
                        const expectedDuration = matchedChapter.duration;
                        const diff = actualDuration - expectedDuration;
                        const diffAbs = Math.abs(diff);
                        const diffMin = Math.floor(diffAbs / 60);
                        const diffSec = Math.floor(diffAbs % 60);
                        const diffStr = `${diffMin}ë¶„ ${diffSec}ì´ˆ`;

                        const expectedMin = Math.floor(expectedDuration / 60);
                        const expectedSec = Math.floor(expectedDuration % 60);
                        const expectedTimeStr = `${expectedMin}ë¶„ ${expectedSec}ì´ˆ`;

                        if (Math.abs(diff) < 5) {
                            addLog(`â¹ï¸ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ: "${finalChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (ì •í™•!)`, 'success');
                        } else if (diff > 0) {
                            addLog(`â¹ï¸ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ: "${finalChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (+${diffStr} ì´ˆê³¼)`, 'warning');
                        } else {
                            addLog(`â¹ï¸ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ: "${finalChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (-${diffStr} ë¶€ì¡±)`, 'warning');
                        }
                    } else {
                        addLog(`â¹ï¸ ì „ì²´ ë…¹ìŒ ì¢…ë£Œ: "${finalChapterName}" | ì‹¤ì œ: ${actualTimeStr}`, 'info');
                    }

                    // âœ… ì €ì¥ëœ ì±•í„° ì´ë¦„ìœ¼ë¡œ ë…¹ìŒ ì €ì¥
                    stopCapture();
                    const imagesToSave = [...capturedImages];
                    capturedImages = [];
                    captureCount = 0;

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                        saveRecordingWithNameAndImages(audioBlob, currentRecordingType, finalChapterName, imagesToSave);
                        audioChunks = [];
                    };

                    mediaRecorder.stop();
                }

                // UI ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                recordBtn.classList.remove('recording');
                recordBtn.disabled = false;
                pauseBtn.disabled = true;
                stopBtn.disabled = true;
                newLectureBtn.disabled = true;
                includeSystemAudio.disabled = false;
                includeMic.disabled = false;
                silenceIndicator.textContent = '';
                silenceStart = null;
                currentChapterIndex = 0;
                activeChapterName = '';
                renderChapters();

                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                `;
                pauseBtn.title = 'ì¼ì‹œì •ì§€';
                timerDisplay.textContent = '00:00:00';
                progressSection.style.display = 'none'; // ì •ì§€ ì‹œ ìˆ¨ê¹€
                progressBar.style.width = '0%';

                // ë¦¬ì†ŒìŠ¤ ì •ë¦¬ (ëª¨ë“  ìŠ¤íŠ¸ë¦¼ ì¤‘ë‹¨)
                cleanup();

                updateStatus('ready', 'âœ… ë…¹ìŒ ì™„ë£Œ! ìƒˆ ë…¹ìŒì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            } catch (err) {
                console.error('ë…¹ìŒ ì •ì§€ ì¤‘ ì˜¤ë¥˜:', err);
                updateStatus('error', 'âŒ ë…¹ìŒ ì •ì§€ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + err.message);
                cleanup(); // ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë”ë¼ë„ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œë„
            }
        }

        function saveRecording(blob, type) {
            const now = new Date();
            const name = `ê°•ì˜${lectureCount}_${now.toLocaleDateString('ko-KR')}_${now.toLocaleTimeString('ko-KR').replace(/:/g, '-')}`;
            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type
            };

            recordings.unshift(recording);
            renderRecordings();

            if (capturedImages.length > 0) {
                saveImagesAsPdf([...capturedImages], name);
                capturedImages = [];
                captureCount = 0;
                updateCaptureStatus();
            }
        }

        function getTypeBadge(type) {
            // ê·¸ëŒ€ë¡œ
            switch (type) {
                case 'system':
                    return '<span class="recording-badge badge-system">ğŸ”Š ì‹œìŠ¤í…œ</span>';
                case 'mic':
                    return '<span class="recording-badge badge-mic">ğŸ¤ ë§ˆì´í¬</span>';
                case 'both':
                    return '<span class="recording-badge badge-both">ğŸ§ ì‹œìŠ¤í…œ+ë§ˆì´í¬</span>';
                default:
                    return '';
            }
        }

        function renderRecordings() {
            if (recordings.length === 0) {
                recordingsList.innerHTML = '<div class="empty-state">ë…¹ìŒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>';
                downloadAllBtn.disabled = true;
                return;
            }

            downloadAllBtn.disabled = false;

            recordingsList.innerHTML = recordings.map(rec => {
                const durationText = rec.duration ? ` â€¢ ì¬ìƒì‹œê°„: ${rec.duration}` : '';
                return `
                <div class="recording-item" data-id="${rec.id}">
                    <div class="recording-header">
                        <div class="recording-info">
                            <div class="recording-name">${rec.name}</div>
                            <div class="recording-meta">${rec.date} ${getTypeBadge(rec.type)}${durationText}</div>
                        </div>
                        <div class="recording-actions">
                            <button class="btn-small btn-download" onclick="downloadRecording(${rec.id})" title="ë‹¤ìš´ë¡œë“œ">
                                <svg viewBox="0 0 24 24">
                                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                                </svg>
                            </button>
                            <button class="btn-small btn-delete" onclick="deleteRecording(${rec.id})" title="ì‚­ì œ">
                                <svg viewBox="0 0 24 24">
                                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <audio controls src="${rec.url}" onloadedmetadata="updateRecordingDuration(${rec.id}, this)"></audio>
                </div>
                `;
            }).join('');
        }

        // ì˜¤ë””ì˜¤ ë©”íƒ€ë°ì´í„° ë¡œë“œ í›„ ì¬ìƒì‹œê°„ ì—…ë°ì´íŠ¸
        function updateRecordingDuration(id, audioElement) {
            const recording = recordings.find(r => r.id === id);
            if (recording && audioElement.duration && !isNaN(audioElement.duration) && isFinite(audioElement.duration)) {
                const actualDuration = Math.floor(audioElement.duration); // ì‹¤ì œ ì¬ìƒì‹œê°„ (ì´ˆ)

                // ë‚´ë¶€ì ìœ¼ë¡œë§Œ ì €ì¥ (UIì—ëŠ” í‘œì‹œí•˜ì§€ ì•ŠìŒ)
                recording.actualDuration = actualDuration;

                // UIì—ëŠ” ì‹œê°„ ì •ë³´ë¥¼ í‘œì‹œí•˜ì§€ ì•ŠìŒ (ë¡œê·¸ì—ë§Œ í‘œì‹œë¨)
            }
        }

        // (downloadAll / downloadRecording / deleteRecording / splitRecording í•¨ìˆ˜ëŠ” ê¸°ì¡´ê³¼ ë™ì¼)

        recordBtn.addEventListener('click', startRecording);
        pauseBtn.addEventListener('click', pauseRecording);
        stopBtn.addEventListener('click', stopRecording);
        newLectureBtn.addEventListener('click', () => splitRecording());

        // âœ… ì±•í„°ëª… ê¸°ë°˜ ë¶„í•  ì €ì¥
        function splitRecordingWithName(chapterName) {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                const endedChapterName =
                    chapterName ||
                    activeChapterName ||
                    (chapters[currentChapterIndex]?.name) ||
                    `ê°•ì˜${lectureCount}`;

                // ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚°
                const actualDuration = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0; // ì´ˆ ë‹¨ìœ„
                const actualMin = Math.floor(actualDuration / 60);
                const actualSec = Math.floor(actualDuration % 60);
                const actualTimeStr = `${actualMin}ë¶„ ${actualSec}ì´ˆ`;

                // ì˜ˆìƒ ì‹œê°„ê³¼ ë¹„êµ
                const matchedChapter = chapters.find(ch => ch.name === endedChapterName);
                if (matchedChapter && matchedChapter.duration && recordingStartTime) {
                    const expectedDuration = matchedChapter.duration; // ì´ˆ
                    const diff = actualDuration - expectedDuration;
                    const diffAbs = Math.abs(diff);
                    const diffMin = Math.floor(diffAbs / 60);
                    const diffSec = Math.floor(diffAbs % 60);
                    const diffStr = `${diffMin}ë¶„ ${diffSec}ì´ˆ`;

                    const expectedMin = Math.floor(expectedDuration / 60);
                    const expectedSec = Math.floor(expectedDuration % 60);
                    const expectedTimeStr = `${expectedMin}ë¶„ ${expectedSec}ì´ˆ`;

                    if (Math.abs(diff) < 5) {
                        // ì˜¤ì°¨ 5ì´ˆ ì´ë‚´ëŠ” ì •í™•
                        addLog(`â¹ï¸ ë…¹ìŒ ì¢…ë£Œ: "${endedChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (ì •í™•!)`, 'success');
                    } else if (diff > 0) {
                        // ì´ˆê³¼
                        addLog(`â¹ï¸ ë…¹ìŒ ì¢…ë£Œ: "${endedChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (+${diffStr} ì´ˆê³¼)`, 'warning');
                    } else {
                        // ë¶€ì¡±
                        addLog(`â¹ï¸ ë…¹ìŒ ì¢…ë£Œ: "${endedChapterName}" | ì˜ˆìƒ: ${expectedTimeStr}, ì‹¤ì œ: ${actualTimeStr} (-${diffStr} ë¶€ì¡±)`, 'warning');
                    }
                } else {
                    addLog(`â¹ï¸ ë…¹ìŒ ì¢…ë£Œ: "${endedChapterName}" | ì‹¤ì œ: ${actualTimeStr}`, 'info');
                }

                stopCapture();
                const imagesToSave = [...capturedImages];
                capturedImages = [];
                captureCount = 0;

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                    saveRecordingWithNameAndImages(audioBlob, currentRecordingType, endedChapterName, imagesToSave);
                    audioChunks = [];
                };

                mediaRecorder.stop();

                // âœ… ì¦‰ì‹œ ë‹¤ìŒ ë…¹ìŒ ì‹œì‘ (ë”œë ˆì´ ì œê±°)
                // ì •ì§€ ë²„íŠ¼ì´ ëˆŒë ¸ë‹¤ë©´ ìƒˆë¡œìš´ ë…¹ìŒì„ ì‹œì‘í•˜ì§€ ì•ŠìŒ
                if (!isRecording && !isWaitingForFirstSound) return;

                if (streams.length > 0 && streams.some(s => s.active)) {
                    let finalStream;
                    if (streams.length > 1) {
                        finalStream = mergeAudioStreams(streams);
                    } else {
                        finalStream = streams[0];
                    }

                    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                        ? 'audio/webm;codecs=opus'
                        : 'audio/webm';

                    mediaRecorder = new MediaRecorder(finalStream, { mimeType });

                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                        const finalName =
                            activeChapterName ||
                            (chapters[currentChapterIndex]?.name) ||
                            `ê°•ì˜${lectureCount}`;
                        saveRecordingWithName(audioBlob, currentRecordingType, finalName);
                        audioChunks = [];
                    };

                    // âœ… ë¶„í•  ì‹œì—ë„ ì†Œë¦¬ ê°ì§€ ì²´í¬
                    if (autoStartOnSound.checked) {
                        isWaitingForFirstSound = true;
                        isRecording = false; // ì‹¤ì œ ë…¹ìŒ ì „ê¹Œì§€ëŠ” false
                        const nextName = chapters[currentChapterIndex]?.shortName || chapters[currentChapterIndex]?.name || `ê°•ì˜ ${lectureCount}`;
                        updateStatus('recording', `ğŸµ ì†Œë¦¬ ëŒ€ê¸° ì¤‘... (${nextName})`);
                        // actuallyStartRecording()ì´ ë£¨í”„ì—ì„œ í˜¸ì¶œë  ê²ƒì„
                    } else {
                        // âœ… ë¶„í•  í›„ì—ëŠ” ë°”ë¡œ ì‹œì‘ (ë”œë ˆì´ ì—†ìŒ)
                        actuallyStartRecording();
                    }
                }
            }
        }

        function saveRecordingWithNameAndImages(blob, type, name, images) {
            const now = new Date();

            // í•´ë‹¹ ì±•í„°ì˜ ì˜ˆìƒ ì¬ìƒì‹œê°„ ì°¾ê¸°
            let expectedDuration = null;
            const matchedChapter = chapters.find(ch => ch.name === name);
            if (matchedChapter && matchedChapter.duration) {
                expectedDuration = matchedChapter.duration; // seconds
            }

            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type,
                expectedDuration: expectedDuration
            };

            recordings.unshift(recording);
            renderRecordings();

            // ë¡œê·¸ ì¶”ê°€
            const fileSizeMB = (blob.size / (1024 * 1024)).toFixed(2);
            addLog(`ğŸ’¾ ë…¹ìŒ ì €ì¥ ì™„ë£Œ: "${name}" (${fileSizeMB}MB)`, 'success');

            if (images && images.length > 0) {
                addLog(`ğŸ“¸ ìº¡ì²˜ ì´ë¯¸ì§€ ${images.length}ê°œ â†’ PDF ë³€í™˜ ì‹œì‘`, 'info');
                saveImagesAsPdf(images, name);
            }
        }

        function saveRecordingWithName(blob, type, name) {
            const now = new Date();

            // í•´ë‹¹ ì±•í„°ì˜ ì˜ˆìƒ ì¬ìƒì‹œê°„ ì°¾ê¸°
            let expectedDuration = null;
            const matchedChapter = chapters.find(ch => ch.name === name);
            if (matchedChapter && matchedChapter.duration) {
                expectedDuration = matchedChapter.duration; // seconds
            }

            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type,
                expectedDuration: expectedDuration
            };

            recordings.unshift(recording);
            renderRecordings();

            if (capturedImages.length > 0) {
                saveImagesAsPdf([...capturedImages], name);
                capturedImages = [];
                captureCount = 0;
                updateCaptureStatus();
            }
        }

        // ëª©ì°¨ íŒŒì‹± í•¨ìˆ˜
        function parseCurriculum(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            const chapters = [];

            let currentLectureNum = '';
            let currentPart = '';
            let currentChapter = '';
            let lastTitleLine = '';

            for (const line of lines) {
                // 1. ê°•ì˜ ë²ˆí˜¸ (ìˆ«ìë§Œ ìˆëŠ” ì¤„, 1-3ìë¦¬ - ì˜ˆ: 24)
                if (/^\d{1,3}$/.test(line)) {
                    currentLectureNum = line;
                    // ë²ˆí˜¸ë§Œ ìˆëŠ” ì¤„ì€ ì œëª© í›„ë³´ë¡œ ì“°ì§€ ì•ŠìŒ
                    continue;
                }

                // 2. Part ì¸ì‹ (Part 1. ..., Part 1)
                const partMatch = line.match(/^Part\s*(\d+)[.\s-]*(.*)/i);
                if (partMatch) {
                    currentPart = `Part ${partMatch[1]}`;
                    const remaining = partMatch[2].trim();
                    if (remaining) {
                        lastTitleLine = remaining;
                    }
                    continue; // âœ… ë©”íƒ€ë°ì´í„° ì²˜ë¦¬ í›„ ë‹¤ìŒ ì¤„ë¡œ (ì¤‘ë³µ ë°©ì§€)
                }

                // 3. Chapter ì¸ì‹ (Ch 3. ..., Chapter 3. ...)
                const chapterMatch = line.match(/^(?:Ch|Chapter)\s*(\d+)[.\s-]*(.*)/i);
                if (chapterMatch) {
                    currentChapter = `Ch ${chapterMatch[1]}`;
                    const remaining = chapterMatch[2].trim();
                    if (remaining) {
                        lastTitleLine = remaining;
                    }
                    continue; // âœ… ë©”íƒ€ë°ì´í„° ì²˜ë¦¬ í›„ ë‹¤ìŒ ì¤„ë¡œ (ì¤‘ë³µ ë°©ì§€)
                }

                // 4. ì‹œê°„ì´ í¬í•¨ëœ ì¤„ì¸ì§€ í™•ì¸ (MM:SS)
                const timeMatch = line.match(/(\d+):(\d+)/);
                if (timeMatch) {
                    const minutes = parseInt(timeMatch[1]);
                    const seconds = parseInt(timeMatch[2]);
                    const totalSeconds = minutes * 60 + seconds;

                    // í˜„ì¬ ì¤„ì—ì„œ ì‹œê°„ ë¶€ë¶„ì„ ì œì™¸í•œ ê²ƒì´ ì œëª©ì¸ì§€ í™•ì¸
                    let titleInLine = line.replace(/(\d+):(\d+)/, '').replace(/^[.\s-]+/, '').trim();

                    // ì œëª© ê²°ì •: í˜„ì¬ ì¤„ì— ì œëª©ì´ ì—†ìœ¼ë©´ ì´ì „ ì¤„(lastTitleLine) ì‚¬ìš©
                    let finalTitle = titleInLine || lastTitleLine;

                    if (finalTitle) {
                        let nameParts = [];
                        if (currentLectureNum) nameParts.push(currentLectureNum);
                        if (currentPart) nameParts.push(currentPart);
                        if (currentChapter) nameParts.push(currentChapter);
                        nameParts.push(finalTitle);

                        const fullName = nameParts.join(' - ');

                        chapters.push({
                            name: fullName,
                            shortName: finalTitle,
                            originalDuration: totalSeconds,
                            duration: totalSeconds
                        });

                        // ì‚¬ìš©í•œ ì œëª©ì€ ë¹„ì›Œì¤Œ (ë‹¤ìŒ ì±•í„° ì˜¤ì¸ ë°©ì§€)
                        lastTitleLine = '';
                    }
                    continue;
                }

                // 5. ê¸°íƒ€ ì¼ë°˜ í…ìŠ¤íŠ¸ (ì œëª© í›„ë³´)
                // ì§„í–‰ë¥  í‘œì‹œ(0/4)ë‚˜ ë‚ ì§œ ë“± ë¶ˆí•„ìš” íŒ¨í„´ ì œì™¸
                if (/^\d+\/\d+$/.test(line)) continue;
                if (/^\d{2}:\d{2}$/.test(line)) continue; // ì‹œê°„ë§Œ ìˆëŠ” ì¤„ì€ ìœ„ 4ë²ˆì—ì„œ ì²˜ë¦¬ë¨

                // ë¶ˆí•„ìš”í•œ ì¥ì‹ ì œê±°í•˜ê³  ì œëª© í›„ë³´ë¡œ ì €ì¥
                lastTitleLine = line.replace(/^[.\s-]+/, '').trim();
            }

            return chapters;
        }

        // ì±•í„° ë Œë”ë§
        function renderChapters() {
            if (chapters.length === 0) {
                chapterList.innerHTML = '';
                chapterProgress.innerHTML = '';
                return;
            }

            const speed = parseFloat(playbackSpeed.value);

            let totalOriginal = 0;
            let totalAdjusted = 0;

            chapterList.innerHTML = chapters.map((ch, i) => {
                const adjustedDuration = Math.ceil(ch.originalDuration / speed);
                ch.duration = adjustedDuration;
                totalOriginal += ch.originalDuration;
                totalAdjusted += adjustedDuration;

                const isActive = i === currentChapterIndex;
                const isDone = i < currentChapterIndex;

                const originalTime = formatTime(ch.originalDuration * 1000);
                const adjustedTime = formatTime(adjustedDuration * 1000);

                return `
                    <div class="chapter-item ${isActive ? 'active' : ''} ${isDone ? 'done' : ''}">
                        <span class="chapter-number">${i + 1}</span>
                        <span class="chapter-name">${ch.name}</span>
                        <span class="chapter-time">${originalTime} â†’ ${adjustedTime}</span>
                    </div>
                `;
            }).join('');

            chapterProgress.innerHTML = `
                <div>ì´ ${chapters.length}ê°œ ì±•í„°</div>
                <div>ì›ë³¸: ${formatTime(totalOriginal * 1000)} â†’ ì¡°ì •: ${formatTime(totalAdjusted * 1000)}</div>
            `;
        }

        // ì±•í„° íƒ€ì´ë¨¸ ì‹œì‘
        function startChapterTimers(startIndex = 0) {
            clearChapterTimers();
            activeChapterName = chapters[startIndex]?.name || '';

            // âœ… í…œí”Œë¦¿ ë§¤ì¹­ì´ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì¦‰ì‹œ ê°ì§€ ì‹œì‘
            if (templateMatchingToggle.checked && templateImage) {
                console.log('âœ… í…œí”Œë¦¿ ë§¤ì¹­ ëª¨ë“œ: ì¦‰ì‹œ ê°ì§€ ì‹œì‘');
                addLog(`ğŸ” [DEBUG] í…œí”Œë¦¿ ë§¤ì¹­ ëª¨ë“œ ì‹œì‘ - startIndex: ${startIndex}`, 'info');

                // í…œí”Œë¦¿ ë§¤ì¹­ìœ¼ë¡œë§Œ ë¶„í•  ì§„í–‰
                chapterReadyToSplit = true;
                waitingForSilence = true;
                pendingSplitChapterIndex = startIndex;
                silenceIndicator.textContent = '(í…œí”Œë¦¿ ë§¤ì¹­ìœ¼ë¡œ ìë™ë¶„í•  ëŒ€ê¸° ì¤‘...)';
                silenceIndicator.className = 'silence-indicator active';

                // í™”ë©´ ê°ì§€ ì‹œì‘
                startSceneChangeDetection();
            }
            // âœ… í™”ë©´ ì „í™˜ ìë™ê°ì§€ê°€ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ ì¦‰ì‹œ ê°ì§€ ì‹œì‘
            else if (sceneChangeDetectionToggle.checked) {
                console.log('âœ… í™”ë©´ ì „í™˜ ìë™ê°ì§€ ëª¨ë“œ: ì¦‰ì‹œ ê°ì§€ ì‹œì‘');
                addLog(`ğŸ” [DEBUG] í™”ë©´ ì „í™˜ ìë™ê°ì§€ ëª¨ë“œ ì‹œì‘ - startIndex: ${startIndex}`, 'info');

                // í™”ë©´ ì „í™˜ ìë™ê°ì§€ë¡œë§Œ ë¶„í•  ì§„í–‰
                chapterReadyToSplit = true;
                waitingForSilence = true;
                pendingSplitChapterIndex = startIndex;
                silenceIndicator.textContent = '(í™”ë©´ ì „í™˜ìœ¼ë¡œ ìë™ë¶„í•  ëŒ€ê¸° ì¤‘...)';
                silenceIndicator.className = 'silence-indicator active';

                // í™”ë©´ ê°ì§€ ì‹œì‘
                startSceneChangeDetection();

                // âœ… ì˜ˆìƒ ë…¹ìŒ ì‹œê°„ ê²½ê³¼ ì‹œ 20ì´ˆ ëŒ€ê¸° íƒ€ì´ë¨¸ ì„¤ì •
                // ì˜ˆìƒ ì‹œê°„ì´ ì§€ë‚˜ë„ í…œí”Œë¦¿ ë§¤ì¹­ì´ ë˜ì–´ì•¼ ë„˜ì–´ê°€ì§€ë§Œ, ìµœëŒ€ 20ì´ˆê¹Œì§€ë§Œ ëŒ€ê¸°
                let cumulativeTime = 0;
                for (let i = startIndex; i < chapters.length; i++) {
                    const ch = chapters[i];
                    cumulativeTime += ch.duration * 1000;

                    // ì˜ˆìƒ ì‹œê°„ + 20ì´ˆ í›„ ê°•ì œ ì „í™˜ íƒ€ì´ë¨¸
                    const timeoutTime = cumulativeTime + 20000; // +20ì´ˆ
                    const timeoutTimer = setTimeout(() => {
                        // ì´ë¯¸ ì „í™˜ë˜ì—ˆìœ¼ë©´ ë¬´ì‹œ
                        if (currentChapterIndex !== i) return;

                        console.log(`â° í…œí”Œë¦¿ ë§¤ì¹­ íƒ€ì„ì•„ì›ƒ: ì±•í„° ${i + 1} (ì˜ˆìƒì‹œê°„ ê²½ê³¼ í›„ 20ì´ˆ ëŒ€ê¸° ì™„ë£Œ) â†’ ê°•ì œ ì „í™˜`);
                        addLog(`â° í…œí”Œë¦¿ ë§¤ì¹­ íƒ€ì„ì•„ì›ƒ: ì±•í„° ${i + 1} (ì˜ˆìƒì‹œê°„+20ì´ˆ ê²½ê³¼) â†’ ê°•ì œ ì „í™˜`, 'warning');

                        if (i < chapters.length - 1) {
                            // ë‹¤ìŒ ì±•í„°ë¡œ ê°•ì œ ì „í™˜
                            const endedChapterName =
                                activeChapterName ||
                                (chapters[i]?.name) ||
                                `ê°•ì˜${lectureCount}`;

                            stopCapture();
                            const imagesToSave = [...capturedImages];
                            capturedImages = [];
                            captureCount = 0;

                            mediaRecorder.onstop = () => {
                                const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                                saveRecordingWithNameAndImages(audioBlob, currentRecordingType, endedChapterName, imagesToSave);
                                audioChunks = [];
                            };

                            mediaRecorder.stop();

                            // ì¦‰ì‹œ ë‹¤ìŒ ë…¹ìŒ ì‹œì‘
                            if (!isRecording && !isWaitingForFirstSound) return;

                            if (streams.length > 0 && streams.some(s => s.active)) {
                                let finalStream;
                                if (streams.length > 1) {
                                    finalStream = mergeAudioStreams(streams);
                                } else {
                                    finalStream = streams[0];
                                }

                                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                                    ? 'audio/webm;codecs=opus'
                                    : 'audio/webm';

                                mediaRecorder = new MediaRecorder(finalStream, { mimeType });

                                mediaRecorder.ondataavailable = (event) => {
                                    if (event.data.size > 0) {
                                        audioChunks.push(event.data);
                                    }
                                };

                                mediaRecorder.onstop = () => {
                                    const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                                    const finalName =
                                        activeChapterName ||
                                        (chapters[currentChapterIndex]?.name) ||
                                        `ê°•ì˜${lectureCount}`;
                                    saveRecordingWithName(audioBlob, currentRecordingType, finalName);
                                    audioChunks = [];
                                };

                                // ë‹¤ìŒ ì±•í„°ë¡œ ì´ë™
                                currentChapterIndex = i + 1;
                                activeChapterName = chapters[currentChapterIndex]?.name || '';
                                renderChapters();

                                // ë…¹ìŒ ì‹œì‘ (íƒ€ì´ë¨¸ ì¬ì„¤ì •)
                                if (autoStartOnSound.checked) {
                                    isWaitingForFirstSound = true;
                                    isRecording = false;
                                    const nextName = chapters[currentChapterIndex]?.shortName || chapters[currentChapterIndex]?.name || `ê°•ì˜ ${lectureCount}`;
                                    updateStatus('recording', `ğŸµ ì†Œë¦¬ ëŒ€ê¸° ì¤‘... (${nextName})`);
                                } else {
                                    actuallyStartRecording();
                                }

                                // ë‹¤ìŒ ì±•í„° íƒ€ì´ë¨¸ ì‹œì‘
                                startChapterTimers(currentChapterIndex);
                            }
                        } else if (autoStopCheckbox.checked) {
                            // ë§ˆì§€ë§‰ ì±•í„° â†’ ìë™ ì¢…ë£Œ
                            console.log('â° í…œí”Œë¦¿ ë§¤ì¹­ íƒ€ì„ì•„ì›ƒ: ë§ˆì§€ë§‰ ì±•í„° â†’ ìë™ ì¢…ë£Œ');
                            addLog('â° í…œí”Œë¦¿ ë§¤ì¹­ íƒ€ì„ì•„ì›ƒ: ë§ˆì§€ë§‰ ì±•í„° â†’ ìë™ ì¢…ë£Œ', 'warning');
                            stopRecording();
                        }
                    }, timeoutTime);

                    chapterTimers.push(timeoutTimer);
                }

                return;
            }

            // í™”ë©´ ì „í™˜ ìë™ê°ì§€ ëª¨ë“œì—ì„œëŠ” íƒ€ì´ë¨¸ ë¶ˆí•„ìš” (ì¦‰ì‹œ ê°ì§€ ì‹œì‘)
            console.log('âœ… í™”ë©´ ì „í™˜ ìë™ê°ì§€ ëª¨ë“œ: íƒ€ì´ë¨¸ ì„¤ì • ìƒëµ');
        }

        // ì±•í„° íƒ€ì´ë¨¸ í´ë¦¬ì–´
        function clearChapterTimers() {
            chapterTimers.forEach(t => clearTimeout(t));
            chapterTimers = [];
            chapterReadyToSplit = false;
            waitingForSilence = false;
            pendingSplitChapterIndex = -1;
            readyToAutoStop = false;
            silenceStartForSplit = null;
            silenceWaitStartTime = null;

            // í™”ë©´ ë³€í™” ê°ì§€ ì¤‘ì§€
            stopSceneChangeDetection();
        }

        // ìˆ˜ë™ ë¶„í•  (ìƒˆ ê°•ì˜ ë²„íŠ¼)
        function splitRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                // âœ… ì±•í„° ëª¨ë“œì¼ ë•ŒëŠ” triggerChapterTransition í˜¸ì¶œ
                if (chapters.length > 0 && currentChapterIndex < chapters.length) {
                    console.log('ğŸ” [ë¬´ìŒ ê°ì§€ ìë™ë¶„í• ] ì±•í„° ëª¨ë“œ ê°ì§€ â†’ triggerChapterTransition í˜¸ì¶œ');

                    // ì±•í„° ì „í™˜ì„ ìœ„í•œ í”Œë˜ê·¸ ì„¤ì •
                    chapterReadyToSplit = true;
                    pendingSplitChapterIndex = currentChapterIndex;

                    triggerChapterTransition('ë¬´ìŒ ê°ì§€ ìë™ë¶„í• ');
                    return;
                }

                // âœ… ì¼ë°˜ ëª¨ë“œ (ì±•í„° ì—†ìŒ)
                const currentName = activeChapterName || `ê°•ì˜${lectureCount}`;
                lectureCount++;

                // ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚° ë° ë¡œê·¸
                const actualDuration = recordingStartTime ? (Date.now() - recordingStartTime) / 1000 : 0;
                const actualMin = Math.floor(actualDuration / 60);
                const actualSec = Math.floor(actualDuration % 60);
                const actualTimeStr = `${actualMin}ë¶„ ${actualSec}ì´ˆ`;
                addLog(`â¹ï¸ ìˆ˜ë™ ë¶„í• : "${currentName}" | ì‹¤ì œ: ${actualTimeStr}`, 'info');

                stopCapture();
                const imagesToSave = [...capturedImages];
                capturedImages = [];
                captureCount = 0;

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: currentMimeType });
                    saveRecordingWithNameAndImages(audioBlob, currentRecordingType, currentName, imagesToSave);
                    audioChunks = [];
                };

                mediaRecorder.stop();

                setTimeout(() => {
                    // ì •ì§€ ë²„íŠ¼ì´ ëˆŒë ¸ë‹¤ë©´ ìƒˆë¡œìš´ ë…¹ìŒì„ ì‹œì‘í•˜ì§€ ì•ŠìŒ
                    if (!isRecording && !isWaitingForFirstSound) return;

                    if (streams.length > 0 && streams.some(s => s.active)) {
                        let finalStream;
                        if (streams.length > 1) {
                            finalStream = mergeAudioStreams(streams);
                        } else {
                            finalStream = streams[0];
                        }

                        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                            ? 'audio/webm;codecs=opus'
                            : 'audio/webm';

                        mediaRecorder = new MediaRecorder(finalStream, { mimeType });

                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };

                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: mimeType });
                            const finalName = activeChapterName || `ê°•ì˜${lectureCount}`;
                            saveRecordingWithName(audioBlob, currentRecordingType, finalName);
                            audioChunks = [];
                        };

                        // âœ… ë¶„í•  ì‹œì—ë„ ì†Œë¦¬ ê°ì§€ ì²´í¬
                        if (autoStartOnSound.checked) {
                            isWaitingForFirstSound = true;
                            isRecording = false;
                            activeChapterName = `ê°•ì˜${lectureCount}`;
                            updateStatus('recording', `ğŸµ ì†Œë¦¬ ëŒ€ê¸° ì¤‘... (ê°•ì˜ ${lectureCount})`);
                        } else {
                            actuallyStartRecording();
                        }
                    }
                }, 100);
            }
        }

        // ë…¹ìŒ ë‹¤ìš´ë¡œë“œ
        function downloadRecording(id) {
            const recording = recordings.find(r => r.id === id);
            if (recording) {
                const ext = currentMimeType.includes('ogg') ? 'ogg' : 'webm';
                const a = document.createElement('a');
                a.href = recording.url;
                a.download = `${recording.name}.${ext}`;
                a.click();
            }
        }

        // ë…¹ìŒ ì‚­ì œ
        function deleteRecording(id) {
            const index = recordings.findIndex(r => r.id === id);
            if (index > -1) {
                URL.revokeObjectURL(recordings[index].url);
                recordings.splice(index, 1);
                renderRecordings();
            }
        }

        // ì „ì²´ ë‹¤ìš´ë¡œë“œ
        async function downloadAll() {
            const ext = currentMimeType.includes('ogg') ? 'ogg' : 'webm';
            for (const recording of recordings) {
                const a = document.createElement('a');
                a.href = recording.url;
                a.download = `${recording.name}.${ext}`;
                a.click();
                await new Promise(r => setTimeout(r, 500));
            }
        }

        downloadAllBtn.addEventListener('click', downloadAll);

        // ë§ˆì§€ë§‰ ë¶€ë¶„ ì˜ˆì‹œ
        if (parseBtn) {
            parseBtn.addEventListener('click', () => {
                console.log('ëª©ì°¨ ë¶„ì„ ë²„íŠ¼ í´ë¦­ë¨');
                const text = curriculumInput.value;
                console.log('ì…ë ¥ëœ í…ìŠ¤íŠ¸:', text);
                chapters = parseCurriculum(text);
                console.log('íŒŒì‹±ëœ ì±•í„°:', chapters);
                currentChapterIndex = 0;
                activeChapterName = chapters[0]?.name || '';
                renderChapters();

                if (chapters.length > 0) {
                    updateStatus('ready', `âœ… ${chapters.length}ê°œ ì±•í„° ì¸ì‹ë¨`);
                } else {
                    updateStatus('ready', 'âš ï¸ ì±•í„°ë¥¼ ì¸ì‹í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì‹œê°„(MM:SS)ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.');
                }
            });
        } else {
            console.error('parseBtn ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        }

        clearBtn.addEventListener('click', () => {
            curriculumInput.value = '';
            chapters = [];
            currentChapterIndex = 0;
            activeChapterName = '';
            clearChapterTimers();
            renderChapters();
            updateStatus('ready', 'ì¤€ë¹„ë¨ - ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”');
        });

        playbackSpeed.addEventListener('change', () => {
            renderChapters();
        });

        // ì±•í„° ëª¨ë“œ ë¬´ìŒ ì„¤ì • ì´ë²¤íŠ¸
        chapterSilence5.addEventListener('change', (e) => {
            console.log(`[ì±•í„° ëª¨ë“œ] ì”ì—¬ 5ì´ˆ ë¯¸ë§Œ ë¬´ìŒ ì¡°ê±´ ë³€ê²½: ${parseInt(e.target.value) / 1000}ì´ˆ`);
        });

        chapterSilence10.addEventListener('change', (e) => {
            console.log(`[ì±•í„° ëª¨ë“œ] ì”ì—¬ 5~10ì´ˆ ë¬´ìŒ ì¡°ê±´ ë³€ê²½: ${parseInt(e.target.value) / 1000}ì´ˆ`);
        });

        // í™”ë©´ ì „í™˜ ë¯¼ê°ë„ ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸
        sceneChangeSensitivity.addEventListener('input', (e) => {
            const value = e.target.value;
            sensitivityValue.textContent = `${value}%`;

            // í˜„ì¬ ê°ì§€ê¸°ê°€ ìˆìœ¼ë©´ ë¯¼ê°ë„ ì—…ë°ì´íŠ¸
            if (sceneChangeDetector) {
                sceneChangeDetector.changeThreshold = value / 100;
            }
        });

        // í™”ë©´ì „í™˜ ê°ì§€ ì¡°ê±´ ì²´í¬ë°•ìŠ¤ ë³€ê²½
        const updateDetectionModes = () => {
            const modes = [];
            if (detectBasic.checked) modes.push('ê¸°ë³¸');
            if (detectMode1.checked) modes.push('ëª¨ë“œ1');
            if (detectMode2.checked) modes.push('ëª¨ë“œ2');
            if (detectMode3.checked) modes.push('ëª¨ë“œ3');

            // ëª¨ë“œ2 ì²´í¬ ì‹œ ì´ë¯¸ì§€ ì—…ë¡œë“œ UI í‘œì‹œ
            if (detectMode2.checked) {
                mode2ImageUpload.style.display = 'block';
            } else {
                mode2ImageUpload.style.display = 'none';
            }

            console.log(`ğŸ”„ í™”ë©´ì „í™˜ ê°ì§€ ì¡°ê±´: ${modes.join(' AND ')}`);
            addLog(`ğŸ”„ ê°ì§€ ì¡°ê±´: ${modes.join(' AND ')}`, 'info');
        };

        detectBasic.addEventListener('change', updateDetectionModes);
        detectMode1.addEventListener('change', updateDetectionModes);
        detectMode2.addEventListener('change', updateDetectionModes);
        detectMode3.addEventListener('change', updateDetectionModes);

        // ëª¨ë“œ2 ì´ë¯¸ì§€ ì—…ë¡œë“œ ë²„íŠ¼ í´ë¦­
        uploadMode2ImageBtn.addEventListener('click', () => {
            mode2ImageInput.click();
        });

        // ëª¨ë“œ2 ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ
        let mode2ReferenceImage = null;
        mode2ImageInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const img = new Image();
                img.src = URL.createObjectURL(file);
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                });

                // ìº”ë²„ìŠ¤ì— ê·¸ë ¤ì„œ ImageData ì¶”ì¶œ
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                mode2ReferenceImage = ctx.getImageData(0, 0, canvas.width, canvas.height);

                mode2ImageStatus.textContent = `âœ… ${file.name} (${img.width}x${img.height})`;
                mode2ImageStatus.style.color = '#28a745';

                // ê°ì§€ê¸°ê°€ ìˆìœ¼ë©´ ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸
                if (sceneChangeDetector) {
                    sceneChangeDetector.mode2ReferenceImage = mode2ReferenceImage;
                    console.log(`âœ… ëª¨ë“œ2 ì°¸ì¡° ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ: ${img.width}x${img.height}`);
                    addLog(`âœ… ëª¨ë“œ2 ì°¸ì¡° ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ: ${file.name}`, 'success');
                }

                URL.revokeObjectURL(img.src);
            } catch (err) {
                mode2ImageStatus.textContent = 'âŒ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨';
                mode2ImageStatus.style.color = '#dc3545';
                console.error('ëª¨ë“œ2 ì´ë¯¸ì§€ ë¡œë“œ ì˜¤ë¥˜:', err);
            }
        });

        // í…œí”Œë¦¿ ìœ ì‚¬ë„ ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸
        templateSimilarity.addEventListener('input', (e) => {
            const value = e.target.value;
            document.getElementById('similarityValue').textContent = `${value}%`;

            // í˜„ì¬ ë§¤ì²˜ê°€ ìˆìœ¼ë©´ ìœ ì‚¬ë„ ì—…ë°ì´íŠ¸
            if (templateMatcher) {
                templateMatcher.similarityThreshold = value / 100;
            }
        });

        // í…œí”Œë¦¿ ì—…ë¡œë“œ ë²„íŠ¼ í´ë¦­
        uploadTemplateBtn.addEventListener('click', () => {
            templateImageInput.click();
        });

        // í…œí”Œë¦¿ ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ
        templateImageInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const img = new Image();
                const reader = new FileReader();

                reader.onload = (event) => {
                    img.onload = () => {
                        // ìº”ë²„ìŠ¤ì— ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        // ImageData ì €ì¥
                        templateImage = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        templateStatus.textContent = `âœ… ${file.name} (${img.width}x${img.height})`;
                        templateStatus.style.color = '#27ae60';

                        console.log(`âœ… í…œí”Œë¦¿ ì´ë¯¸ì§€ ë¡œë“œ ì™„ë£Œ: ${img.width}x${img.height}`);
                    };
                    img.src = event.target.result;
                };

                reader.readAsDataURL(file);
            } catch (err) {
                console.error('í…œí”Œë¦¿ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨:', err);
                templateStatus.textContent = 'âŒ ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨';
                templateStatus.style.color = '#e74c3c';
            }
        });

        // GitHub APIë¥¼ ì‚¬ìš©í•˜ì—¬ ë§ˆì§€ë§‰ ì»¤ë°‹ ë‚ ì§œ ê°€ì ¸ì˜¤ê¸°
        async function updateLastUpdateDate() {
            const owner = 'Goldloom';
            const repo = 'audio-recorder';
            const path = 'index.html';
            const url = `https://api.github.com/repos/${owner}/${repo}/commits?path=${path}&page=1&per_page=1`;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const commits = await response.json();
                if (commits && commits.length > 0) {
                    const lastCommitDate = new Date(commits[0].commit.committer.date);
                    const formattedDate = lastCommitDate.getFullYear() + '-' +
                        String(lastCommitDate.getMonth() + 1).padStart(2, '0') + '-' +
                        String(lastCommitDate.getDate()).padStart(2, '0') + ' ' +
                        String(lastCommitDate.getHours()).padStart(2, '0') + ':' +
                        String(lastCommitDate.getMinutes()).padStart(2, '0');
                    document.getElementById('lastUpdate').textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${formattedDate}`;
                } else {
                    // ì»¤ë°‹ ì •ë³´ê°€ ì—†ì„ ë•Œ
                    document.getElementById('lastUpdate').textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ì •ë³´ ì—†ìŒ`;
                }
            } catch (error) {
                console.error('ì—…ë°ì´íŠ¸ ë‚ ì§œë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤:', error);
                // ì—ëŸ¬ ë°œìƒ ì‹œ í˜„ì¬ ë‚ ì§œ í‘œì‹œ
                const now = new Date();
                const formattedDate = now.getFullYear() + '-' +
                    String(now.getMonth() + 1).padStart(2, '0') + '-' +
                    String(now.getDate()).padStart(2, '0') + ' ' +
                    String(now.getHours()).padStart(2, '0') + ':' +
                    String(now.getMinutes()).padStart(2, '0');
                document.getElementById('lastUpdate').textContent = `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${formattedDate} (ë¡œì»¬)`;
            }
        }

        updateLastUpdateDate();
        drawVisualizer();

        function checkBrowserSupport() {
            const hasMediaDevices = !!(navigator.mediaDevices);
            const hasGetDisplayMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia);
            const isSecure = window.isSecureContext;
            const protocol = window.location.protocol;

            if (!hasMediaDevices || !hasGetDisplayMedia) {
                let reason = "ì´ ë¸Œë¼ìš°ì €ëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.";

                if (!isSecure && protocol !== 'localhost:' && protocol !== '127.0.0.1:') {
                    reason = "ë³´ì•ˆ ì—°ê²°(HTTPS) í™˜ê²½ì´ ì•„ë‹ˆì–´ì„œ ê¸°ëŠ¥ì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ì£¼ì†Œì°½ì˜ ì£¼ì†Œê°€ https:// ë¡œ ì‹œì‘í•˜ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.";
                } else if (protocol === 'file:') {
                    reason = "ë¡œì»¬ íŒŒì¼(file://)ë¡œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. ì›¹ ì„œë²„(http://localhost ë“±)ë¥¼ í†µí•´ ì‹¤í–‰í•´ì•¼ ê¸°ëŠ¥ì´ ì‘ë™í•©ë‹ˆë‹¤.";
                } else if (/Android|iPhone|iPad/i.test(navigator.userAgent)) {
                    reason = "ëª¨ë°”ì¼ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. PCë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.";
                }

                const debugInfo = `(ì§„ë‹¨: MD=${hasMediaDevices}, GDM=${hasGetDisplayMedia}, Sec=${isSecure}, Proto=${protocol})`;
                updateStatus('error', `âŒ ${reason} ${debugInfo}`);
                recordBtn.disabled = true;
            }
        }

        checkBrowserSupport();
    </script>

</body>

</html>