<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ë…¹ìŒê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            position: relative;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 24px;
            padding: 40px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.4);
        }

        h1 {
            text-align: center;
            color: #1a1a2e;
            margin-bottom: 8px;
            font-size: 28px;
            font-weight: 600;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
            font-size: 14px;
        }

        .help-icon {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            cursor: help;
        }

        .help-icon:hover .tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .tooltip {
            position: absolute;
            top: 35px;
            right: 0;
            background: #1a1a2e;
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            line-height: 1.6;
            width: 280px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .tooltip strong {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .tooltip ol {
            margin-left: 18px;
            padding: 0;
        }

        .tooltip li {
            margin-bottom: 4px;
        }

        .source-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
        }

        .source-btn {
            flex: 1;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .source-btn:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }

        .source-btn.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .source-btn .icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .source-btn .label {
            font-size: 13px;
            font-weight: 600;
        }

        .source-btn .desc {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 3px;
        }

        .visualizer-container {
            background: #1a1a2e;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 25px;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #visualizer {
            width: 100%;
            height: 60px;
        }

        .timer {
            text-align: center;
            font-size: 48px;
            font-weight: 300;
            color: #1a1a2e;
            margin-bottom: 25px;
            font-family: 'Courier New', monospace;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-record {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .btn-record.recording {
            animation: pulse 1.5s infinite;
        }

        .btn-stop {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .btn-pause {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            50% { box-shadow: 0 0 0 20px rgba(231, 76, 60, 0); }
        }

        .btn svg {
            width: 28px;
            height: 28px;
            fill: white;
        }

        .status {
            text-align: center;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 14px;
            font-weight: 500;
        }

        .status.ready {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .status.recording {
            background: #ffebee;
            color: #c62828;
        }

        .status.paused {
            background: #fff8e1;
            color: #f57f17;
        }

        .status.error {
            background: #fce4ec;
            color: #c2185b;
        }

        .recordings {
            max-height: 300px;
            overflow-y: auto;
        }

        .recordings h2 {
            color: #1a1a2e;
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .recordings-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-download-all {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-download-all:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        .btn-download-all:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recording-item {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .recording-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .recording-info {
            flex: 1;
        }

        .recording-name {
            font-weight: 600;
            color: #1a1a2e;
            font-size: 14px;
        }

        .recording-meta {
            font-size: 12px;
            color: #888;
            margin-top: 3px;
        }

        .recording-badge {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 20px;
            font-weight: 600;
        }

        .badge-system {
            background: #e3f2fd;
            color: #1565c0;
        }

        .badge-mic {
            background: #fce4ec;
            color: #c2185b;
        }

        .badge-both {
            background: #f3e5f5;
            color: #7b1fa2;
        }

        .recording-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .btn-small:hover {
            transform: scale(1.1);
        }

        .btn-small svg {
            width: 18px;
            height: 18px;
            fill: white;
        }

        .btn-download {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .btn-delete {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .recording-item audio {
            width: 100%;
            height: 40px;
            border-radius: 8px;
        }

        .empty-state {
            text-align: center;
            color: #888;
            padding: 30px;
            font-size: 14px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-item input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-item label {
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }

        .extra-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn-new-lecture {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-new-lecture:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }

        .btn-new-lecture:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
            padding: 10px 15px;
            border-radius: 10px;
        }

        .toggle-label {
            font-size: 13px;
            color: #333;
            font-weight: 500;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        .silence-indicator {
            font-size: 11px;
            color: #888;
            margin-left: 5px;
        }

        .silence-indicator.active {
            color: #27ae60;
            font-weight: 600;
        }

        .capture-section {
            background: #fff3e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .capture-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .capture-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .capture-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .capture-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
        }

        .capture-option select {
            padding: 5px 8px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 12px;
            cursor: pointer;
            background: white;
        }

        .capture-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .capture-status {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .capture-status.active {
            color: #e65100;
            font-weight: 500;
        }

        .curriculum-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            position: relative;
        }

        .curriculum-help {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .curriculum-help-icon {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
        }

        .curriculum-help-icon:hover + .curriculum-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .curriculum-tooltip {
            position: absolute;
            top: 25px;
            left: 0;
            background: #1a1a2e;
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: 12px;
            line-height: 1.7;
            width: 320px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 100;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .curriculum-tooltip strong {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #f093fb;
        }

        .curriculum-tooltip code {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }

        .curriculum-tooltip ul {
            margin: 8px 0;
            padding-left: 18px;
        }

        .curriculum-tooltip li {
            margin-bottom: 4px;
        }

        .curriculum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .curriculum-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .speed-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-selector label {
            font-size: 13px;
            color: #555;
        }

        .speed-selector select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 13px;
            cursor: pointer;
            background: white;
        }

        .curriculum-textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            margin-bottom: 10px;
        }

        .curriculum-textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .curriculum-textarea::placeholder {
            color: #aaa;
        }

        .btn-parse {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-parse:hover {
            transform: scale(1.02);
        }

        .chapter-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .chapter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .chapter-item.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .chapter-item.completed {
            background: #d4edda;
            color: #155724;
        }

        .chapter-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 10px;
        }

        .chapter-time {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            opacity: 0.8;
        }

        .chapter-progress {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            text-align: center;
        }

        .clear-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
        }

        .clear-btn:hover {
            background: #c0392b;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 12px 15px;
            border-radius: 10px;
            font-size: 12px;
            margin-bottom: 20px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§ ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ë…¹ìŒê¸°</h1>
        <p class="subtitle">ì˜¨ë¼ì¸ ê°•ì˜, ìœ íŠœë¸Œ, ìŒì•… ë“± ì»´í“¨í„° ì†Œë¦¬ë¥¼ ë…¹ìŒí•˜ì„¸ìš”</p>

        <div class="help-icon">
            ?
            <div class="tooltip">
                <strong>ğŸ“Œ ì‚¬ìš© ë°©ë²•</strong>
                <ol>
                    <li>ë…¹ìŒ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</li>
                    <li>ê³µìœ  ì°½ì—ì„œ <strong>"Chrome íƒ­"</strong> ë˜ëŠ” <strong>"ì „ì²´ í™”ë©´"</strong> ì„ íƒ</li>
                    <li><strong>"ì˜¤ë””ì˜¤ ê³µìœ "</strong> ì²´í¬ âœ…</li>
                    <li>ê³µìœ  ë²„íŠ¼ í´ë¦­ í›„ ë…¹ìŒ ì‹œì‘!</li>
                </ol>
            </div>
        </div>

        <div class="warning">
            âš ï¸ <strong>Chrome, Edge ë¸Œë¼ìš°ì €</strong>ì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤. Firefox, SafariëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
        </div>

        <div class="checkbox-group">
            <div class="checkbox-item">
                <input type="checkbox" id="includeSystemAudio" checked>
                <label for="includeSystemAudio">ğŸ”Š ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤</label>
            </div>
            <div class="checkbox-item">
                <input type="checkbox" id="includeMic">
                <label for="includeMic">ğŸ¤ ë§ˆì´í¬ (ë‚´ ëª©ì†Œë¦¬)</label>
            </div>
        </div>

        <div id="status" class="status ready">ì¤€ë¹„ë¨ - ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”</div>

        <div class="extra-controls">
            <div class="toggle-container">
                <span class="toggle-label">ğŸ”‡ ë¬´ìŒ ê°ì§€ ìë™ë¶„í• </span>
                <label class="toggle-switch">
                    <input type="checkbox" id="silenceDetection">
                    <span class="toggle-slider"></span>
                </label>
                <span id="silenceIndicator" class="silence-indicator"></span>
            </div>
            <button class="btn-new-lecture" id="newLectureBtn" disabled>
                ğŸ“š ìƒˆ ê°•ì˜
            </button>
        </div>

        <div class="capture-section">
            <div class="capture-header">
                <div class="capture-toggle">
                    <span class="capture-title">ğŸ“¸ ì´ë¯¸ì§€ ìº¡ì²˜</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="captureEnabled">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                <div class="capture-options">
                    <div class="capture-option">
                        <label>ê°„ê²©:</label>
                        <select id="captureInterval">
                            <option value="1">1ì´ˆ</option>
                            <option value="2">2ì´ˆ</option>
                            <option value="5" selected>5ì´ˆ</option>
                            <option value="10">10ì´ˆ</option>
                        </select>
                    </div>
                    <div class="capture-option">
                        <label>í’ˆì§ˆ:</label>
                        <select id="captureQuality">
                            <option value="0.9">ê³ í™”ì§ˆ</option>
                            <option value="0.7" selected>ì¤‘í™”ì§ˆ</option>
                            <option value="0.5">ì €í™”ì§ˆ</option>
                        </select>
                    </div>
                </div>
            </div>
            <div id="captureStatus" class="capture-status"></div>
        </div>

        <div class="curriculum-section">
            <div class="curriculum-header">
                <span class="curriculum-title">
                    <span class="curriculum-help">
                        ğŸ“‹ ê°•ì˜ ëª©ì°¨ (ì„ íƒì‚¬í•­)
                        <span class="curriculum-help-icon">?</span>
                        <div class="curriculum-tooltip">
                            <strong>ğŸ“Œ ëª©ì°¨ ì…ë ¥ ë°©ë²•</strong>
                            ê°•ì˜ ì‚¬ì´íŠ¸ì—ì„œ ëª©ì°¨ë¥¼ ë³µì‚¬í•´ì„œ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.
                            <ul>
                                <li><code>55</code> â†’ ê°•ì˜ ë²ˆí˜¸</li>
                                <li><code>Part 4. Advanced</code> â†’ íŒŒíŠ¸ëª…</li>
                                <li><code>Ch01. ì œëª©</code> â†’ ì±•í„°ëª… (ì‹œê°„ ì—†ìŒ)</li>
                                <li><code>CH01-1. ì œëª© 7:58</code> â†’ ì†Œì±•í„° (ì‹œê°„ í•„ìˆ˜)</li>
                            </ul>
                            <strong>ğŸ’¾ ì €ì¥ë˜ëŠ” íŒŒì¼ëª… ì˜ˆì‹œ</strong>
                            <code>55 Part 4 - Ch01 - CH01-1. ì œëª©.webm</code>
                            <br><br>
                            â© ë°°ì† ì„¤ì •í•˜ë©´ ìë™ìœ¼ë¡œ ì‹¤ì œ ë…¹ìŒ ì‹œê°„ ê³„ì‚°ë¨
                        </div>
                    </span>
                </span>
                <div class="speed-selector">
                    <label>ì¬ìƒ ë°°ì†:</label>
                    <select id="playbackSpeed">
                        <option value="1">1ë°°ì†</option>
                        <option value="1.25">1.25ë°°ì†</option>
                        <option value="1.5">1.5ë°°ì†</option>
                        <option value="1.75">1.75ë°°ì†</option>
                        <option value="2" selected>2ë°°ì†</option>
                        <option value="2.5">2.5ë°°ì†</option>
                        <option value="3">3ë°°ì†</option>
                    </select>
                </div>
            </div>
            <textarea id="curriculumInput" class="curriculum-textarea" placeholder="ê°•ì˜ ëª©ì°¨ë¥¼ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”. ì˜ˆì‹œ:

001
Part 1. ê¸°ì´ˆí¸
Ch01. ì˜¤ë¦¬ì—”í…Œì´ì…˜
01. ê°•ì˜ ì†Œê°œ 5:00
02. í•™ìŠµ ë°©ë²• ì•ˆë‚´ 7:30"></textarea>
            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <button class="btn-parse" id="parseBtn">ëª©ì°¨ ë¶„ì„</button>
                <button class="clear-btn" id="clearBtn">ì´ˆê¸°í™”</button>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 13px; cursor: pointer;">
                    <input type="checkbox" id="autoStopCheckbox" checked style="width: 16px; height: 16px;">
                    ëª©ì°¨ ëë‚˜ë©´ ìë™ ì¢…ë£Œ
                </label>
            </div>
            <div id="chapterList" class="chapter-list"></div>
            <div id="chapterProgress" class="chapter-progress"></div>
        </div>

        <div class="visualizer-container">
            <canvas id="visualizer"></canvas>
        </div>

        <div class="timer" id="timer">00:00:00</div>

        <div class="controls">
            <button class="btn btn-record" id="recordBtn" title="ë…¹ìŒ ì‹œì‘">
                <svg viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="8"/>
                </svg>
            </button>
            <button class="btn btn-pause" id="pauseBtn" disabled title="ì¼ì‹œì •ì§€">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="4" width="4" height="16"/>
                    <rect x="14" y="4" width="4" height="16"/>
                </svg>
            </button>
            <button class="btn btn-stop" id="stopBtn" disabled title="ì •ì§€">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="6" width="12" height="12"/>
                </svg>
            </button>
        </div>

        <div class="recordings">
            <h2>
                <span class="recordings-title">ğŸ“ ë…¹ìŒ íŒŒì¼</span>
                <button class="btn-download-all" id="downloadAllBtn" disabled>
                    â¬‡ï¸ ì „ì²´ ë‹¤ìš´ë¡œë“œ
                </button>
            </h2>
            <div id="recordingsList">
                <div class="empty-state">ë…¹ìŒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>
            </div>
        </div>
    </div>

    <script>
        let mediaRecorder;
        let audioChunks = [];
        let recordings = [];
        let startTime;
        let timerInterval;
        let isPaused = false;
        let pausedTime = 0;
        let audioContext;
        let analyser;
        let dataArray;
        let animationId;
        let streams = [];
        let silenceStart = null;
        let silenceThreshold = 15; // ë³¼ë¥¨ ì„ê³„ê°’ (0-255)
        let silenceDuration = 4000; // 4ì´ˆ ë¬´ìŒ ì‹œ ë¶„í• 
        let lectureCount = 1;

        const recordBtn = document.getElementById('recordBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const timerDisplay = document.getElementById('timer');
        const recordingsList = document.getElementById('recordingsList');
        const statusDisplay = document.getElementById('status');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        const includeSystemAudio = document.getElementById('includeSystemAudio');
        const includeMic = document.getElementById('includeMic');
        const silenceDetection = document.getElementById('silenceDetection');
        const silenceIndicator = document.getElementById('silenceIndicator');
        const newLectureBtn = document.getElementById('newLectureBtn');
        const curriculumInput = document.getElementById('curriculumInput');
        const parseBtn = document.getElementById('parseBtn');
        const clearBtn = document.getElementById('clearBtn');
        const chapterList = document.getElementById('chapterList');
        const chapterProgress = document.getElementById('chapterProgress');
        const playbackSpeed = document.getElementById('playbackSpeed');
        const autoStopCheckbox = document.getElementById('autoStopCheckbox');
        const captureEnabled = document.getElementById('captureEnabled');
        const captureInterval = document.getElementById('captureInterval');
        const captureQuality = document.getElementById('captureQuality');
        const captureStatus = document.getElementById('captureStatus');
        const downloadAllBtn = document.getElementById('downloadAllBtn');

        let chapters = [];
        let currentChapterIndex = 0;
        let chapterStartTime = 0;
        let chapterTimers = [];
        
        // ìº¡ì²˜ ê´€ë ¨ ë³€ìˆ˜
        let captureTimer = null;
        let capturedImages = [];
        let captureCount = 0;
        let videoStream = null;
        let videoElement = null;
        
        // ë¶„í•  ëŒ€ê¸° ìƒíƒœ ë³€ìˆ˜ë“¤
        let chapterReadyToSplit = false;
        let waitingForSilence = false;
        let pendingSplitChapterIndex = -1;
        let readyToAutoStop = false;
        let silenceStartForSplit = null;
        const silenceDurationForSplit = 3000; // 3ì´ˆ ë¬´ìŒ

        function updateStatus(state, message) {
            statusDisplay.className = 'status ' + state;
            statusDisplay.textContent = message;
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateTimer() {
            if (!isPaused) {
                const elapsed = Date.now() - startTime + pausedTime;
                timerDisplay.textContent = formatTime(elapsed);
            }
        }

        function setupVisualizer() {
            // ê¸°ì¡´ contextê°€ ìˆìœ¼ë©´ ë‹«ê¸°
            if (audioContext) {
                audioContext.close().catch(() => {});
            }
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            analyser.smoothingTimeConstant = 0.8;
            
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            
            // ëª¨ë“  ì˜¤ë””ì˜¤ íŠ¸ë™ì„ ì—°ê²°
            streams.forEach(s => {
                if (s.getAudioTracks().length > 0) {
                    try {
                        const source = audioContext.createMediaStreamSource(s);
                        source.connect(analyser);
                    } catch (e) {
                        console.log('Stream already connected or invalid');
                    }
                }
            });
            
            // ì‹œê°í™” ì‹œì‘
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            drawVisualizer();
        }

        function drawVisualizer() {
            animationId = requestAnimationFrame(drawVisualizer);
            
            canvas.width = canvas.offsetWidth * 2;
            canvas.height = canvas.offsetHeight * 2;
            canvasCtx.scale(2, 2);
            
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            
            canvasCtx.fillStyle = '#1a1a2e';
            canvasCtx.fillRect(0, 0, width, height);
            
            if (!analyser || !dataArray) {
                // ë…¹ìŒ ì „ ê¸°ë³¸ ë¼ì¸ í‘œì‹œ
                canvasCtx.strokeStyle = '#667eea';
                canvasCtx.lineWidth = 2;
                canvasCtx.beginPath();
                canvasCtx.moveTo(0, height / 2);
                canvasCtx.lineTo(width, height / 2);
                canvasCtx.stroke();
                return;
            }
            
            analyser.getByteFrequencyData(dataArray);
            
            // ë¬´ìŒ ê°ì§€ ë¡œì§ (ìˆ˜ë™ ë¬´ìŒ ê°ì§€ ëª¨ë“œ)
            if (silenceDetection.checked && mediaRecorder && mediaRecorder.state === 'recording' && !waitingForSilence) {
                const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
                
                if (average < silenceThreshold) {
                    if (!silenceStart) {
                        silenceStart = Date.now();
                    } else {
                        const silentTime = Date.now() - silenceStart;
                        silenceIndicator.textContent = `(ë¬´ìŒ ${(silentTime / 1000).toFixed(1)}ì´ˆ)`;
                        silenceIndicator.className = 'silence-indicator active';
                        
                        if (silentTime >= silenceDuration) {
                            // ë¬´ìŒ ê°ì§€ë¨ - ìƒˆ ê°•ì˜ë¡œ ë¶„í• 
                            splitRecording();
                            silenceStart = null;
                            silenceIndicator.textContent = '(ìë™ ë¶„í• ë¨!)';
                        }
                    }
                } else {
                    silenceStart = null;
                    silenceIndicator.textContent = '';
                    silenceIndicator.className = 'silence-indicator';
                }
            }
            
            // ì±•í„° ì‹œê°„ ê¸°ë°˜ + ë¬´ìŒ ê°ì§€ (ëª©ì°¨ê°€ ìˆì„ ë•Œ)
            if (waitingForSilence && mediaRecorder && mediaRecorder.state === 'recording') {
                const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
                
                if (average < silenceThreshold) {
                    if (!silenceStartForSplit) {
                        silenceStartForSplit = Date.now();
                    } else {
                        const silentTime = Date.now() - silenceStartForSplit;
                        silenceIndicator.textContent = `(ë¬´ìŒ ${(silentTime / 1000).toFixed(1)}ì´ˆ / 3ì´ˆ)`;
                        silenceIndicator.className = 'silence-indicator active';
                        
                        if (silentTime >= silenceDurationForSplit) {
                            // 3ì´ˆ ë¬´ìŒ ê°ì§€ë¨
                            if (readyToAutoStop) {
                                // ë§ˆì§€ë§‰ ì±•í„° í›„ ìë™ ì¢…ë£Œ
                                updateStatus('ready', 'âœ… ëª¨ë“  ê°•ì˜ ë…¹ìŒ ì™„ë£Œ! ìë™ ì¢…ë£Œë¨');
                                stopRecording();
                            } else if (chapterReadyToSplit && pendingSplitChapterIndex >= 0) {
                                // ë‹¤ìŒ ì±•í„°ë¡œ ë¶„í• 
                                currentChapterIndex = pendingSplitChapterIndex + 1;
                                splitRecordingWithName(chapters[pendingSplitChapterIndex].name);
                                renderChapters();
                                
                                // ìƒíƒœ ì´ˆê¸°í™”
                                chapterReadyToSplit = false;
                                waitingForSilence = false;
                                pendingSplitChapterIndex = -1;
                                silenceIndicator.textContent = '(ë¶„í•  ì™„ë£Œ!)';
                            }
                            silenceStartForSplit = null;
                        }
                    }
                } else {
                    silenceStartForSplit = null;
                    if (waitingForSilence) {
                        silenceIndicator.textContent = '(ë¬´ìŒ ëŒ€ê¸° ì¤‘...)';
                        silenceIndicator.className = 'silence-indicator active';
                    }
                }
            }
            
            const barCount = 64;
            const barWidth = width / barCount;
            const gap = 2;
            
            for (let i = 0; i < barCount; i++) {
                const dataIndex = Math.floor(i * dataArray.length / barCount);
                const barHeight = (dataArray[dataIndex] / 255) * height * 0.9;
                
                const x = i * barWidth;
                const y = height - barHeight;
                
                const gradient = canvasCtx.createLinearGradient(0, y, 0, height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(0.5, '#764ba2');
                gradient.addColorStop(1, '#f093fb');
                
                canvasCtx.fillStyle = gradient;
                canvasCtx.fillRect(x + gap/2, y, barWidth - gap, barHeight);
            }
        }

        function mergeAudioStreams(streams) {
            const ctx = new AudioContext();
            const dest = ctx.createMediaStreamDestination();
            
            streams.forEach(stream => {
                if (stream.getAudioTracks().length > 0) {
                    const source = ctx.createMediaStreamSource(stream);
                    source.connect(dest);
                }
            });
            
            return dest.stream;
        }

        async function startRecording() {
            const wantSystem = includeSystemAudio.checked;
            const wantMic = includeMic.checked;

            if (!wantSystem && !wantMic) {
                updateStatus('error', 'âŒ ìµœì†Œ í•˜ë‚˜ì˜ ì˜¤ë””ì˜¤ ì†ŒìŠ¤ë¥¼ ì„ íƒí•˜ì„¸ìš”');
                return;
            }

            try {
                streams = [];
                let recordingType = '';
                
                // Get system audio via screen capture
                if (wantSystem) {
                    try {
                        const displayStream = await navigator.mediaDevices.getDisplayMedia({
                            video: true,
                            audio: {
                                echoCancellation: false,
                                noiseSuppression: false,
                                autoGainControl: false
                            }
                        });
                        
                        // Check if audio track exists
                        const audioTracks = displayStream.getAudioTracks();
                        if (audioTracks.length === 0) {
                            displayStream.getTracks().forEach(track => track.stop());
                            updateStatus('error', 'âŒ ì˜¤ë””ì˜¤ ê³µìœ ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ê³  "ì˜¤ë””ì˜¤ ê³µìœ "ë¥¼ ì²´í¬í•´ì£¼ì„¸ìš”.');
                            return;
                        }
                        
                        // ìº¡ì²˜ ê¸°ëŠ¥ì´ ì¼œì ¸ ìˆìœ¼ë©´ ë¹„ë””ì˜¤ íŠ¸ë™ ìœ ì§€
                        if (captureEnabled.checked) {
                            const videoTracks = displayStream.getVideoTracks();
                            if (videoTracks.length > 0) {
                                videoStream = new MediaStream(videoTracks);
                                setupVideoCapture(videoStream);
                            }
                        } else {
                            // ìº¡ì²˜ ë¹„í™œì„±í™”ë©´ ë¹„ë””ì˜¤ íŠ¸ë™ ì¤‘ì§€
                            displayStream.getVideoTracks().forEach(track => track.stop());
                        }
                        
                        // Create audio-only stream
                        const audioStream = new MediaStream(audioTracks);
                        streams.push(audioStream);
                        recordingType = 'system';
                        
                        // Handle when user stops sharing
                        audioTracks[0].onended = () => {
                            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                                stopRecording();
                            }
                        };
                    } catch (err) {
                        if (err.name === 'NotAllowedError') {
                            updateStatus('ready', 'ì·¨ì†Œë¨ - í™”ë©´ ê³µìœ ê°€ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤');
                            return;
                        }
                        throw err;
                    }
                }
                
                // Get microphone audio
                if (wantMic) {
                    const micStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    streams.push(micStream);
                    recordingType = recordingType === 'system' ? 'both' : 'mic';
                }
                
                // Merge streams if multiple
                let finalStream;
                if (streams.length > 1) {
                    finalStream = mergeAudioStreams(streams);
                } else {
                    finalStream = streams[0];
                }
                
                setupVisualizer();
                
                // Setup MediaRecorder
                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                    ? 'audio/webm;codecs=opus' 
                    : 'audio/webm';
                    
                mediaRecorder = new MediaRecorder(finalStream, { mimeType });
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    saveRecording(audioBlob, recordingType);
                    cleanup();
                };
                
                mediaRecorder.start(1000); // Collect data every second
                startTime = Date.now();
                pausedTime = 0;
                isPaused = false;
                timerInterval = setInterval(updateTimer, 100);
                
                recordBtn.classList.add('recording');
                recordBtn.disabled = true;
                pauseBtn.disabled = false;
                stopBtn.disabled = false;
                newLectureBtn.disabled = false;
                includeSystemAudio.disabled = true;
                includeMic.disabled = true;
                currentRecordingType = recordingType;
                lectureCount = 1;
                
                // ì±•í„° ê¸°ë°˜ ìë™ ë¶„í•  ì‹œì‘
                if (chapters.length > 0) {
                    startChapterTimers();
                    const firstChapter = chapters[0];
                    updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (${firstChapter.name})`);
                } else {
                    const sourceText = recordingType === 'both' ? 'ì‹œìŠ¤í…œ + ë§ˆì´í¬' : 
                                       recordingType === 'system' ? 'ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤' : 'ë§ˆì´í¬';
                    updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (ê°•ì˜ ${lectureCount}, ${sourceText})`);
                }
                
            } catch (err) {
                console.error('ë…¹ìŒ ì‹œì‘ ì˜¤ë¥˜:', err);
                cleanup();
                
                if (err.name === 'NotAllowedError') {
                    updateStatus('error', 'âŒ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”.');
                } else if (err.name === 'NotSupportedError') {
                    updateStatus('error', 'âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome ë˜ëŠ” Edgeë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.');
                } else {
                    updateStatus('error', `âŒ ì˜¤ë¥˜: ${err.message}`);
                }
            }
        }

        function cleanup() {
            streams.forEach(stream => {
                stream.getTracks().forEach(track => track.stop());
            });
            streams = [];
            
            if (audioContext) {
                audioContext.close().catch(() => {});
                audioContext = null;
            }
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            analyser = null;
            dataArray = null;
            
            // ìº¡ì²˜ ì •ë¦¬
            stopCapture();
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
            }
            if (videoElement) {
                videoElement.remove();
                videoElement = null;
            }
        }

        // ë¹„ë””ì˜¤ ìº¡ì²˜ ì„¤ì •
        function setupVideoCapture(stream) {
            videoElement = document.createElement('video');
            videoElement.srcObject = stream;
            videoElement.muted = true;
            videoElement.play();
            
            capturedImages = [];
            captureCount = 0;
            
            // ë¹„ë””ì˜¤ê°€ ì¤€ë¹„ë˜ë©´ ìº¡ì²˜ ì‹œì‘
            videoElement.onloadedmetadata = () => {
                startCapture();
            };
        }

        // ìº¡ì²˜ ì‹œì‘
        function startCapture() {
            if (!captureEnabled.checked || !videoElement) return;
            
            const interval = parseInt(captureInterval.value) * 1000;
            
            captureTimer = setInterval(() => {
                captureFrame();
            }, interval);
            
            updateCaptureStatus();
        }

        // í”„ë ˆì„ ìº¡ì²˜
        function captureFrame() {
            if (!videoElement || videoElement.readyState < 2) return;
            
            const canvas = document.createElement('canvas');
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoElement, 0, 0);
            
            const quality = parseFloat(captureQuality.value);
            const imageData = canvas.toDataURL('image/jpeg', quality);
            
            capturedImages.push(imageData);
            captureCount++;
            
            updateCaptureStatus();
        }

        // ìº¡ì²˜ ì¤‘ì§€
        function stopCapture() {
            if (captureTimer) {
                clearInterval(captureTimer);
                captureTimer = null;
            }
        }

        // ìº¡ì²˜ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateCaptureStatus() {
            if (captureEnabled.checked && captureTimer) {
                captureStatus.className = 'capture-status active';
                captureStatus.textContent = `ğŸ“¸ ìº¡ì²˜ ì¤‘... (${captureCount}ì¥)`;
            } else if (capturedImages.length > 0) {
                captureStatus.className = 'capture-status';
                captureStatus.textContent = `ì´ ${capturedImages.length}ì¥ ìº¡ì²˜ë¨`;
            } else {
                captureStatus.className = 'capture-status';
                captureStatus.textContent = '';
            }
        }

        // PDF íŒŒì¼ ìƒì„± ë° ì €ì¥
        async function saveImagesAsPdf(images, fileName) {
            if (images.length === 0) return;
            
            // jsPDF ë¼ì´ë¸ŒëŸ¬ë¦¬ ë™ì  ë¡œë“œ
            if (typeof jspdf === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                document.head.appendChild(script);
                await new Promise(resolve => script.onload = resolve);
            }
            
            const { jsPDF } = jspdf;
            
            // ì²« ë²ˆì§¸ ì´ë¯¸ì§€ë¡œ í¬ê¸° ê²°ì •
            const firstImg = await loadImage(images[0]);
            const imgWidth = firstImg.width;
            const imgHeight = firstImg.height;
            
            // PDF ë°©í–¥ ê²°ì • (ê°€ë¡œ/ì„¸ë¡œ)
            const orientation = imgWidth > imgHeight ? 'landscape' : 'portrait';
            const pdf = new jsPDF({
                orientation: orientation,
                unit: 'px',
                format: [imgWidth, imgHeight]
            });
            
            for (let i = 0; i < images.length; i++) {
                if (i > 0) {
                    pdf.addPage([imgWidth, imgHeight], orientation);
                }
                
                const img = await loadImage(images[i]);
                pdf.addImage(images[i], 'JPEG', 0, 0, imgWidth, imgHeight);
                
                // ì§„í–‰ ìƒíƒœ ì—…ë°ì´íŠ¸
                captureStatus.textContent = `ğŸ“„ PDF ìƒì„± ì¤‘... (${i + 1}/${images.length})`;
            }
            
            pdf.save(fileName + '.pdf');
            captureStatus.textContent = `âœ… PDF ì €ì¥ ì™„ë£Œ (${images.length}ì¥)`;
        }
        
        // ì´ë¯¸ì§€ ë¡œë“œ í—¬í¼
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function pauseRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.pause();
                isPaused = true;
                pausedTime += Date.now() - startTime;
                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <polygon points="5,3 19,12 5,21"/>
                    </svg>
                `;
                pauseBtn.title = 'ê³„ì†';
                updateStatus('paused', 'â¸ï¸ ì¼ì‹œì •ì§€ë¨');
            } else if (mediaRecorder && mediaRecorder.state === 'paused') {
                mediaRecorder.resume();
                isPaused = false;
                startTime = Date.now();
                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                `;
                pauseBtn.title = 'ì¼ì‹œì •ì§€';
                updateStatus('recording', 'ğŸ”´ ë…¹ìŒ ì¤‘...');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                clearInterval(timerInterval);
                
                recordBtn.classList.remove('recording');
                recordBtn.disabled = false;
                pauseBtn.disabled = true;
                stopBtn.disabled = true;
                newLectureBtn.disabled = true;
                includeSystemAudio.disabled = false;
                includeMic.disabled = false;
                silenceIndicator.textContent = '';
                silenceStart = null;
                clearChapterTimers();
                currentChapterIndex = 0;
                renderChapters();
                
                pauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <rect x="6" y="4" width="4" height="16"/>
                        <rect x="14" y="4" width="4" height="16"/>
                    </svg>
                `;
                pauseBtn.title = 'ì¼ì‹œì •ì§€';
                
                timerDisplay.textContent = '00:00:00';
                updateStatus('ready', 'âœ… ë…¹ìŒ ì™„ë£Œ! ìƒˆ ë…¹ìŒì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
            }
        }

        function saveRecording(blob, type) {
            const now = new Date();
            const name = `ê°•ì˜${lectureCount}_${now.toLocaleDateString('ko-KR')}_${now.toLocaleTimeString('ko-KR').replace(/:/g, '-')}`;
            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type
            };
            
            recordings.unshift(recording);
            renderRecordings();
            
            // ìº¡ì²˜ëœ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ PDFë¡œ ì €ì¥
            if (capturedImages.length > 0) {
                saveImagesAsPdf([...capturedImages], name);
                capturedImages = [];
                captureCount = 0;
                updateCaptureStatus();
            }
        }

        function getTypeBadge(type) {
            switch(type) {
                case 'system':
                    return '<span class="recording-badge badge-system">ğŸ”Š ì‹œìŠ¤í…œ</span>';
                case 'mic':
                    return '<span class="recording-badge badge-mic">ğŸ¤ ë§ˆì´í¬</span>';
                case 'both':
                    return '<span class="recording-badge badge-both">ğŸ§ ì‹œìŠ¤í…œ+ë§ˆì´í¬</span>';
                default:
                    return '';
            }
        }

        function renderRecordings() {
            if (recordings.length === 0) {
                recordingsList.innerHTML = '<div class="empty-state">ë…¹ìŒëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤</div>';
                downloadAllBtn.disabled = true;
                return;
            }
            
            downloadAllBtn.disabled = false;
            
            recordingsList.innerHTML = recordings.map(rec => `
                <div class="recording-item" data-id="${rec.id}">
                    <div class="recording-header">
                        <div class="recording-info">
                            <div class="recording-name">${rec.name}</div>
                            <div class="recording-meta">${rec.date} ${getTypeBadge(rec.type)}</div>
                        </div>
                        <div class="recording-actions">
                            <button class="btn-small btn-download" onclick="downloadRecording(${rec.id})" title="ë‹¤ìš´ë¡œë“œ">
                                <svg viewBox="0 0 24 24">
                                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                                </svg>
                            </button>
                            <button class="btn-small btn-delete" onclick="deleteRecording(${rec.id})" title="ì‚­ì œ">
                                <svg viewBox="0 0 24 24">
                                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                    <audio controls src="${rec.url}"></audio>
                </div>
            `).join('');
        }

        // ì „ì²´ ë‹¤ìš´ë¡œë“œ
        async function downloadAllRecordings() {
            if (recordings.length === 0) return;
            
            downloadAllBtn.disabled = true;
            downloadAllBtn.textContent = 'â³ ë‹¤ìš´ë¡œë“œ ì¤‘...';
            
            // JSZip ë¼ì´ë¸ŒëŸ¬ë¦¬ ë™ì  ë¡œë“œ
            if (typeof JSZip === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                document.head.appendChild(script);
                await new Promise(resolve => script.onload = resolve);
            }
            
            const zip = new JSZip();
            
            for (let i = 0; i < recordings.length; i++) {
                const rec = recordings[i];
                const arrayBuffer = await rec.blob.arrayBuffer();
                zip.file(rec.name + '.webm', arrayBuffer);
                downloadAllBtn.textContent = `â³ ${i + 1}/${recordings.length}`;
            }
            
            const content = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(content);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `ë…¹ìŒíŒŒì¼_${new Date().toLocaleDateString('ko-KR')}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            downloadAllBtn.disabled = false;
            downloadAllBtn.innerHTML = 'â¬‡ï¸ ì „ì²´ ë‹¤ìš´ë¡œë“œ';
        }

        downloadAllBtn.addEventListener('click', downloadAllRecordings);

        function downloadRecording(id) {
            const recording = recordings.find(r => r.id === id);
            if (recording) {
                const a = document.createElement('a');
                a.href = recording.url;
                a.download = recording.name + '.webm';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        }

        function deleteRecording(id) {
            const index = recordings.findIndex(r => r.id === id);
            if (index !== -1) {
                URL.revokeObjectURL(recordings[index].url);
                recordings.splice(index, 1);
                renderRecordings();
            }
        }

        recordBtn.addEventListener('click', startRecording);
        pauseBtn.addEventListener('click', pauseRecording);
        stopBtn.addEventListener('click', stopRecording);
        newLectureBtn.addEventListener('click', () => splitRecording());

        // ë…¹ìŒ ë¶„í•  í•¨ìˆ˜ (ìƒˆ ê°•ì˜ ë²„íŠ¼ ë˜ëŠ” ë¬´ìŒ ê°ì§€)
        function splitRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                // í˜„ì¬ ë…¹ìŒ ì €ì¥
                mediaRecorder.stop();
                
                // ì•½ê°„ì˜ ë”œë ˆì´ í›„ ìƒˆ ë…¹ìŒ ì‹œì‘
                setTimeout(() => {
                    if (streams.length > 0 && streams.some(s => s.active)) {
                        lectureCount++;
                        audioChunks = [];
                        
                        let finalStream;
                        if (streams.length > 1) {
                            finalStream = mergeAudioStreams(streams);
                        } else {
                            finalStream = streams[0];
                        }
                        
                        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                            ? 'audio/webm;codecs=opus' 
                            : 'audio/webm';
                        
                        mediaRecorder = new MediaRecorder(finalStream, { mimeType });
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: mimeType });
                            saveRecording(audioBlob, currentRecordingType);
                        };
                        
                        mediaRecorder.start(1000);
                        startTime = Date.now();
                        pausedTime = 0;
                        
                        updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (ê°•ì˜ ${lectureCount})`);
                    }
                }, 100);
            }
        }

        let currentRecordingType = '';

        // ê°•ì˜ ëª©ì°¨ íŒŒì‹±
        function parseCurriculum(text) {
            const lines = text.trim().split('\n');
            const parsed = [];
            
            // ì‹œê°„ íŒ¨í„´: MM:SS ë˜ëŠ” H:MM:SS
            const timeOnlyPattern = /^(\d{1,2}):(\d{2})(?::(\d{2}))?$/;
            const timeInLinePattern = /(\d{1,2}):(\d{2})(?::(\d{2}))?/;
            
            // íŒ¨í„´ë“¤
            const courseNumberPattern = /^(\d+)\s*$/; // ê°•ì˜ ë²ˆí˜¸ (ìˆ«ìë§Œ ìˆëŠ” ì¤„)
            const partPattern = /^(Part\s*\d+[.\s\-]*.*?)$/i;
            const chapterTitlePattern = /^(Ch(?:apter)?\s*\d+)[.\s]+(.+)$/i; // Ch01. ì œëª© (ì‹œê°„ ì—†ëŠ” ê²ƒ)
            const subChapterPattern = /^(CH?\d+[-]\d+)[.\s]*(.*)$/i; // CH01-01. ì œëª©
            const progressPattern = /^\d+\/\d+$/; // 2/3 ê°™ì€ ì§„í–‰ë¥  íŒ¨í„´
            const quizPattern = /^ë¯¸ì œì¶œ|í€´ì¦ˆ|ê³¼ì œ|ì œì¶œ/; // í€´ì¦ˆ/ê³¼ì œ íŒ¨í„´
            
            let courseNumber = '';
            let currentPart = '';
            let currentChapter = '';
            let pendingTitle = null; // ë‹¤ìŒ ì¤„ ì‹œê°„ì„ ê¸°ë‹¤ë¦¬ëŠ” ì œëª©
            let pendingSubChapter = null; // CH01-01 í˜•ì‹ì˜ ì†Œì±•í„°
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                if (!line) continue;
                
                // ì§„í–‰ë¥  íŒ¨í„´ ë¬´ì‹œ (2/3 ê°™ì€ ê²ƒ)
                if (progressPattern.test(line)) {
                    continue;
                }
                
                // í€´ì¦ˆ/ê³¼ì œ íŒ¨í„´ ë¬´ì‹œ
                if (quizPattern.test(line)) {
                    continue;
                }
                
                // ì‹œê°„ë§Œ ìˆëŠ” ì¤„ (ì´ì „ ì œëª©ì˜ ì‹œê°„)
                if (timeOnlyPattern.test(line) && pendingTitle) {
                    const timeMatch = line.match(timeOnlyPattern);
                    let minutes, seconds;
                    if (timeMatch[3]) {
                        minutes = parseInt(timeMatch[1]) * 60 + parseInt(timeMatch[2]);
                        seconds = parseInt(timeMatch[3]);
                    } else {
                        minutes = parseInt(timeMatch[1]);
                        seconds = parseInt(timeMatch[2]);
                    }
                    const totalSeconds = minutes * 60 + seconds;
                    
                    // ì „ì²´ íŒŒì¼ëª… ìƒì„±
                    let fullName = '';
                    if (courseNumber) fullName += courseNumber + ' ';
                    if (currentPart) fullName += currentPart + ' - ';
                    if (currentChapter) fullName += currentChapter + ' - ';
                    fullName += pendingTitle;
                    
                    parsed.push({
                        name: fullName,
                        shortName: pendingTitle,
                        originalDuration: totalSeconds,
                        adjustedDuration: 0
                    });
                    
                    pendingTitle = null;
                    continue;
                }
                
                // ê°•ì˜ ë²ˆí˜¸ (ìˆ«ìë§Œ)
                if (courseNumberPattern.test(line)) {
                    courseNumber = line;
                    pendingTitle = null;
                    continue;
                }
                
                // Part ì¸ì‹
                const partMatch = line.match(partPattern);
                if (partMatch && !timeInLinePattern.test(line)) {
                    currentPart = partMatch[1].replace(/\s+/g, ' ').trim();
                    const partNumMatch = currentPart.match(/Part\s*(\d+)/i);
                    if (partNumMatch) {
                        currentPart = `Part ${partNumMatch[1]}`;
                    }
                    pendingTitle = null;
                    continue;
                }
                
                // Chapter ì œëª© ì¸ì‹ (Ch01. ì œëª© í˜•ì‹, ì‹œê°„ ì—†ëŠ” ê²ƒ)
                const chTitleMatch = line.match(chapterTitlePattern);
                if (chTitleMatch && !timeInLinePattern.test(line)) {
                    const chNumMatch = chTitleMatch[1].match(/Ch(?:apter)?\s*(\d+)/i);
                    if (chNumMatch) {
                        currentChapter = `Ch${chNumMatch[1].padStart(2, '0')}`;
                    }
                    pendingTitle = null;
                    continue;
                }
                
                // CH01-01. ì œëª© í˜•ì‹ (ì†Œì±•í„°, ì‹œê°„ì€ ë‹¤ìŒ ì¤„ì— ìˆì„ ìˆ˜ ìˆìŒ)
                const subChMatch = line.match(subChapterPattern);
                if (subChMatch && !timeInLinePattern.test(line)) {
                    const subChNum = subChMatch[1].toUpperCase(); // CH01-01
                    const subChTitle = subChMatch[2] || '';
                    
                    // CH01-01ì—ì„œ Ch01 ì¶”ì¶œí•´ì„œ í˜„ì¬ ì±•í„° ì—…ë°ì´íŠ¸
                    const chFromSub = subChNum.match(/CH?(\d+)-/i);
                    if (chFromSub) {
                        currentChapter = `Ch${chFromSub[1].padStart(2, '0')}`;
                    }
                    
                    pendingTitle = subChNum + (subChTitle ? '. ' + subChTitle : '');
                    continue;
                }
                
                // ì‹œê°„ì´ ê°™ì€ ì¤„ì— ìˆëŠ” ê²½ìš°
                const timeMatch = line.match(timeInLinePattern);
                if (timeMatch) {
                    let minutes, seconds;
                    if (timeMatch[3]) {
                        minutes = parseInt(timeMatch[1]) * 60 + parseInt(timeMatch[2]);
                        seconds = parseInt(timeMatch[3]);
                    } else {
                        minutes = parseInt(timeMatch[1]);
                        seconds = parseInt(timeMatch[2]);
                    }
                    const totalSeconds = minutes * 60 + seconds;
                    
                    let name = line.replace(timeInLinePattern, '').trim();
                    name = name.replace(/[\s\-â€“â€”:]+$/, '').trim();
                    
                    if (name) {
                        // CH01-01 í˜•ì‹ì¸ì§€ í™•ì¸í•˜ê³  ì±•í„° ì—…ë°ì´íŠ¸
                        const subChInLine = name.match(/^(CH?(\d+)-\d+)/i);
                        if (subChInLine) {
                            currentChapter = `Ch${subChInLine[2].padStart(2, '0')}`;
                        }
                        
                        let fullName = '';
                        if (courseNumber) fullName += courseNumber + ' ';
                        if (currentPart) fullName += currentPart + ' - ';
                        if (currentChapter) fullName += currentChapter + ' - ';
                        fullName += name;
                        
                        parsed.push({
                            name: fullName,
                            shortName: name,
                            originalDuration: totalSeconds,
                            adjustedDuration: 0
                        });
                    }
                    pendingTitle = null;
                } else {
                    // ì‹œê°„ì´ ì—†ëŠ” ì¤„ - ë‹¤ìŒ ì¤„ì— ì‹œê°„ì´ ì˜¬ ìˆ˜ ìˆìŒ
                    pendingTitle = line;
                }
            }
            
            return parsed;
        }
            
            return parsed;
        }

        // ë°°ì†ì— ë”°ë¥¸ ì‹œê°„ ì¡°ì •
        function adjustChapterTimes() {
            const speed = parseFloat(playbackSpeed.value);
            chapters.forEach(ch => {
                ch.adjustedDuration = Math.round(ch.originalDuration / speed);
            });
        }

        // ì±•í„° ëª©ë¡ ë Œë”ë§
        function renderChapters() {
            if (chapters.length === 0) {
                chapterList.innerHTML = '';
                chapterProgress.innerHTML = '';
                return;
            }

            adjustChapterTimes();
            
            chapterList.innerHTML = chapters.map((ch, idx) => {
                const originalTime = formatTimeShort(ch.originalDuration);
                const adjustedTime = formatTimeShort(ch.adjustedDuration);
                let className = 'chapter-item';
                if (idx < currentChapterIndex) className += ' completed';
                if (idx === currentChapterIndex && mediaRecorder?.state === 'recording') className += ' active';
                
                // ëª©ë¡ì—ëŠ” ì§§ì€ ì´ë¦„ í‘œì‹œ
                const displayName = ch.shortName || ch.name;
                
                return `
                    <div class="${className}" title="${ch.name}">
                        <span class="chapter-name">${idx + 1}. ${displayName}</span>
                        <span class="chapter-time">${originalTime} â†’ ${adjustedTime}</span>
                    </div>
                `;
            }).join('');

            const totalOriginal = chapters.reduce((sum, ch) => sum + ch.originalDuration, 0);
            const totalAdjusted = chapters.reduce((sum, ch) => sum + ch.adjustedDuration, 0);
            chapterProgress.innerHTML = `ì´ ${chapters.length}ê°œ ì±•í„° | ì›ë³¸: ${formatTimeShort(totalOriginal)} â†’ ì‹¤ì œ: ${formatTimeShort(totalAdjusted)}`;
        }

        function formatTimeShort(seconds) {
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // ì±•í„° ê¸°ë°˜ ìë™ ë¶„í•  ì‹œì‘
        function startChapterTimers() {
            if (chapters.length === 0) return;
            
            clearChapterTimers();
            currentChapterIndex = 0;
            chapterStartTime = Date.now();
            chapterReadyToSplit = false;
            waitingForSilence = false;
            renderChapters();
            
            // ì±•í„° ì‹œê°„ì´ ë˜ë©´ ë¶„í•  ëŒ€ê¸° ìƒíƒœë¡œ ì „í™˜ (ì‹¤ì œ ë¶„í• ì€ ë¬´ìŒ ê°ì§€ ì‹œ)
            let accumulatedTime = 0;
            
            for (let i = 0; i < chapters.length - 1; i++) {
                accumulatedTime += chapters[i].adjustedDuration * 1000;
                
                const chapterIndex = i;
                const timer = setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        // ë¶„í•  ëŒ€ê¸° ìƒíƒœë¡œ ì „í™˜
                        chapterReadyToSplit = true;
                        waitingForSilence = true;
                        pendingSplitChapterIndex = chapterIndex;
                        updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (${chapters[chapterIndex].shortName || chapters[chapterIndex].name}) - â³ ë¬´ìŒ ëŒ€ê¸° ì¤‘`);
                    }
                }, accumulatedTime);
                
                chapterTimers.push(timer);
            }
            
            // ë§ˆì§€ë§‰ ì±•í„° ëë‚˜ë©´ ìë™ ì¢…ë£Œ ëŒ€ê¸°
            if (autoStopCheckbox.checked) {
                accumulatedTime += chapters[chapters.length - 1].adjustedDuration * 1000;
                
                const autoStopTimer = setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        // ìë™ ì¢…ë£Œ ëŒ€ê¸° ìƒíƒœ
                        readyToAutoStop = true;
                        waitingForSilence = true;
                        updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (ë§ˆì§€ë§‰ ì±•í„°) - â³ ë¬´ìŒ ëŒ€ê¸° í›„ ì¢…ë£Œ`);
                    }
                }, accumulatedTime);
                
                chapterTimers.push(autoStopTimer);
            }
        }
        
        function clearChapterTimers() {
            chapterTimers.forEach(t => clearTimeout(t));
            chapterTimers = [];
            chapterReadyToSplit = false;
            waitingForSilence = false;
            pendingSplitChapterIndex = -1;
            readyToAutoStop = false;
            silenceStartForSplit = null;
        }

        // ì±•í„°ëª…ìœ¼ë¡œ ë…¹ìŒ ë¶„í• 
        function splitRecordingWithName(chapterName) {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                const saveName = chapterName;
                
                // ìº¡ì²˜ ì¼ì‹œ ì¤‘ì§€ ë° í˜„ì¬ ì´ë¯¸ì§€ ì €ì¥ ì¤€ë¹„
                stopCapture();
                const imagesToSave = [...capturedImages];
                capturedImages = [];
                captureCount = 0;
                
                // í˜„ì¬ ë…¹ìŒ ì¤‘ì§€ (ì´ë¦„ ì§€ì •)
                mediaRecorder.onstop = () => {
                    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                        ? 'audio/webm;codecs=opus' 
                        : 'audio/webm';
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    saveRecordingWithNameAndImages(audioBlob, currentRecordingType, saveName, imagesToSave);
                    audioChunks = [];
                };
                
                mediaRecorder.stop();
                
                // ìƒˆ ë…¹ìŒ ì‹œì‘
                setTimeout(() => {
                    if (streams.length > 0 && streams.some(s => s.active)) {
                        let finalStream;
                        if (streams.length > 1) {
                            finalStream = mergeAudioStreams(streams);
                        } else {
                            finalStream = streams[0];
                        }
                        
                        const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
                            ? 'audio/webm;codecs=opus' 
                            : 'audio/webm';
                        
                        mediaRecorder = new MediaRecorder(finalStream, { mimeType });
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: mimeType });
                            // ë§ˆì§€ë§‰ ì±•í„° ì´ë¦„ìœ¼ë¡œ ì €ì¥
                            const lastName = chapters[currentChapterIndex]?.name || `ê°•ì˜${lectureCount}`;
                            saveRecordingWithName(audioBlob, currentRecordingType, lastName);
                        };
                        
                        mediaRecorder.start(1000);
                        startTime = Date.now();
                        pausedTime = 0;
                        
                        // ìº¡ì²˜ ë‹¤ì‹œ ì‹œì‘
                        if (captureEnabled.checked && videoElement) {
                            startCapture();
                        }
                        
                        const nextChapter = chapters[currentChapterIndex];
                        updateStatus('recording', `ğŸ”´ ë…¹ìŒ ì¤‘... (${nextChapter?.name || ''})`);
                    }
                }, 100);
            }
        }

        function saveRecordingWithNameAndImages(blob, type, name, images) {
            const now = new Date();
            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type
            };
            
            recordings.unshift(recording);
            renderRecordings();
            
            // ìº¡ì²˜ëœ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ PDFë¡œ ì €ì¥
            if (images && images.length > 0) {
                saveImagesAsPdf(images, name);
            }
        }

        function saveRecordingWithName(blob, type, name) {
            const now = new Date();
            const recording = {
                id: Date.now(),
                blob: blob,
                name: name,
                date: now.toLocaleString('ko-KR'),
                url: URL.createObjectURL(blob),
                type: type
            };
            
            recordings.unshift(recording);
            renderRecordings();
            
            // ìº¡ì²˜ëœ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ PDFë¡œ ì €ì¥
            if (capturedImages.length > 0) {
                saveImagesAsPdf([...capturedImages], name);
                capturedImages = [];
                captureCount = 0;
                updateCaptureStatus();
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        parseBtn.addEventListener('click', () => {
            const text = curriculumInput.value;
            chapters = parseCurriculum(text);
            currentChapterIndex = 0;
            renderChapters();
            
            if (chapters.length > 0) {
                updateStatus('ready', `âœ… ${chapters.length}ê°œ ì±•í„° ì¸ì‹ë¨`);
            } else {
                updateStatus('ready', 'âš ï¸ ì±•í„°ë¥¼ ì¸ì‹í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì‹œê°„(MM:SS)ì´ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.');
            }
        });

        clearBtn.addEventListener('click', () => {
            curriculumInput.value = '';
            chapters = [];
            currentChapterIndex = 0;
            clearChapterTimers();
            renderChapters();
            updateStatus('ready', 'ì¤€ë¹„ë¨ - ë…¹ìŒ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”');
        });

        playbackSpeed.addEventListener('change', () => {
            renderChapters();
        });

        // Initialize visualizer
        drawVisualizer();

        // Check browser support
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            updateStatus('error', 'âŒ ì´ ë¸Œë¼ìš°ì €ëŠ” ì‹œìŠ¤í…œ ì˜¤ë””ì˜¤ ìº¡ì²˜ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Chrome ë˜ëŠ” Edgeë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”.');
            recordBtn.disabled = true;
        }
    </script>
</body>
</html>
